<!DOCTYPE html>
<html lang="en">

<head>
    <header>
        <link rel= "icon" type= "image/png" href="./game-icon.png" />
    </header>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game Center Beta</title>
    <canvas id="Canvas" width="device-width" height="100%"></canvas>
    <script src = "src/main.js"></script>
    <style>
        .btn-game-action {
            /* Ensures the scale change and shadow change are smooth */
            transition: all 0.2s ease-in-out;
            transform: scale(1);
        }

        .btn-game-action:hover {
            /* Slightly enlarges the button and increases the shadow on hover/press */
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
    </style>
    <style>
        .btn-game-action-1 {
            transition: all 0.5s ease-in-out;
            transform: scale(2);
        }

        .btn-game-action:hover {
            /* Does the same thing as lines 25-29 */
            transform: scale(1.1);
            box-shadow: 0 4px 15 px rgba(0, 0, 0, 1)
        }
        .btn-game-action:open {
            /* creates a effect if you open a app it shows a animation */
            transform: scale(2000)
        }
    </style>
    <style>
        /* Epilepsy mode animation uses the above colors. Applied when body has .epilepsy-mode */
        @keyframes epilepsyFlash {
            0% {
                background-color: var(--epilepsy-color1);
            }

            50% {
                background-color: var(--epilepsy-color2);
            }

            100% {
                background-color: var(--epilepsy-color1);
            }
        }

        html.epilepsy-mode {
            animation: epilepsyFlash var(--epilepsy-speed) 0.001s !important;
        }

        html.epilepsy-mode body {
            background: none !important;
        }

        /* Button to toggle epilepsy mode */
        .epilepsyBtn {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 9999;
            padding: 8px 12px;
            background: red;
            color: #000;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            box-shadow: 0 6px 16px RGBa(0, 0, 0, 0.015);
            font-weight: 700;
        }

        .epilepsyBtn.active {
            background: #ff4444;
            color: #fff;
        }


        html,
        body {
            height: 100%;
            margin: 0;
            background: #ffffff;
            color: var(--ink);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        .wrap {
            min-height: 100%;
            display: block;
            padding: 0;
        }

        /* Start Screen */
        .startScreen {
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
        }

        .startScreen h1 {
            font-size: 48px;
            color: white;
            margin: 0 0 20px 0;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .startScreen p {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            margin: 0 0 40px 0;
        }

        .gamesGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            max-width: 1000px;
            width: 100%;
        }

        .gameCard {
            background: white;
            border-radius: 20px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            text-align: center;
        }

        .gameCard:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25);
        }

        .gameCard .icon {
            font-size: 49px;
            margin-bottom: 15px;
        }

        .gameCard .title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0 0 8px 0;
        }

        .gameCard .desc {
            font-size: 14px;
            color: #666;
            margin: 0;
        }

        .gameView {
            display: none;
            background: radial-gradient(1200px 800px at 70% 30%, #0c1326 0%, #0a0f1d 45%, #090e19 100%);
            background: repeating-linear-gradient(45deg, #0c1326, #0c1326 10px, #1a2b4a 10px, #1a2b4a 20px);
        }

        .gameView.active {
            display: block;
        }

        .backToHome {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 100001;
            cursor: pointer;
            padding: 10px 18px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(15, 22, 40, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            color: var(--ink);
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .backToHome:hover {
            background: rgba(20, 30, 50, 0.95);
            border-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .calc {
            width: 100vw;
            max-width: 100vw;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 0;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .calc[data-bg-mode="solid"] {
            background: var(--calc-bg-color1);
        }

        .calc[data-bg-mode="gradient"] {
            background: linear-gradient(var(--calc-bg-angle), var(--calc-bg-color1), var(--calc-bg-color2));
        }

        .tabs {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 12px 12px 0 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tab {
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--ink);
            font-size: 14px;
        }

        .tab.active {
            background: rgba(102, 170, 255, 0.18);
            border-color: rgba(102, 170, 255, 0.35);
        }

        .panel {
            display: none;
        }

        .panel.active {
            display: block;
        }

        .spacer {
            flex: 1;
        }

        .display {
            padding: 20px 18px 12px 18px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: linear-gradient(180deg, #0e172d, #0d1426);
        }

        .expr {
            min-height: 26px;
            color: var(--muted);
            font-size: 16px;
            letter-spacing: 0.3px;
            word-break: break-word;
        }

        .result {
            min-height: 60px;
            font-size: 48px;
            line-height: 1.1;
            font-weight: 600;
            word-break: break-word;
        }

        .keypad {
            padding: 10px 14px 14px 14px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--grid-gap);
        }

        button {
            cursor: pointer;
            appearance: none;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, var(--btn), var(--btn2));
            color: var(--ink);
            font-size: 20px;
            padding: 16px 12px;
            border-radius: 12px;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.25);
            transition: transform 0.03s ease, filter 0.15s ease;
        }

        .keypad button {
            min-height: 112px;
        }

        button:active {
            transform: translateY(1px);
        }

        .op {
            color: #b0c6ff;
        }

        .wide {
            grid-column: span 2;
        }

        .accent {
            background: linear-gradient(180deg, #264d8e, #1d3d72);
            border-color: #2a539a;
        }

        .danger {
            background: linear-gradient(180deg, #442027, #32161c);
            border-color: #5a2b34;
            color: #ffc5c5;
        }

        .footer {
            padding: 8px 14px 14px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--muted);
            font-size: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            color: var(--ink);
        }

        .settingsBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(15, 22, 40, 0.9);
            backdrop-filter: blur(10px);
            color: var(--ink);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            z-index: 9998;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .settingsBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(102, 170, 255, 0.4);
        }

        /* Color picker controls */
        .colorControls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            padding: 6px 0
        }

        .colorControls label {
            font-size: 11px;
            color: var(--muted)
        }

        .colorControls input[type="color"] {
            cursor: pointer;
            width: 32px;
            height: 32px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            background: transparent;
            padding: 0
        }

        .colorControls input[type="range"] {
            width: 80px
        }

        .colorControls .modeToggle {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            font-size: 11px;
            transition: background 0.15s ease
        }

        .colorControls .modeToggle.active {
            background: rgba(102, 170, 255, 0.2);
            border-color: rgba(102, 170, 255, 0.3)
        }

        .colorStop {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 4px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08)
        }

        .colorStop input[type="range"] {
            width: 60px
        }

        .colorStop button {
            padding: 2px 6px;
            font-size: 10px;
            min-height: 20px
        }

        .colorStops {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center
        }

        .addColorBtn {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(34, 197, 94, 0.15);
            font-size: 11px;
            color: var(--ok)
        }

        /* Settings Modal */
        .settingsModal {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: block;
            z-index: 99999;
            perspective: 2000px;
            overflow: auto
        }

        .flipContainer {
            width: 100vw;
            min-height: 100vh;
            position: relative;
            transition: transform 0.8s;
            transform-style: preserve-3d
        }

        .flipContainer.flipped {
            transform: rotateY(180deg)
        }

        .calcSide,
        .settingsSide {
            position: absolute;
            inset: 0;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden
        }

        .settingsSide {
            transform: rotateY(180deg);
            background: var(--bg);
            overflow-y: auto;
            padding: 20px;
        }

        .settingsContent {
            max-width: 800px;
            margin: 0 auto;
            background: var(--panel);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow)
        }

        .settingsContent h2 {
            margin: 0 0 16px 0;
            font-size: 22px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px
        }

        .settingsContent h3 {
            margin: 16px 0 8px 0;
            font-size: 16px;
            color: var(--accent)
        }

        .settingsSection {
            margin-bottom: 20px
        }

        .settingRow {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 8px 0;
            flex-wrap: wrap
        }

        .settingRow label {
            min-width: 80px;
            font-size: 13px
        }

        .backToCalc {
            cursor: pointer;
            padding: 10px 20px;
            border-radius: 8px;
            background: var(--accent);
            color: #fff;
            border: none;
            font-size: 14px;
            margin-bottom: 20px;
            display: inline-block
        }

        /* Zoom & Pan - Starts at 1x (normal size), can zoom 1x to 1,000,000x */
        .calcWrapper {
            transform-origin: center center;
            transition: transform 0.08s ease-out;
            will-change: transform
        }

        .calcWrapper.dragging {
            transition: none;
            cursor: grabbing
        }

        .calcWrapper.locked {
            pointer-events: none
        }

        .calcWrapper.locked .calc {
            pointer-events: auto
        }

        /* Lock button */
        .lockBtn {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 100000;
            cursor: pointer;
            padding: 8px 14px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(15, 22, 40, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            color: var(--ink);
            font-size: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3)
        }

        .lockBtn:hover {
            background: rgba(20, 30, 50, 0.95);
            border-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.05)
        }

        .lockBtn.locked {
            background: rgba(255, 107, 107, 0.2);
            border-color: rgba(255, 107, 107, 0.4);
            color: #ff6b6b
        }

        /* Wide, short layout on large screens */
        @media (min-width: 1024px) {
            .keypad {
                grid-template-columns: repeat(8, 1fr);
            }

            .result {
                font-size: 56px;
                min-height: 72px;
            }

            .keypad button {
                min-height: 128px;
                font-size: 21px;
                padding: 18px 14px
            }

            .tab {
                font-size: 13px
            }
        }

        /* Graph panel */
        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap
        }

        .field {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .field input,
        .practice select {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: #0b142a;
            color: var(--ink)
        }

        .graphwrap {
            padding: 12px
        }

        #graph {
            background: #0b1122;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            width: 100%;
            height: 360px;
            display: block
        }

        /* Fun preset interactive effects */
        @keyframes rippleExpand {
            from {
                transform: scale(0);
                opacity: .35
            }

            to {
                transform: scale(1);
                opacity: 0
            }
        }

        @keyframes resCatch {
            0% {
                transform: scale(1);
                text-shadow: none
            }

            40% {
                transform: scale(1.08);
                text-shadow: 0 6px 18px rgba(255, 184, 107, 0.35)
            }

            100% {
                transform: scale(1);
                text-shadow: none
            }
        }

        @keyframes shardFall {
            to {
                transform: translate(var(--dx, 0px), 120vh) rotate(var(--rot, 0deg));
                opacity: 0
            }
        }
        @keyframes doomsday {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            5% {
                transform: translate(var(--dx, 0px), var(--dy, 0px)) rotate(var(--rot, 0deg)) scale(1);
                opacity: 1;
                filter: blur(4592678), 
                hue-rotate(360deg), 
                saturate(666),
                sepia(100);
            }
            10% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px), 
                hue-rotate(0deg), 
                saturate(100),
                sepia(0),
                translate(999,999,999),
                translate(-999,-999,-999),
                translate(0,0,0);
            }
            15% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px), 
                hue-rotate(0deg), 
                saturate(100),
                sepia(5423867904358967245387692435876245387643589764357865439985743),
                brightness(infinity),
                brightness(1);
            }
            20% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px), 
                hue-rotate(0deg), 
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg)
            }
            25% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1e+10),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                blur(infinity)
                opacity(-1)
                opacity(1)
                opacity(-infinity)
                opacity(1)
            }
            30% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8); 
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(infinity)
            }
            35% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                hue-rotate(-1)
            }
            40% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
                blur(blur(9223372036854775807px))
        }
        45% {
            transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
    }
}

        @keyframes explodeParticle {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }

            30% {
                transform: translate(var(--dx, 0px), var(--dy, 0px)) rotate(var(--rot, 0deg)) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes buttonExplosion {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 14px rgba(0, 0, 0, 0.25);
            }

            20% {
                transform: scale(1.15);
                box-shadow: 0 0 30px var(--accent), 0 0 15px var(--accent) inset;
            }

            40% {
                transform: scale(0.95);
                box-shadow: 0 4px 14px rgba(0, 0, 0, 0.25);
            }

            60% {
                transform: scale(1.05);
                box-shadow: 0 0 20px var(--accent);
            }
        }

        @keyframes resultFlash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            40% {
                transform: scale(1.05);
                filter: brightness(1.3);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        /* Elements created at runtime */
        .fun-ripple {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0));
            pointer-events: none;
            transform: scale(0);
            animation: rippleExpand 600ms ease-out forwards;
        }

        .fun-flyClone {
            position: fixed;
            z-index: 999;
            pointer-events: none;
            font-weight: 700;
            color: var(--accent);
            filter: drop-shadow(0 6px 16px rgba(255, 184, 107, 0.28));
        }

        .fun-shards {
            position: fixed;
            inset: auto 0 0 0;
            pointer-events: none;
            z-index: 999;
        }

        .fun-shard {
            position: fixed;
            color: var(--accent);
            will-change: transform, opacity;
            font-size: clamp(28px, 4vw, 52px);
            font-weight: 800;
        }

        .result.fun-flash {
            animation: resCatch 600ms ease-out;
        }

        /* keep ripples contained to buttons while in fun theme */
        body.theme-fun .keypad button {
            position: relative;
            overflow: hidden
        }

        /* Practice */
        .practice {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .practice .problem {
            padding: 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08)
        }

        .okBadge {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5)
        }

        .errBadge {
            background: rgba(255, 107, 107, 0.2);
            border-color: rgba(255, 107, 107, 0.5)
        }

        /* Drawing Studio */
        .drawPanel {
            padding: 12px;
            display: flex;
            gap: 12px;
            height: calc(100vh - 160px);
            overflow: hidden
        }

        .drawToolbar {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            padding: 12px;
            width: 220px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.08)
        }

        .drawToolbar h3 {
            font-size: 12px;
            color: var(--muted);
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 1px
        }

        .drawToolSection {
            margin-bottom: 16px
        }

        .drawToolsGrid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px
        }

        .drawToolBtn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 11px
        }

        .drawToolBtn:hover {
            background: rgba(102, 170, 255, 0.15);
            border-color: rgba(102, 170, 255, 0.3)
        }

        .drawToolBtn.active {
            background: rgba(102, 170, 255, 0.2);
            border-color: rgba(102, 170, 255, 0.4);
            color: var(--accent)
        }

        .drawToolIcon {
            font-size: 20px;
            margin-bottom: 4px
        }

        .drawCanvasArea {
            flex: 1;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.08)
        }

        #drawCanvas {
            background: #fff;
            border-radius: 8px;
            cursor: crosshair;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3)
        }

        .drawControls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap
        }

        .drawBtn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            color: var(--ink);
            transition: all 0.2s
        }

        .drawBtn:hover {
            background: rgba(102, 170, 255, 0.15);
            border-color: rgba(102, 170, 255, 0.3)
        }

        .colorPickerWrap {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .colorPickerInput {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            cursor: pointer
        }

        .colorPresets {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-top: 8px
        }

        .colorPreset {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.12);
            transition: all 0.2s
        }

        .colorPreset:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.3)
        }

        .sliderWrap {
            margin-top: 8px
        }

        .sliderLabel {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 4px
        }

        .drawSlider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            appearance: none
        }

        .drawSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer
        }

        .drawSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none
        }

        .canvasOverlay {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px
        }

        .aiPanel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(15, 22, 40, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 12px;
            display: none
        }

        .aiPanel.active {
            display: block
        }

        .aiPrompt {
            width: 100%;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            padding: 8px;
            color: var(--ink);
            font-size: 12px;
            resize: none
        }

        .aiOptions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap
        }

        .rulerOverlay {
            position: absolute;
            pointer-events: none;
            z-index: 100
        }

        .rulerH {
            height: 2px;
            background: rgba(255, 170, 0, 0.8);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.6)
        }

        .rulerV {
            width: 2px;
            background: rgba(255, 170, 0, 0.8);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.6)
        }

        /* Password Game */
        .passwordGame {
            padding: 40px 20px;
            max-width: 800px;
            margin: 0 auto;
            min-height: 100vh
        }

        .passwordGame h2 {
            font-size: 32px;
            color: var(--ink);
            margin: 0 0 10px 0;
            text-align: center
        }

        .passwordGame .subtitle {
            font-size: 16px;
            color: var(--muted);
            margin: 0 0 30px 0;
            text-align: center
        }

        .passwordCard {
            background: var(--panel);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: var(--shadow)
        }

        .passwordCard h3 {
            font-size: 18px;
            color: var(--accent);
            margin: 0 0 15px 0
        }

        .settingGroup {
            margin-bottom: 20px
        }

        .settingGroup label {
            display: block;
            font-size: 14px;
            color: var(--muted);
            margin-bottom: 8px
        }

        .settingGroup input[type="number"],
        .settingGroup input[type="text"] {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.04);
            color: var(--ink);
            font-size: 14px
        }

        .checkboxList {
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        .checkboxItem {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: pointer;
            transition: all 0.2s
        }

        .checkboxItem:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15)
        }

        .checkboxItem input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--accent)
        }

        .checkboxItem label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            color: var(--ink)
        }

        .passwordDisplay {
            background: rgba(255, 255, 255, 0.06);
            border: 2px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 4px;
            word-break: break-all;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace
        }

        .guessInput {
            width: 100%;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.04);
            color: var(--ink);
            font-size: 18px;
            text-align: center;
            letter-spacing: 2px;
            font-family: monospace
        }

        .guessInput:focus {
            outline: none;
            border-color: var(--accent)
        }

        .btnGroup {
            display: flex;
            gap: 10px;
            flex-wrap: wrap
        }

        .gameBtn {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: linear-gradient(180deg, var(--btn), var(--btn2));
            color: var(--ink);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s
        }

        .gameBtn:hover {
            filter: brightness(1.2);
            transform: translateY(-2px)
        }

        .gameBtn.primary {
            background: linear-gradient(180deg, #264d8e, #1d3d72);
            border-color: #2a539a
        }

        .gameBtn.success {
            background: linear-gradient(180deg, #22c55e, #16a34a);
            border-color: #22c55e
        }

        .gameBtn.danger {
            background: linear-gradient(180deg, #ef4444, #dc2626);
            border-color: #ef4444
        }

        .attemptsCounter {
            text-align: center;
            font-size: 16px;
            color: var(--muted);
            margin: 15px 0
        }

        .attemptsCounter span {
            color: var(--accent);
            font-weight: 600
        }

        .feedback {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            margin-top: 15px;
            display: none
        }

        .feedback.show {
            display: block
        }

        .feedback.correct {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: #22c55e
        }

        .feedback.wrong {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #ef4444
        }

        .feedback.hint {
            background: rgba(102, 170, 255, 0.2);
            border: 1px solid rgba(102, 170, 255, 0.5);
            color: var(--accent)
        }

        .hintsList {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08)
        }

        .hintsList h4 {
            margin: 0 0 10px 0;
            color: var(--accent);
            font-size: 14px
        }

        .hintsList ul {
            margin: 0;
            padding-left: 20px;
            color: var(--muted)
        }

        .hintsList li {
            margin: 5px 0
        }

        /* Color Selector Circle */
        .colorSelectorModal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100000
        }

        .colorSelectorModal.active {
            display: flex
        }

        .colorSelectorContainer {
            background: var(--panel);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 500px
        }

        .colorSelectorContainer h3 {
            margin: 0 0 20px 0;
            color: var(--ink);
            text-align: center
        }

        .colorCircle {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            position: relative;
            margin: 0 auto 20px auto;
            cursor: crosshair;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3)
        }

        .colorCircle canvas {
            width: 100%;
            height: 100%;
            border-radius: 50%
        }

        .colorPointer {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            transform: translate(-50%, -50%)
        }

        .colorControls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            align-items: center
        }

        .selectedColorBox {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3)
        }

        .colorInfo {
            flex: 1;
            font-size: 14px;
            color: var(--muted)
        }

        .colorInfo .colorHexDisplay {
            font-size: 18px;
            font-weight: 600;
            color: var(--ink);
            font-family: monospace
        }

        .colorSelectorBtns {
            display: flex;
            gap: 10px;
            margin-top: 20px
        }

        /* Rainbow Timer Styles */
        .rainbowTimerBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: 800;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            background: linear-gradient(90deg, red, orange, yellow, gold, lightgreen,lime, green, lightblue, skyblue, cyan, aqua, purple, indigo, violet, magenta, Deeppink, pink, brown, grey, silver, darkgray, black,white);
            animation: rainbowPulse 2s ease-in-out infinite;
            box-shadow: 0 8px 32px rgba(255, 0, 255, 0.5);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 9999
        }

        @keyframes rainbowPulse {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 8px 32px rgba(255, 0, 255, 0.5)
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 12px 48px rgba(255, 0, 255, 0.8)
            }
        }

        .rainbowTimerBtn:hover {
            transform: scale(1.1) rotate(5deg)
        }

        .timerModal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100000
        }

        .timerModal.active {
            display: flex
        }

        .timerContainer {
            background: var(--panel);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            min-width: 400px
        }

        .timerDisplay {
            font-size: 72px;
            font-weight: 800;
            background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 20px 0;
            font-family: monospace
        }

        .timerControls {
            margin: 20px 1
        }

        .timerControls label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px
        }

        .timerControls input {
            padding: 10px;
            font-size: 18px;
            border-radius: 8px;
            border: 2px solid var(--accent);
            background: var(--btn);
            color: var(--ink);
            width: 150px;
            text-align: center
        }

        .timerBtns {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px
        }

        .timerRunning {
            animation: timerRainbow 1s linear infinite
        }

        @keyframes timerRainbow {
            0% {
                filter: hue-rotate(0deg)
            }

            100% {
                filter: hue-rotate(360deg)
            }
        }

        .chaos-spin {
            animation: chaosSpin 0.75s ease-in-out
        }

        @keyframes chaosSpin {
            0% {
                transform: rotate(0deg)
            }

            100% {
                transform: rotate(1080deg)
            }
        }

        .chaos-flip {
            animation: chaosFlip 0.5s ease-in-out
        }

        @keyframes chaosFlip {
            0% {
                transform: rotateY(-720deg)
            }

            100% {
                transform: rotateY(720deg)
            }
        }

        .chaos-rainbow {
            animation: chaosRainbow 0.4s ease-in-out
        }

        @keyframes chaosRainbow {

            0%,
            100% {
                filter: hue-rotate(0deg)
            }

            50% {
                filter: hue-rotate(180deg)
            }
        }

        .chaos-shake {
            animation: chaosShake 0.3s ease-in-out
        }

        @keyframes chaosShake {

            0%,
            100% {
                transform: translate(0, 0)
            }

            10% {
                transform: translate(-10px, -10px)
            }

            20% {
                transform: translate(10px, 10px)
            }

            30% {
                transform: translate(-10px, 10px)
            }

            40% {
                transform: translate(10px, -10px)
            }

            50% {
                transform: translate(-10px, -10px)
            }

            60% {
                transform: translate(10px, 10px)
            }

            70% {
                transform: translate(-10px, 10px)
            }

            80% {
                transform: translate(10px, -10px)
            }

            90% {
                transform: translate(-10px, -10px)
            }
        }

        .chaos-zoom {
            animation: chaosZoom 0.4s ease-in-out
        }

        @keyframes chaosZoom {

            0%,
            100% {
                transform: scale(1)
            }

            25% {
                transform: scale(2)
            }

            75% {
                transform: scale(0.5)
            }

            100% {
                transform: scale(1)
            }
        }

        .chaos-glitch {
            animation: chaosGlitch 0.3s ease-in-out
        }

        @keyframes chaosGlitch {

            0%,
            100% {
                transform: translate(0, 0);
                filter: none
            }

            10% {
                transform: translate(-20px, 5px);
                filter: brightness(2)
            }

            20% {
                transform: translate(20px, -5px);
                filter: contrast(3),
                    brightness(924) invert(3)
            }

            30% {
                transform: translate(-15px, -10px);
                filter: saturate(5) brightness(4) contrast(5) invert(1)
            }

            40% {
                transform: translate(15px, 10px);
                filter: hue-rotate(180deg)
            }

            50% {
                transform: translate(-10px, 5px);
                filter: invert(1)
            }

            60% {
                transform: translate(10px, -5px);
                filter: brightness(0.5)
            }

            70% {
                transform: translate(-5px, 10px);
                filter: contrast(0.5)
            }

            80% {
                transform: translate(5px, -10px);
                filter: saturate(0)
            }

            90% {
                transform: translate(-10px, 0);
                filter: hue-rotate(90deg),
                    saturate(9)
            }
        }

        .chaos-bounce {
            animation: chaosBounce 0.5s ease-in-out
        }

        @keyframes chaosBounce {
            0% {
                transform: translateY(0)
            }

            10% {
                transform: translateY(-100px)
            }

            20% {
                transform: translateY(0)
            }

            30% {
                transform: translateY(-50px)
            }

            40% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-25px)
            }

            60% {
                transform: translateY(0)
            }

            70% {
                transform: translateY(25)
            }

            80% {
                transform: translateY(12.5)
            }

            90% {
                transform: translateY(6.25)
            }

            100% {
                transform: translateY(0)
            }
        }

        .chaos-skew {
            animation: chaosSkew 0.4s ease-in-out
        }

        @keyframes chaosSkew {

            0%,
            100% {
                transform: skew(0deg)
            }

            25% {
                transform: skew(45deg, 15deg)
            }

            50% {
                transform: skew(-45deg, -15deg)
            }

            75% {
                transform: skew(30deg, -30deg)
            }
        }

        .chaos-blur {
            animation: chaosBlur 0.5s ease-in-out
        }

        @keyframes chaosBlur {

            0%,
            100% {
                filter: blur(0)
            }

            50% {
                filter: blur(20px)
            }

            25% {
                filter: blur(99999999999999)
            }

            0% {
                filter: blur(0)
            }
        }

        .chaos-pixelate {
            animation: chaosPixelate 0.4s steps(5)
        }
        doomsday {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            5% {
                transform: translate(var(--dx, 0px), var(--dy, 0px)) rotate(var(--rot, 0deg)) scale(1);
                opacity: 1;
                filter: blur(4592678), 
                hue-rotate(360deg), 
                saturate(666),
                sepia(100);
            }
            10% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px), 
                hue-rotate(0deg), 
                saturate(100),
                sepia(0),
                translate(999,999,999),
                translate(-999,-999,-999),
                translate(0,0,0);
            }
            15% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px), 
                hue-rotate(0deg), 
                saturate(100),
                sepia(5423867904358967245387692435876245387643589764357865439985743),
                brightness(infinity),
                brightness(1);
            }
            20% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8); 
                opacity: 0; 
                filter: blur(0px), 
                hue-rotate(0deg), 
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg)
            }
            25% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1e+10),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                blur(infinity)
                opacity(-1)
                opacity(1)
                opacity(-infinity)
                opacity(1)
            }
            30% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8); 
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(infinity)
            }
            35% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                hue-rotate(-1)
            }
            40% {
                transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
                blur(blur(9223372036854775807px))
        }
        45% {
            transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
    }
    50% {
        transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(infinity),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
    }
    70% {
        transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(222),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
    }
    99% {
        transform: translate(var(--targetX, 0px), var(--targetY, 100vh)) rotate(calc(var(--rot, 0deg) * 2)) scale(0.8);
                opacity: 0;
                filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(222),
                brightness(0),
                brightness(infinity),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
    }
    100% {
        opacity: 1;
        filter: blur(0px),
                hue-rotate(0deg),
                saturate(100),
                sepia(222),
                brightness(0),
                brightness(1),
                hue-rotate(999245796853429768234567892354678924356978324deg),
                saturate(1000000000000000),
                hue-rotate(999245796)
    }
}

        @keyframes chaosPixelate {

            0%,
            100% {
                filter: contrast(1)
            }

            25% {
                filter: contrast(10) brightness(0.5)
            }

            50% {
                filter: contrast(20) brightness(2)
            }

            75% {
                filter: contrast(5) saturate(10)
            }
        }

        .chaos-invert {
            animation: chaosInvert 0.35s ease-in-out
        }

        @keyframes chaosInvert {

            0%,
            100% {
                filter: invert(0)
            }

            25% {
                filter: invert(1)
            }

            50% {
                filter: invert(0.5)
            }

            75% {
                filter: invert(1)
            }
        }

        .chaos-strobe {
            animation: chaosStrobe 0.2s steps(4)
        }

        @keyframes chaosStrobe {

            0%,
            50% {
                opacity: 1
            }

            25%,
            75% {
                opacity: 0
            }
        }

        .chaos-morph {
            animation: chaosMorph 0.6s ease-in-out
        }

        @keyframes chaosMorph {
            0% {
                filter: blur(0) brightness(1);
                transform: scale(1) rotate(0deg)
            }

            25% {
                filter: blur(5px) brightness(1.5);
                transform: scale(1.2) rotate(90deg)
            }

            50% {
                filter: blur(10px) brightness(0.7);
                transform: scale(0.8) rotate(180deg)
            }

            75% {
                filter: blur(5px) brightness(1.3);
                transform: scale(1.1) rotate(270deg)
            }

            100% {
                filter: blur(0) brightness(1);
                transform: scale(1) rotate(360deg)
            }
        }

        .chaos-pulse {
            animation: chaosPulse 0.25s ease-in-out
        }

        @keyframes chaosPulse {

            0%,
            100% {
                transform: scale(1)
            }

            20% {
                transform: scale(1.3)
            }

            40% {
                transform: scale(0.7)
            }

            60% {
                transform: scale(1.5)
            }

            80% {
                transform: scale(0.5)
            }
        }

        .chaos-swirl {
            animation: chaosSwirl 0.8s ease-in-out
        }

        @keyframes chaosSwirl {
            0% {
                transform: translateX(0) translateY(0) rotate(0deg)
            }

            25% {
                transform: translateX(100px) translateY(100px) rotate(90deg)
            }

            50% {
                transform: translateX(-100px) translateY(100px) rotate(180deg)
            }

            75% {
                transform: translateX(-100px) translateY(-100px) rotate(270deg)
            }

            100% {
                transform: translateX(0) translateY(0) rotate(360deg)
            }
        }

        .chaos-chromatic {
            animation: chaosChromatic 0.3s ease-in-out
        }

        @keyframes chaosChromatic {

            0%,
            100% {
                filter: none
            }

            25% {
                filter: drop-shadow(5px 0 0 red) drop-shadow(-5px 0 0 cyan)
            }

            50% {
                filter: drop-shadow(0 5px 0 blue) drop-shadow(0 -5px 0 yellow)
            }

            75% {
                filter: drop-shadow(5px 5px 0 magenta) drop-shadow(-5px -5px 0 lime)
            }
        }

        .chaos-wobble {
            animation: chaosWobble 0.4s ease-in-out
        }

        @keyframes chaosWobble {

            0%,
            100% {
                transform: translateY(0) rotateZ(0deg)
            }

            10% {
                transform: translateY(-15px) rotateZ(-5deg)
            }

            20% {
                transform: translateY(15px) rotateZ(5deg)
            }

            30% {
                transform: translateY(-20px) rotateZ(-8deg)
            }

            40% {
                transform: translateY(20px) rotateZ(8deg)
            }

            50% {
                transform: translateY(-25px) rotateZ(-10deg)
            }

            60% {
                transform: translateY(25px) rotateZ(10deg)
            }

            70% {
                transform: translateY(-15px) rotateZ(-5deg)
            }

            80% {
                transform: translateY(15px) rotateZ(5deg)
            }

            90% {
                transform: translateY(-10px) rotateZ(-2deg)
            }
        }

        .chaos-melt {
            animation: chaosMelt 0.5s ease-in-out
        }

        @keyframes chaosMelt {
            0% {
                filter: blur(0);
                transform: scale(1)
            }

            50% {
                filter: blur(15px);
                transform: scale(0.6)
            }

            100% {
                filter: blur(0);
                transform: scale(1)
            }
        }

        .chaos-crumble {
            animation: chaosCrumble 0.35s ease-in-out
        }

        @keyframes chaosCrumble {

            0%,
            100% {
                transform: translate(0, 0) scale(1)
            }

            5% {
                transform: translate(-8px, -8px) scale(0.95)
            }

            10% {
                transform: translate(8px, 8px) scale(1.05)
            }

            15% {
                transform: translate(-12px, 5px) scale(0.9)
            }

            20% {
                transform: translate(12px, -5px) scale(1.1)
            }

            25% {
                transform: translate(-15px, -15px) scale(0.85)
            }

            30% {
                transform: translate(15px, 15px) scale(1.15)
            }

            35% {
                transform: translate(-10px, 10px) scale(0.95)
            }

            40% {
                transform: translate(10px, -10px) scale(1.05)
            }

            45% {
                transform: translate(-5px, 0) scale(0.98)
            }

            50% {
                transform: translate(5px, 0) scale(1.02)
            }

            55% {
                transform: translate(-20px, 0) scale(0.8)
            }

            60% {
                transform: translate(20px, 0) scale(1.2)
            }

            65% {
                transform: translate(-15px, 15px) scale(0.9)
            }

            70% {
                transform: translate(15px, -15px) scale(1.1)
            }

            75% {
                transform: translate(-8px, 8px) scale(0.96)
            }

            80% {
                transform: translate(8px, -8px) scale(1.04)
            }

            85% {
                transform: translate(-5px, -5px) scale(0.99)
            }

            90% {
                transform: translate(5px, 5px) scale(1.01)
            }

            95% {
                transform: translate(-2px, 2px) scale(1)
            }
        }

        .persistent-spin {
            animation: persistentSpin 2s linear infinite
        }

        @keyframes persistentSpin {
            0% {
                transform: rotate(0deg)
            }

            100% {
                transform: rotate(360deg)
            }
        }

        @keyframes screen-shake {

            0%,
            100% {
                transform: translateX(0)
            }

            10% {
                transform: translateX(-10px)
            }

            20% {
                transform: translateX(10px)
            }

            30% {
                transform: translateX(-30000px)
            }

            40% {
                transform: translateX(30000px)
            }

            50% {
                transform: translateY(3000px)
            }

            60% {
                transform: translateY(3000px)
            }

            70% {
                transform: translateZ(50000px)
            }

            71% {
                transform: translateZ(-50000px)
            }

            80% {
                transform: translateX(20px)
            }

            90% {
                transform: translateZ(9000px)
            }

            99% {
                transform: translateZ(-9000px)
            }

            100% {
                transform: translateZ(0px)
            }
        }

        @keyframes fade-out {
            0% {
                opacity: 1
            }

            25% {
                opacity: 0.75
            }

            50% {
                opacity: 0.5
            }

            75% {
                opacity: 0.25
            }

            99% {
                opacity: 0
            }

            100% {
                opacity: 1
            }
        }

        .screen-cut-top {
            clip-path: polygon(0 0, 100% 0, 100% 0, 0 0);
            transition: clip-path 0.5s ease-out
        }

        .screen-cut-bottom {
            clip-path: polygon(0 100%, 100% 100%, 100% 100%, 0 100%);
            transition: clip-path 0.5s ease-out
        }

        /* Themes */
        /* Robot theme: cool neon on steel */
        @keyframes robotScan {
            0% {
                background-position: 0 0
            }

            100% {
                background-position: 0 40px
            }
        }

        @keyframes robotPulse {

            0%,
            100% {
                box-shadow: 0 0 18px rgba(82, 224, 255, 0.25), inset 0 0 14px rgba(82, 224, 255, 0.08)
            }

            50% {
                box-shadow: 0 0 26px rgba(82, 224, 255, 0.45), inset 0 0 18px rgba(82, 224, 255, 0.12)
            }
        }

        body.theme-robot {
            --bg: #080c14;
            --panel: #0b1220;
            --ink: #e6f3ff;
            --muted: #a2b4d6;
            --accent: #52e0ff;
            --btn: #111b32;
            --btn2: #0e1628
        }

        body.theme-robot .badge {
            border-color: rgba(82, 224, 255, 0.35);
            background: rgba(82, 224, 255, 0.08)
        }

        /* subtle cyan grid behind content */
        body.theme-robot .wrap {
            position: relative
        }

        body.theme-robot .wrap::before {
            content: "";
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background: linear-gradient(90deg, rgba(82, 224, 255, 0.05) 1px, transparent 1px),
                linear-gradient(180deg, rgba(82, 224, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        /* neon frame and corner brackets around the calculator */
        body.theme-robot .calc {
            position: relative;
            border-color: rgba(82, 224, 255, 0.25);
            animation: robotPulse 3s ease-in-out infinite
        }

        body.theme-robot .calc::before {
            content: "";
            position: absolute;
            inset: 6px;
            pointer-events: none;
            z-index: 2;
            background: linear-gradient(0deg, rgba(82, 224, 255, 0.2), rgba(82, 224, 255, 0.85));
            filter: drop-shadow(0 0 8px rgba(82, 224, 255, 0.35));
        }

        /* faint scanlines within display area */
        body.theme-robot .display {
            position: relative;
        }

        body.theme-robot .display::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            background: repeating-linear-gradient(180deg, rgba(82, 224, 255, 0.06) 0 2px, transparent 2px 8px);
            animation: robotScan 6s linear infinite;
        }

        /* buttons with cyan edges and hover glow */
        body.theme-robot .keypad button {
            border-color: rgba(82, 224, 255, 0.22);
            box-shadow: 0 0 10px rgba(82, 224, 255, 0.18), inset 0 0 8px rgba(82, 224, 255, 0.06);
        }

        body.theme-robot .keypad button:hover {
            filter: brightness(1.12) saturate(1.1);
            box-shadow: 0 0 18px rgba(82, 224, 255, 0.35), inset 0 0 10px rgba(82, 224, 255, 0.08);
        }

        /* Leaf theme: greens */
        body.theme-leaf {
            --bg: #07110a;
            --panel: #0b1a10;
            --ink: #e7ffef;
            --muted: #a3d2b4;
            --accent: #4be38a;
            --btn: #0f2a1a;
            --btn2: #0c2015
        }

        body.theme-leaf .calc {
            background: linear-gradient(180deg, var(--panel), #0b1510)
        }

        /* Unsatisfying theme: odd spacing, clashing hues, imperfect shapes */
        body.theme-unsatisfying {
            --bg: #140e07;
            --panel: #1a1411;
            --ink: #ffe9e9;
            --muted: #d4a3a3;
            --accent: #ff8bd1;
            --btn: #2a1a16;
            --btn2: #221612;
            --grid-gap: 7px
        }

        body.theme-unsatisfying .keypad button,
        body.theme-unsatisfying .tab,
        body.theme-unsatisfying .badge {
            border-radius: 0;
            border-width: 2px;
            border-color: rgba(255, 0, 0, 0.22);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.18), inset 0 0 8px rgba(255, 0, 0, 0.06);
        }

        /* Satisfying theme: soft pastel and smooth */
        body.theme-satisfying {
            --bg: #0b0f13;
            --panel: #0d1520;
            --ink: #f4f9ff;
            --muted: #c6d4ea;
            --accent: #86b5ff;
            --btn: #121c2b;
            --btn2: #0f1826
        }

        body.theme-satisfying .calc {
            box-shadow: 0 18px 44px rgba(0, 0, 0, 0.45)
        }

        /* Fun theme: playful animations */
        @keyframes floaty {
            0% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-2px)
            }

            100% {
                transform: translateY(0)
            }
        }

        body.theme-fun {
            --bg: #0b0d15;
            --panel: #121a2c;
            --ink: #fdfcff;
            --muted: #b1c1e9;
            --accent: #ffb86b;
            --btn: #1b2340;
            --btn2: #172036
        }

        body.theme-fun .keypad button {
            animation: floaty 3s ease-in-out infinite
        }

        body.theme-fun .keypad button:hover {
            filter: brightness(1.15)
        }

        /* Colorful theme: animated rainbow */
        @keyframes rainbowShift {
            0% {
                filter: hue-rotate(0deg)
            }

            100% {
                filter: hue-rotate(360deg)
            }
        }

        @keyframes hueCycle {
            0% {
                filter: hue-rotate(0deg)
            }

            100% {
                filter: hue-rotate(360deg)
            }
        }

        @keyframes spinBg {
            0% {
                transform: rotate(0deg)
            }

            100% {
                transform: rotate(360deg)
            }
        }

        @keyframes flashBg {

            0%,
            100% {
                opacity: .5
            }

            50% {
                opacity: .9
            }
        }

        body.theme-colorful .wrap,
        body.theme-colorful .calc {
            position: relative;
            z-index: 1;
        }

        body.theme-colorful .calc {
            background: linear-gradient(180deg, rgba(20, 20, 40, 0.7), rgba(15, 15, 35, 0.9));
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px)
        }

        body.theme-colorful .keypad button {
            border-color: rgba(255, 0, 0, 0.22);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.18), inset 0 0 8px rgba(255, 0, 0, 0.06);
        }

        body.theme-colorful .keypad button:hover {
            filter: brightness(1.12) saturate(1.1);
            box-shadow: 0 0 18px rgba(255, 0, 0, 0.35), inset 0 0 10px rgba(255, 0, 0, 0.08);
        }

        body.theme-colorful .display {
            background: linear-gradient(180deg, rgba(20, 20, 40, 0.6), rgba(15, 15, 35, 0.9))
        }

        @keyframes rainbowShift {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        @keyframes spinBg {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>

</head>

<body>
    <button id="epilepsyToggle" class="epilepsyBtn" title="Toggle epilepsy background"> Epilepsy</button>
    <!-- Global Settings Button -->
    <button id="settingsBtn" class="settingsBtn" title="Open settings"> Settings</button>

    <!-- Start Screen -->
    <div class="startScreen" id="startScreen">
        <h1> Game Center</h1>
        <p>Choose your game to start playing</p>
        <div class="gamesGrid">
            <div class="gameCard" data-game="calculator">
                <div class="icon"></div>
                <div class="title">Calculator</div>
                <div class="desc">Scientific calculator with graphing</div>
            </div>
            <div class="gameCard" data-game="drawing">
                <div class="icon"></div>
                <div class="title">Drawing Studio</div>
                <div class="desc">Paint with AI assistant</div>
            </div>
            <div class="gameCard" data-game="practice">
                <div class="icon"></div>
                <div class="title">Math Practice</div>
                <div class="desc">Solve problems and learn</div>
            </div>
            <div class="gameCard" data-game="password">
                <div class="icon"></div>
                <div class="title">Guess the Password</div>
                <div class="desc">Crack the secret code</div>
            </div>
            <div class="gameCard" data-game="stopwatch">
                <div class="icon"></div>
                <div class="title">Stopwatch</div>
                <div class="desc">Track time with precision</div>
            </div>
            <div class="gameCard" data-game="worldtime">
                <div class="icon"></div>
                <div class="title">World Time</div>
                <div class="desc">Check time across the globe</div>
            </div>
            <div class="gameCard" data-game="slicepie">
                <div class="icon"></div>
                <div class="title">Slice the Pi</div>
                <div class="desc">Cut perfect shapes from pie</div>
            </div>
            <div class="gameCard" data-game="literallygame">
                <div class="icon"></div>
                <div class="title">Literally a Game</div>
                <div class="desc">Just a game, nothing special</div>
            </div>
            <div class="gameCard" data-game="colormatch">
                <div class="icon"></div>
                <div class="title">Color Match</div>
                <div class="desc">Match colors before time runs out</div>
            </div>
            <div class="gameCard" data-game="simonmemory">
                <div class="icon"></div>
                <div class="title">Memory Master</div>
                <div class="desc">Remember the sequence</div>
            </div>
            <div class="gameCard" data-game="typingspeed">
                <div class="icon"></div>
                <div class="title">Type Racer</div>
                <div class="desc">Test your typing speed</div>
            </div>
            <div class="gameCard" data-game="reaction">
                <div class="icon"></div>
                <div class="title">Reaction Time</div>
                <div class="desc">How fast can you click?</div>
            </div>
            <div class="gameCard" data-game="maze">
                <div class="icon"></div>
                <div class="title">Maze Runner</div>
                <div class="desc">Navigate the maze</div>
            </div>
            <div class="gameCard" data-game="flappyclone">
                <div class="icon"></div>
                <div class="title">Flappy Clone</div>
                <div class="desc">Avoid the obstacles</div>
            </div>
            <div class="gameCard" data-game="tictactoe">
                <div class="icon"></div>
                <div class="title">Tic Tac Toe</div>
                <div class="desc">Beat the AI</div>
            </div>
            <div class="gameCard" data-game="snake">
                <div class="icon"></div>
                <div class="title">Snake Classic</div>
                <div class="desc">Eat and grow</div>
            </div>
            <div class="gameCard" data-game="hangman">
                <div class="icon"></div>
                <div class="title">Hangman</div>
                <div class="desc">Guess the word</div>
            </div>
            <div class="gameCard" data-game="2048">
                <div class="icon"></div>
                <div class="title">2048</div>
                <div class="desc">Combine tiles to reach 2048</div>
            </div>
            <div class="gameCard" data-game="breakout">
                <div class="icon"></div>
                <div class="title">Breakout</div>
                <div class="desc">Break the bricks</div>
            </div>
            <div class="gameCard" data-game="pong">
                <div class="icon"></div>
                <div class="title">Pong</div>
                <div class="desc">Classic paddle game</div>
            </div>
            <div class="gameCard" data-game="sudoku">
                <div class="icon"></div>
                <div class="title">Sudoku</div>
                <div class="desc">Solve the puzzle</div>
            </div>
            <div class="gameCard" data-game="whackamole">
                <div class="icon"></div>
                <div class="title">Whack-a-Mole</div>
                <div class="desc">Hit the moles</div>
            </div>
            <div class="gameCard" data-game="trivia">
                <div class="icon"></div>
                <div class="title">Trivia Quiz</div>
                <div class="desc">Test your knowledge</div>
            </div>
            <div class="gameCard" data-game="asteroid">
                <div class="icon"></div>
                <div class="title">Asteroid Blaster</div>
                <div class="desc">Shoot and survive</div>
            </div>
            <div class="gameCard" data-game="spaceinvaders">
                <div class="icon"></div>
                <div class="title">Space Invaders</div>
                <div class="desc">Defend from invaders</div>
            </div>
            <div class="gameCard" data-game="spaceinvadersbutbetter">
                <div class="icon"></div>
                <div class="title">Space invaders but better</div>
                <div class="desc">Space invaders but better</div>
            </div>
            <div class="gameCard" data-game="megagame">
                <div class="icon"></div>
                <div class="title">Initiate Mega Game</div>
                <div class="desc">Space Invaders Plus with boss battle</div>
            </div>
            <div class="gameCard" data-game="pacman">
                <div class="icon"></div>
                <div class="title">Pac-Man</div>
                <div class="desc">Eat pellets and avoid ghosts</div>
            </div>
            <div class="gameCard" data-game="jumpingshape">
                <div class="icon"></div>
                <div class="title">Jumping Shape</div>
                <div class="desc">Jump over obstacles</div>
            </div>
            <div class="gameCard" data-game="memoryflip">
                <div class="icon"></div>
                <div class="title">Memory Flip</div>
                <div class="desc">Match the pairs</div>
            </div>
            <div class="gameCard" data-game="ballpusher">
                <div class="icon"></div>
                <div class="title">Ball Pusher</div>
                <div class="desc">Push balls into goals</div>
            </div>
            <div class="gameCard" data-game="numberchain">
                <div class="icon"></div>
                <div class="title">Number Chain</div>
                <div class="desc">Connect matching numbers</div>
            </div>
            <div class="gameCard" data-game="asteroidfighter">
                <div class="icon"></div>
                <div class="title">Asteroid Fighter</div>
                <div class="desc">Ultimate space combat</div>
            </div>
            <div class="gameCard" data-game="fastclicker">
                <div class="icon"></div>
                <div class="title">Fast Clicker</div>
                <div class="desc">Click as fast as you can</div>
            </div>
            <div class="gameCard" data-game="zombierunner">
                <div class="icon"></div>
                <div class="title">Zombie Runner</div>
                <div class="desc">Endless runner with zombies</div>
            </div>
            <div class="gameCard" data-game="memorymatch">
                <div class="icon"></div>
                <div class="title">Memory Match</div>
                <div class="desc">Match pairs card game</div>
            </div>
            <div class="gameCard" data-game="dinojump">
                <div class="icon"></div>
                <div class="title">Dino Jump</div>
                <div class="desc">Dinosaur jumping game</div>
            </div>
            <div class="gameCard" data-game="blockblast">
                <div class="icon"></div>
                <div class="title">Block Blast</div>
                <div class="desc">Falling blocks puzzle</div>
            </div>
            <div class="gameCard" data-game="bubbleshooter">
                <div class="icon"></div>
                <div class="title">Bubble Shooter</div>
                <div class="desc">Pop bubbles and score</div>
            </div>
            <div class="gameCard" data-game="spaceshooter">
                <div class="icon"></div>
                <div class="title">Space Shooter</div>
                <div class="desc">Vertical scrolling shooter</div>
            </div>
            <div class="gameCard" data-game="whackrats">
                <div class="icon"></div>
                <div class="title">Whack Rats</div>
                <div class="desc">Timing and reflexes game</div>
            </div>
            <div class="gameCard" data-game="catchfalling">
                <div class="icon"></div>
                <div class="title">Catch Falling</div>
                <div class="desc">Catch items to score</div>
            </div>
            <div class="gameCard" data-game="brickbreaker">
                <div class="icon"></div>
                <div class="title">Brick Breaker</div>
                <div class="desc">Paddle game variant</div>
            </div>
            <div class="gameCard" data-game="defendcastle">
                <div class="icon"></div>
                <div class="title">Defend Castle</div>
                <div class="desc">Tower defense simplified</div>
            </div>
            <div class="gameCard" data-game="pipepuzzle">
                <div class="icon"></div>
                <div class="title">Pipe Puzzle</div>
                <div class="desc">Connect pipe pieces</div>
            </div>
            <div class="gameCard" data-game="matchthree">
                <div class="icon"></div>
                <div class="title">Match Three</div>
                <div class="desc">Match three gems</div>
            </div>
            <div class="gameCard" data-game="platformer">
                <div class="icon"></div>
                <div class="title">Platformer</div>
                <div class="desc">Classic platformer game</div>
            </div>
            <div class="gameCard" data-game="ballmaze">
                <div class="icon"></div>
                <div class="title">Ball Maze</div>
                <div class="desc">Roll ball through maze</div>
            </div>
            <div class="gameCard" data-game="cardmemory">
                <div class="icon"></div>
                <div class="title">Card Memory</div>
                <div class="desc">Remember card locations</div>
            </div>
            <div class="gameCard" data-game="lightsout">
                <div class="icon"></div>
                <div class="title">Lights Out</div>
                <div class="desc">Turn off all lights</div>
            </div>
            <div class="gameCard" data-game="sokoban">
                <div class="icon"></div>
                <div class="title">Sokoban</div>
                <div class="desc">Push boxes to goal</div>
            </div>
            <div class="gameCard" data-game="dotchase">
                <div class="icon"></div>
                <div class="title">Dot Chase</div>
                <div class="desc">Chase the dots</div>
            </div>
            <div class="gameCard" data-game="wordscramble">
                <div class="icon"></div>
                <div class="title">Word Scramble</div>
                <div class="desc">Unscramble the words</div>
            </div>
            <div class="gameCard" data-game="bouncemania">
                <div class="icon"></div>
                <div class="title">Bounce Mania</div>
                <div class="desc">Bounce ball into targets</div>
            </div>
            <div class="gameCard" data-game="mineslide">
                <div class="icon"></div>
                <div class="title">Mine Slide</div>
                <div class="desc">Avoid the mines</div>
            </div>
            <div class="gameCard" data-game="flipcards">
                <div class="icon"></div>
                <div class="title">Flip Cards</div>
                <div class="desc">Card flipping game</div>
            </div>
            <div class="gameCard" data-game="colorblind">
                <div class="icon"></div>
                <div class="title">Color Blind</div>
                <div class="desc">Identify color patterns</div>
            </div>
            <div class="gameCard" data-game="numberjump">
                <div class="icon"></div>
                <div class="title">Number Jump</div>
                <div class="desc">Jump between numbers</div>
            </div>
            <div class="gameCard" data-game="dragonslayer">
                <div class="icon"></div>
                <div class="title">Dragon Slayer</div>
                <div class="desc">Defeat the dragon</div>
            </div>
            <div class="gameCard" data-game="fishfeed">
                <div class="icon"></div>
                <div class="title">Fish Feed</div>
                <div class="desc">Feed the fish game</div>
            </div>
            <div class="gameCard" data-game="pigsfly">
                <div class="icon"></div>
                <div class="title">Pigs Fly</div>
                <div class="desc">Launch pigs to target</div>
            </div>
            <div class="gameCard" data-game="bricksbreaker2">
                <div class="icon"></div>
                <div class="title">Bricks Breaker 2</div>
                <div class="desc">Another brick breaker</div>
            </div>
            <div class="gameCard" data-game="slideblock">
                <div class="icon"></div>
                <div class="title">Slide Block</div>
                <div class="desc">Sliding block puzzle</div>
            </div>
            <div class="gameCard" data-game="asteroidshoot">
                <div class="icon"></div>
                <div class="title">Asteroid Shoot</div>
                <div class="desc">Shoot flying asteroids</div>
            </div>
            <div class="gameCard" data-game="ghosthunt">
                <div class="icon"></div>
                <div class="title">Ghost Hunt</div>
                <div class="desc">Hunt the ghosts</div>
            </div>
            <div class="gameCard" data-game="towerstack">
                <div class="icon"></div>
                <div class="title">Tower Stack</div>
                <div class="desc">Stack blocks carefully</div>
            </div>
            <div class="gameCard" data-game="scrollmatch">
                <div class="icon"></div>
                <div class="title">Scroll Match</div>
                <div class="desc">Match scrolling symbols</div>
            </div>
            <div class="gameCard" data-game="starfield">
                <div class="icon"></div>
                <div class="title">Starfield</div>
                <div class="desc">Navigate starfield</div>
            </div>
            <div class="gameCard" data-game="locksmith">
                <div class="icon"></div>
                <div class="title">Locksmith</div>
                <div class="desc">Crack the lock</div>
            </div>
            <div class="gameCard" data-game="spiderweb">
                <div class="icon"></div>
                <div class="title">Spider Web</div>
                <div class="desc">Avoid the spider web</div>
            </div>
            <div class="gameCard" data-game="jetpack">
                <div class="icon"></div>
                <div class="title">Jetpack</div>
                <div class="desc">Fly with jetpack</div>
            </div>
            <div class="gameCard" data-game="moneystack">
                <div class="icon"></div>
                <div class="title">Money Stack</div>
                <div class="desc">Stack coins high</div>
            </div>
            <div class="gameCard" data-game="clockwork">
                <div class="icon"></div>
                <div class="title">Clockwork</div>
                <div class="desc">Gear puzzle game</div>
            </div>
            <div class="gameCard" data-game="cloudwalk">
                <div class="icon"></div>
                <div class="title">Cloud Walk</div>
                <div class="desc">Walk on clouds</div>
            </div>
            <div class="gameCard" data-game="gravitas">
                <div class="icon"></div>
                <div class="title">Gravitas</div>
                <div class="desc">Gravity puzzle game</div>
            </div>
            <div class="gameCard" data-game="motionflash">
                <div class="icon"></div>
                <div class="title">Motion Flash</div>
                <div class="desc">Follow motion patterns</div>
            </div>
            <div class="gameCard" data-game="windrunner">
                <div class="icon"></div>
                <div class="title">Wind Runner</div>
                <div class="desc">Run with wind elements</div>
            </div>
            <div class="gameCard" data-game="iceslide">
                <div class="icon"></div>
                <div class="title">Ice Slide</div>
                <div class="desc">Slide on ice</div>
            </div>
            <div class="gameCard" data-game="fireburst">
                <div class="icon"></div>
                <div class="title">Fire Burst</div>
                <div class="desc">Burn obstacles down</div>
            </div>
            <div class="gameCard" data-game="waterflow">
                <div class="icon"></div>
                <div class="title">Water Flow</div>
                <div class="desc">Direct water flow</div>
            </div>
            <div class="gameCard" data-game="shadowjump">
                <div class="icon"></div>
                <div class="title">Shadow Jump</div>
                <div class="desc">Jump through shadows</div>
            </div>
            <div class="gameCard" data-game="lightburst">
                <div class="icon"></div>
                <div class="title">Light Burst</div>
                <div class="desc">Burst through light</div>
            </div>
            <div class="gameCard" data-game="energyflow">
                <div class="icon"></div>
                <div class="title">Energy Flow</div>
                <div class="desc">Control energy beams</div>
            </div>
            <div class="gameCard" data-game="crystalgem">
                <div class="icon"></div>
                <div class="title">Crystal Gem</div>
                <div class="desc">Collect crystal gems</div>
            </div>
            <div class="gameCard" data-game="volcanorun">
                <div class="icon"></div>
                <div class="title">Volcano Run</div>
                <div class="desc">Run from lava</div>
            </div>
            <div class="gameCard" data-game="desertblast">
                <div class="icon"></div>
                <div class="title">Desert Blast</div>
                <div class="desc">Survive the desert</div>
            </div>
            <div class="gameCard" data-game="frozenquest">
                <div class="icon"></div>
                <div class="title">Frozen Quest</div>
                <div class="desc">Quest in frozen land</div>
            </div>
            <div class="gameCard" data-game="jurassic">
                <div class="icon"></div>
                <div class="title">Jurassic</div>
                <div class="desc">Dinosaur adventure</div>
            </div>
            <div class="gameCard" data-game="deepseadive">
                <div class="icon"></div>
                <div class="title">Deep Sea Dive</div>
                <div class="desc">Dive deep underwater</div>
            </div>
            <div class="gameCard" data-game="forestwalk">
                <div class="icon"></div>
                <div class="title">Forest Walk</div>
                <div class="desc">Walk through forest</div>
            </div>
            <div class="gameCard" data-game="skyglide">
                <div class="icon"></div>
                <div class="title">Sky Glide</div>
                <div class="desc">Glide through sky</div>
            </div>
            <div class="gameCard" data-game="moonbase">
                <div class="icon"></div>
                <div class="title">Moon Base</div>
                <div class="desc">Build moon base</div>
            </div>
            <div class="gameCard" data-game="sunburst">
                <div class="icon"></div>
                <div class="title">Sun Burst</div>
                <div class="desc">Burst of sunlight</div>
            </div>
            <div class="gameCard" data-game="rainbowrace">
                <div class="icon"></div>
                <div class="title">Rainbow Race</div>
                <div class="desc">Race of colors</div>
            </div>
            <div class="gameCard" data-game="thunderstrike">
                <div class="icon"></div>
                <div class="title">Thunder Strike</div>
                <div class="desc">Strike with thunder</div>
            </div>
            <div class="gameCard" data-game="stormchasers">
                <div class="icon"></div>
                <div class="title">Storm Chasers</div>
                <div class="desc">Chase the storms</div>
            </div>
            <div class="gameCard" data-game="blizzardrun">
                <div class="icon"></div>
                <div class="title">Blizzard Run</div>
                <div class="desc">Run in blizzard</div>
            </div>
            <div class="gameCard" data-game="tornado">
                <div class="icon"></div>
                <div class="title">Tornado</div>
                <div class="desc">Escape the tornado</div>
            </div>
            <div class="gameCard" data-game="meteorstrike">
                <div class="icon"></div>
                <div class="title">Meteor Strike</div>
                <div class="desc">Dodge falling meteors</div>
            </div>
            <div class="gameCard" data-game="galaxydef">
                <div class="icon"></div>
                <div class="title">Galaxy Defense</div>
                <div class="desc">Defend the galaxy</div>
            </div>
            <div class="gameCard" data-game="nebula">
                <div class="icon"></div>
                <div class="title">Nebula</div>
                <div class="desc">Explore nebula clouds</div>
            </div>
            <div class="gameCard" data-game="blackhole">
                <div class="icon"></div>
                <div class="title">Black Hole</div>
                <div class="desc">Avoid black hole</div>
            </div>
            <div class="gameCard" data-game="warpdrive">
                <div class="icon"></div>
                <div class="title">Warp Drive</div>
                <div class="desc">Activate warp drive</div>
            </div>
            <div class="gameCard" data-game="pulsewave">
                <div class="icon"></div>
                <div class="title">Pulse Wave</div>
                <div class="desc">Ride the pulse wave</div>
            </div>
        </div>
        <button class="rainbowTimerBtn" id="rainbowTimerBtn"> RAINBOW CHAOS TIMER </button>
    </div>

    <!-- Global Settings View -->
    <div class="gameView" id="settingsView">
        <div class="wrap">
            <div class="settingsModal active">
                <div class="flipContainer" id="flipContainerGlobal">
                    <div class="calcSide">
                        <div class="calcWrapper">
                            <div class="calc">
                                <h1 style="text-align:center;margin:40px 0;font-size:48px;color:var(--ink)"></h1>
                                <h2 style="text-align:center;color:var(--muted)">Settings</h2>
                                <p style="text-align:center;color:var(--muted);margin-top:20px">Click to view and
                                    configure settings</p>
                            </div>
                        </div>
                    </div>
                    <div class="settingsSide">
                        <div class="settingsContent">
                            <button class="backToCalc" id="backToHomeFromSettings"> Back to Home</button>
                            <h2> Settings</h2>

                            <div class="settingsSection">
                                <h3> Rainbow Chaos Timer Settings</h3>
                                <div class="settingRow">
                                    <label>Duration (seconds):</label>
                                    <input type="number" id="chaosTimerDurationGlobal" min="10" max="2000" value="60"
                                        style="width:100px;padding:8px;background:var(--btn);color:var(--ink);border:1px solid rgba(255,255,255,0.1);border-radius:8px;font-size:16px" />
                                    <span style="margin-left:10px;color:var(--muted)">10-2000s</span>
                                </div>

                                <h4 style="margin-top:20px;margin-bottom:12px;color:var(--accent);font-size:15px">
                                    Effect Options</h4>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableAllEffects" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableAllEffects" style="cursor:pointer;font-weight:600">Enable All
                                        Included Effects</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enablePoopSounds" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enablePoopSounds" style="cursor:pointer"> Poop Sounds</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableChaosEffects" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableChaosEffects" style="cursor:pointer"> Chaos Animations</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableScreenExplosion" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableScreenExplosion" style="cursor:pointer"> Screen
                                        Explosion</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enable90dbSound" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enable90dbSound" style="cursor:pointer"> 90 Decibel Sound</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableScreenCut" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableScreenCut" style="cursor:pointer"> Snake Screen Cut</label>
                                </div>

                                <div class="settingRow" style="margin-left:30px">
                                    <label>Effects duration before snake:</label>
                                    <input type="number" id="snakeCutDelay" min="1" max="500" value="60"
                                        style="width:80px;padding:8px;background:var(--btn);color:var(--ink);border:1px solid rgba(255,255,255,0.1);border-radius:8px" />
                                    <span style="margin-left:10px;color:var(--muted)">1-500 seconds</span>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableElementsJump" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableElementsJump" style="cursor:pointer"> Elements Jumping
                                        Out</label>
                                </div>

                                <div class="settingRow" style="margin-left:30px">
                                    <label>Jump repetitions:</label>
                                    <input type="number" id="elementsJumpCount" min="1" max="50" value="10"
                                        style="width:80px;padding:8px;background:var(--btn);color:var(--ink);border:1px solid rgba(255,255,255,0.1);border-radius:8px" />
                                    <span style="margin-left:10px;color:var(--muted)">1-50 times</span>
                                </div>
                            </div>

                            <div class="settingsSection">
                                <h3>Background Colors</h3>
                                <div class="settingRow">
                                    <button class="modeToggle" id="solidModeSettingsGlobal">Solid</button>
                                    <button class="modeToggle active" id="gradientModeSettingsGlobal">Gradient</button>
                                </div>
                                <div class="settingRow">
                                    <label>Gradient Angle:</label>
                                    <input type="range" id="bgAngleSettingsGlobal" min="0" max="360" step="15"
                                        value="180" style="width:150px" />
                                    <span id="angleValueSettingsGlobal">180</span>
                                </div>
                                <div class="settingRow">
                                    <label>Color Stops:</label>
                                    <button class="addColorBtn" id="addColorStopGlobal">+ Add Color</button>
                                </div>
                                <div id="colorStopsContainerGlobal" class="colorStops">
                                    <!-- Color stops will be added here dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rainbow Timer Modal -->
    <div class="timerModal" id="timerModal">
        <div class="timerContainer">
            <h2> Rainbow Chaos Timer </h2>
            <div class="timerDisplay" id="timerDisplay">00:00</div>
            <div class="timerControls">
                <label>Set Time (seconds):</label>
                <input type="number" id="timerInput" min="1" max="2000" value="10" />
            </div>
            <div class="timerBtns">
                <button class="gameBtn primary" id="startTimerBtn"> Start Timer</button>
                <button class="gameBtn" id="closeTimerBtn"> Close</button>
            </div>
        </div>
    </div>

    <!-- Calculator Game View -->
    <div class="gameView" id="calculatorView">
        <button class="backToHome" id="backBtn1"> Back to Home</button>
        <button class="lockBtn" id="lockBtn" title="Lock/Unlock calculator position"> Unlocked</button>

        <div class="wrap">
            <div class="settingsModal" id="settingsModal">
                <div class="flipContainer" id="flipContainer">
                    <div class="calcSide">
                        <div class="calcWrapper" id="calcWrapper">
                            <div class="calc" role="application" aria-label="Calculator">
                                <div class="tabs">
                                    <button class="tab active" data-panel="calcPanel">Calculator</button>
                                    <button class="tab" data-panel="graphPanel">Graph</button>
                                    <button class="tab" data-panel="practicePanel">Practice</button>
                                    <div class="spacer"></div>
                                </div>

                                <div id="calcPanel" class="panel active">
                                    <div class="display">
                                        <div id="expr" class="expr" aria-live="polite"></div>
                                        <div id="res" class="result" aria-live="polite">0</div>
                                    </div>
                                    <div class="keypad" aria-label="Keypad">
                                        <button class="op" data-fn="sin" title="Sine">sin</button>
                                        <button class="op" data-fn="cos" title="Cosine">cos</button>
                                        <button class="op" data-fn="tan" title="Tangent">tan</button>
                                        <button class="op" data-fn="sqrt" title="Square root"></button>

                                        <button class="op" data-fn="log" title="Log base 10">log</button>
                                        <button class="op" data-fn="ln" title="Natural log">ln</button>
                                        <button class="op" data-value="^" title="Power">x^y</button>
                                        <button class="op" data-value="%" title="Percent">%</button>

                                        <button class="danger" data-action="clear" title="Clear (C)">C</button>
                                        <button class="danger" data-action="delete" title="Delete ()"></button>
                                        <button class="op" data-value="(" title="(">(</button>
                                        <button class="op" data-value=")" title=")">)</button>

                                        <button data-value="7">7</button>
                                        <button data-value="8">8</button>
                                        <button data-value="9">9</button>
                                        <button class="op" data-value="*" title="Multiply"></button>

                                        <button data-value="4">4</button>
                                        <button data-value="5">5</button>
                                        <button data-value="6">6</button>
                                        <button class="op" data-value="/" title="Divide"></button>

                                        <button data-value="1">1</button>
                                        <button data-value="2">2</button>
                                        <button data-value="3">3</button>
                                        <button class="op" data-value="-" title="Subtract"></button>

                                        <button data-value="0">0</button>
                                        <button class="op" data-value="." title="Decimal point">.</button>
                                        <button class="accent" data-action="equals" title="Equals">=</button>
                                        <button class="op" data-value="+" title="Add">+</button>
                                    </div>
                                    <div class="footer">
                                        <span class="badge" id="angleBtn" title="Toggle angle mode">DEG</span>
                                        <span class="badge">v1.0</span>
                                    </div>
                                </div>

                                <div id="graphPanel" class="panel">
                                    <div class="graphwrap">
                                        <div class="row">
                                            <div class="field"><label>y = </label><input id="funcInput" type="text"
                                                    value="sin(x)" /></div>
                                            <div class="field"><label>x min</label><input id="xmin" type="number"
                                                    value="-10" step="1" /></div>
                                            <div class="field"><label>x max</label><input id="xmax" type="number"
                                                    value="10" step="1" /></div>
                                            <button id="plotBtn" class="badge">Plot</button>
                                        </div>
                                        <canvas id="graph"></canvas>
                                    </div>
                                </div>

                                <div id="practicePanel" class="panel">
                                    <div class="practice">
                                        <div class="row">
                                            <div class="field">
                                                <label for="ptype">Type</label>
                                                <select id="ptype">
                                                    <option value="add">Addition</option>
                                                    <option value="multiply">Multiplication</option>
                                                    <option value="divide">Division</option>
                                                </select>
                                            </div>
                                            <button id="newProb" class="badge">New Problem</button>
                                        </div>
                                        <div id="probText" class="problem">Press "New Problem"</div>
                                        <div class="row">
                                            <input id="answer" type="text" placeholder="Your answer" />
                                            <button id="checkAns" class="badge">Check</button>
                                            <span id="feedback" class="badge"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="settingsSide">
                        <div class="settingsContent">
                            <button class="backToCalc" id="backToCalc"> Back to Calculator</button>
                            <h2> Settings</h2>

                            <div class="settingsSection">
                                <h3> Rainbow Chaos Timer Settings</h3>
                                <div class="settingRow">
                                    <label>Duration (seconds):</label>
                                    <input type="number" id="chaosTimerDuration" min="10" max="2000" value="60"
                                        style="width:100px;padding:8px;background:var(--btn);color:var(--ink);border:1px solid rgba(255,255,255,0.1);border-radius:8px;font-size:16px" />
                                    <span style="margin-left:10px;color:var(--muted)">10-2000s</span>
                                </div>

                                <h4 style="margin-top:20px;margin-bottom:12px;color:var(--accent);font-size:15px">
                                    Effect Options</h4>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableAllEffectsCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableAllEffectsCalc" style="cursor:pointer;font-weight:600">Enable All
                                        Included Effects</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enablePoopSoundsCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enablePoopSoundsCalc" style="cursor:pointer"> Poop Sounds</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableChaosEffectsCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableChaosEffectsCalc" style="cursor:pointer"> Chaos
                                        Animations</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableScreenExplosionCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableScreenExplosionCalc" style="cursor:pointer"> Screen
                                        Explosion</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enable90dbSoundCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enable90dbSoundCalc" style="cursor:pointer"> 90 Decibel Sound</label>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableScreenCutCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableScreenCutCalc" style="cursor:pointer"> Snake Screen Cut</label>
                                </div>

                                <div class="settingRow" style="margin-left:30px">
                                    <label>Effects duration before snake:</label>
                                    <input type="number" id="snakeCutDelayCalc" min="1" max="500" value="60"
                                        style="width:80px;padding:8px;background:var(--btn);color:var(--ink);border:1px solid rgba(255,255,255,0.1);border-radius:8px" />
                                    <span style="margin-left:10px;color:var(--muted)">1-500 seconds</span>
                                </div>

                                <div class="settingRow" style="align-items:center;gap:10px">
                                    <input type="checkbox" id="enableElementsJumpCalc" checked
                                        style="width:20px;height:20px;cursor:pointer" />
                                    <label for="enableElementsJumpCalc" style="cursor:pointer"> Elements Jumping
                                        Out</label>
                                </div>

                                <div class="settingRow" style="margin-left:30px">
                                    <label>Jump repetitions:</label>
                                    <input type="number" id="elementsJumpCountCalc" min="1" max="50" value="10"
                                        style="width:80px;padding:8px;background:var(--btn);color:var(--ink);border:1px solid rgba(255,255,255,0.1);border-radius:8px" />
                                    <span style="margin-left:10px;color:var(--muted)">1-50 times</span>
                                </div>
                            </div>

                            <div class="settingsSection">
                                <h3>Background Colors</h3>
                                <div class="settingRow">
                                    <button class="modeToggle" id="solidModeSettings">Solid</button>
                                    <button class="modeToggle active" id="gradientModeSettings">Gradient</button>
                                </div>
                                <div class="settingRow">
                                    <label>Gradient Angle:</label>
                                    <input type="range" id="bgAngleSettings" min="0" max="360" step="15" value="180"
                                        style="width:150px" />
                                    <span id="angleValueSettings">180</span>
                                </div>
                                <div class="settingRow">
                                    <label>Color Stops:</label>
                                    <button class="addColorBtn" id="addColorStop">+ Add Color</button>
                                </div>
                                <div id="colorStopsContainer" class="colorStops">
                                    <!-- Color stops will be added here dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Studio Game View -->
    <div class="gameView" id="drawingView">
        <button class="backToHome" id="backBtn2"> Back to Home</button>
        <div class="wrap">
            <div id="drawPanel" class="panel active">
                <div class="drawPanel">
                    <div class="drawToolbar">
                        <div class="drawToolSection">
                            <h3> Drawing Tools</h3>
                            <div class="drawToolsGrid">
                                <div class="drawToolBtn active" data-tool="pen">
                                    <div class="drawToolIcon"></div>
                                    <div>Pen</div>
                                </div>
                                <div class="drawToolBtn" data-tool="calligraphy">
                                    <div class="drawToolIcon"></div>
                                    <div>Calligraphy</div>
                                </div>
                                <div class="drawToolBtn" data-tool="pencil">
                                    <div class="drawToolIcon"></div>
                                    <div>Pencil</div>
                                </div>
                                <div class="drawToolBtn" data-tool="colorpencil">
                                    <div class="drawToolIcon"></div>
                                    <div>Color Pencil</div>
                                </div>
                                <div class="drawToolBtn" data-tool="gel">
                                    <div class="drawToolIcon"></div>
                                    <div>Gel Pen</div>
                                </div>
                                <div class="drawToolBtn" data-tool="marker">
                                    <div class="drawToolIcon"></div>
                                    <div>Marker</div>
                                </div>
                                <div class="drawToolBtn" data-tool="crayon">
                                    <div class="drawToolIcon"></div>
                                    <div>Crayon</div>
                                </div>
                                <div class="drawToolBtn" data-tool="spray">
                                    <div class="drawToolIcon"></div>
                                    <div>Spray</div>
                                </div>
                                <div class="drawToolBtn" data-tool="graffiti">
                                    <div class="drawToolIcon"></div>
                                    <div>Graffiti</div>
                                </div>
                                <div class="drawToolBtn" data-tool="bucket">
                                    <div class="drawToolIcon"></div>
                                    <div>Bucket Fill</div>
                                </div>
                                <div class="drawToolBtn" data-tool="eraser">
                                    <div class="drawToolIcon"></div>
                                    <div>Eraser</div>
                                </div>
                            </div>
                        </div>

                        <div class="drawToolSection">
                            <h3> Color</h3>
                            <div class="colorPickerWrap">
                                <input type="color" id="drawColorPicker" class="colorPickerInput" value="#000000"
                                    title="Choose color">
                                <div style="flex:1;font-size:11px;color:var(--muted)">
                                    <div>Current</div>
                                    <div id="drawColorHex" style="color:var(--ink);font-weight:600">#000000</div>
                                </div>
                            </div>
                            <div class="colorPresets">
                                <div class="colorPreset" style="background:#000" data-color="#000000"></div>
                                <div class="colorPreset" style="background:#f00" data-color="#FF0000"></div>
                                <div class="colorPreset" style="background:#0f0" data-color="#00FF00"></div>
                                <div class="colorPreset" style="background:#00f" data-color="#0000FF"></div>
                                <div class="colorPreset" style="background:#ff0" data-color="#FFFF00"></div>
                                <div class="colorPreset" style="background:#f0f" data-color="#FF00FF"></div>
                                <div class="colorPreset" style="background:#0ff" data-color="#00FFFF"></div>
                                <div class="colorPreset" style="background:#fa0" data-color="#FFAA00"></div>
                            </div>
                        </div>

                        <div class="drawToolSection">
                            <h3> Size</h3>
                            <div class="sliderWrap">
                                <div class="sliderLabel">
                                    <span>Brush Size</span>
                                    <span id="drawSizeVal">5</span>
                                </div>
                                <input type="range" id="drawSizeSlider" class="drawSlider" min="1" max="50" value="5"
                                    title="Brush size">
                            </div>
                        </div>

                        <div class="drawToolSection">
                            <h3> Opacity</h3>
                            <div class="sliderWrap">
                                <div class="sliderLabel">
                                    <span>Opacity</span>
                                    <span id="drawOpacityVal">100%</span>
                                </div>
                                <input type="range" id="drawOpacitySlider" class="drawSlider" min="10" max="100"
                                    value="100" title="Opacity">
                            </div>
                        </div>

                        <div class="drawToolSection">
                            <h3> AI Assistant</h3>
                            <div class="drawControls" style="display:flex;flex-direction:column;gap:6px">
                                <button class="drawBtn" id="aiToggleBtn"> Open AI Assistant</button>
                                <button class="drawBtn" id="colorSelectorBtn"> Color Selector</button>
                            </div>
                        </div>
                    </div>

                    <div class="drawCanvasArea">
                        <canvas id="drawCanvas" width="800" height="600"></canvas>

                        <div class="canvasOverlay">
                            <button class="drawBtn" id="drawUndoBtn"> Undo</button>
                            <button class="drawBtn" id="drawClearBtn"> Clear</button>
                            <button class="drawBtn" id="drawSaveBtn"> Save</button>
                            <button class="drawBtn" id="drawRulerBtn"> Ruler</button>
                            <button class="drawBtn" id="drawGridBtn"> Grid</button>
                        </div>

                        <div class="aiPanel" id="aiPanel">
                            <h3 style="margin:0 0 8px 0;font-size:13px;color:var(--accent)"> AI Drawing Assistant</h3>
                            <textarea id="aiPrompt" class="aiPrompt"
                                placeholder="Describe what you want me to draw (e.g., 'Draw a sunset over mountains', 'Create a flower', 'Draw a house')..."
                                rows="2"></textarea>
                            <div class="aiOptions">
                                <button class="drawBtn" id="aiDrawBtn"> Draw It!</button>
                                <button class="drawBtn" id="aiQuickStar"> Star</button>
                                <button class="drawBtn" id="aiQuickHeart"> Heart</button>
                                <button class="drawBtn" id="aiQuickHouse"> House</button>
                                <button class="drawBtn" id="aiQuickTree"> Tree</button>
                                <button class="drawBtn" id="aiQuickSun"> Sun</button>
                                <button class="drawBtn" id="aiCloseBtn"> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Color Selector Modal -->
    <div class="colorSelectorModal" id="colorSelectorModal">
        <div class="colorSelectorContainer">
            <h3> Advanced Color Selector</h3>
            <div class="colorCircle" id="colorCircle">
                <canvas id="colorWheelCanvas" width="300" height="300"></canvas>
                <div class="colorPointer" id="colorPointer"></div>
            </div>
            <div class="colorControls">
                <div class="selectedColorBox" id="selectedColorBox"></div>
                <div class="colorInfo">
                    <div>Selected Color:</div>
                    <div class="colorHexDisplay" id="colorHexDisplay">#000000</div>
                </div>
            </div>
            <div class="colorSelectorBtns">
                <button class="gameBtn primary" id="applyColorBtn"> Apply Color</button>
                <button class="gameBtn" id="closeColorSelectorBtn"> Cancel</button>
            </div>
        </div>
    </div>

    <!-- Practice Game View -->
    <div class="gameView" id="practiceView">
        <button class="backToHome" id="backBtn3"> Back to Home</button>
        <div class="wrap">
            <div class="passwordGame">
                <h2> Math Practice</h2>
                <p class="subtitle">Practice math problems generated by AI based on your age!</p>

                <div class="passwordCard">
                    <h3> Settings</h3>

                    <div class="settingGroup">
                        <label for="ageInput">Your Age (3-50 years):</label>
                        <input type="number" id="ageInput" min="3" max="50" value="10" />
                    </div>

                    <div class="settingGroup">
                        <label for="numProblems">Number of Problems:</label>
                        <input type="number" id="numProblems" min="1" max="20" value="5" />
                    </div>

                    <div class="btnGroup">
                        <button class="gameBtn primary" id="generateProblemsBtn"> Generate Problems</button>
                    </div>
                </div>

                <div class="passwordCard" id="practiceArea" style="display:none;">
                    <h3> Practice Area</h3>

                    <div id="problemsList"></div>

                    <div class="btnGroup">
                        <button class="gameBtn success" id="checkAllAnswersBtn"> Check All Answers</button>
                        <button class="gameBtn primary" id="generateNewProblemsBtn"> New Problems</button>
                    </div>

                    <div class="feedback" id="practiceFeedback"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Password Game View -->
    <div class="gameView" id="passwordView">
        <button class="backToHome" id="backBtn4"> Back to Home</button>
        <div class="passwordGame">
            <h2> Guess the Password</h2>
            <p class="subtitle">Configure your password and try to guess it!</p>

            <div class="passwordCard">
                <h3> Password Settings</h3>

                <div class="settingGroup">
                    <label for="pwdLength">Password Length:</label>
                    <input type="number" id="pwdLength" min="1" max="20" value="6" />
                </div>

                <div class="settingGroup">
                    <label>Character Types:</label>
                    <div class="checkboxList">
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkLowercase" value="lowercase" checked />
                            <label for="chkLowercase">Lowercase letters (a-z)</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkUppercase" value="uppercase" />
                            <label for="chkUppercase">Uppercase letters (A-Z)</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkBothCase" value="bothcase" />
                            <label for="chkBothCase">All types of letters (a-z, A-Z)</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkNumbers" value="numbers" />
                            <label for="chkNumbers">Numbers (0-9)</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkNumLet" value="numlet" />
                            <label for="chkNumLet">Numbers + Letters</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkSymbols" value="symbols" />
                            <label for="chkSymbols">Symbols (!@#$%^&*)</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkNumSym" value="numsym" />
                            <label for="chkNumSym">Numbers + Symbols</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkLetSym" value="letsym" />
                            <label for="chkLetSym">Letters + Symbols</label>
                        </div>
                        <div class="checkboxItem">
                            <input type="checkbox" id="chkAll" value="all" />
                            <label for="chkAll">Letters + Numbers + Symbols</label>
                        </div>
                    </div>
                </div>

                <div class="settingGroup">
                    <label for="customChars">Or use custom characters:</label>
                    <input type="text" id="customChars" placeholder="e.g., arfdngm" />
                </div>

                <div class="btnGroup">
                    <button class="gameBtn primary" id="generateBtn"> Generate Password</button>
                    <button class="gameBtn" id="revealBtn" disabled> Reveal Password</button>
                </div>
            </div>

            <div class="passwordCard" id="gameArea" style="display:none;">
                <h3> Game Area</h3>

                <div class="passwordDisplay" id="passwordDisplay">
                    <span>???</span>
                </div>

                <div class="attemptsCounter">
                    Attempts: <span id="attemptsCount">0</span>
                </div>

                <div class="settingGroup">
                    <input type="text" class="guessInput" id="guessInput" placeholder="Enter your guess..."
                        maxlength="20" />
                </div>

                <div class="btnGroup">
                    <button class="gameBtn success" id="checkBtn"> Check Guess</button>
                    <button class="gameBtn" id="hintBtn"> Get Hint</button>
                    <button class="gameBtn danger" id="giveUpBtn"> Give Up</button>
                </div>

                <div class="feedback" id="feedback"></div>

                <div class="hintsList" id="hintsArea" style="display:none;">
                    <h4> Hints:</h4>
                    <ul id="hintsList"></ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Stopwatch View -->
    <div class="gameView" id="stopwatchView">
        <button class="backToHome" id="backBtn5"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:30px;font-size:32px"> Stopwatch</h2>
                <div style="text-align:center;font-size:72px;font-weight:800;color:var(--accent);margin:40px 0;font-family:monospace;letter-spacing:4px"
                    id="stopwatchDisplay">00:00:00.000</div>
                <div style="display:flex;gap:20px;justify-content:center;margin-top:40px">
                    <button class="gameBtn primary" id="startStopBtn" style="font-size:20px;padding:20px 40px">
                        Start</button>
                    <button class="gameBtn" id="resetStopBtn" style="font-size:20px;padding:20px 40px"> Reset</button>
                    <button class="gameBtn" id="lapBtn" style="font-size:20px;padding:20px 40px"> Lap</button>
                </div>
                <div id="lapsContainer" style="margin-top:30px;max-height:300px;overflow-y:auto">
                    <!-- Lap times will appear here -->
                </div>
            </div>
        </div>
    </div>

    <!-- World Time View -->
    <div class="gameView" id="worldtimeView">
        <button class="backToHome" id="backBtn6"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:900px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:30px;font-size:32px"> World Time</h2>
                <div id="worldTimeGrid"
                    style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:20px;margin-top:30px">
                    <!-- Time zones will be added here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Slice the Pi View -->
    <div class="gameView" id="slicepieView">
        <button class="backToHome" id="backBtn7"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:700px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px;font-size:32px"> Slice the Pi</h2>
                <div style="text-align:center;margin-bottom:30px">
                    <div style="font-size:20px;color:var(--accent);margin-bottom:10px">
                        Level: <span id="pieLevel">1</span> | Score: <span id="pieScore">0</span>
                    </div>
                    <div style="font-size:16px;color:var(--muted)">
                        Cut: <span id="pieTarget">2 equal slices</span>
                    </div>
                </div>
                <canvas id="pieCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:var(--panel);cursor:crosshair"></canvas>
                <div style="text-align:center;margin-top:20px">
                    <button class="btn" id="pieSliceBtn" style="font-size:18px;padding:12px 30px"> Make Cut</button>
                    <button class="btn" id="pieResetBtn" style="font-size:18px;padding:12px 30px;margin-left:10px">
                        Reset</button>
                </div>
                <div id="pieMessage"
                    style="text-align:center;margin-top:20px;font-size:18px;min-height:30px;color:var(--accent)"></div>
            </div>
        </div>
    </div>

    <!-- Literally a Game View -->
    <div class="gameView" id="literallygameView">
        <button class="backToHome" id="backBtn8"> Exit</button>
        <div class="wrap" style="display:flex;align-items:center;justify-content:center;min-height:80vh">
            <div style="text-align:center;color:var(--muted);font-size:20px">
                <!-- Blank screen - nothing to see here -->
            </div>
        </div>
    </div>

    <!-- Color Match View -->
    <div class="gameView" id="colormatchView">
        <button class="backToHome" id="backBtn9"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Color Match</h2>
                <div style="text-align:center;margin-bottom:20px">
                    <div style="font-size:18px;color:var(--accent)">Score: <span id="colorScore">0</span> | Time: <span
                            id="colorTimer">30</span>s</div>
                </div>
                <div id="colorTarget"
                    style="width:200px;height:200px;margin:0 auto 30px;border-radius:10px;border:3px solid var(--accent)">
                </div>
                <div id="colorOptions"
                    style="display:grid;grid-template-columns:repeat(3,1fr);gap:15px;margin-top:20px"></div>
            </div>
        </div>
    </div>

    <!-- Memory Master View -->
    <div class="gameView" id="simonmemoryView">
        <button class="backToHome" id="backBtn10"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Memory Master</h2>
                <div style="text-align:center;margin-bottom:30px">
                    <div style="font-size:18px;color:var(--accent)">Level: <span id="memoryLevel">1</span></div>
                    <div id="memoryStatus" style="margin-top:10px;font-size:16px;color:var(--muted)">Watch the
                        sequence...</div>
                </div>
                <div id="memoryGrid"
                    style="display:grid;grid-template-columns:repeat(2,200px);gap:20px;justify-content:center"></div>
            </div>
        </div>
    </div>

    <!-- Type Racer View -->
    <div class="gameView" id="typingspeedView">
        <button class="backToHome" id="backBtn11"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:700px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Type Racer</h2>
                <div id="typingText"
                    style="font-size:20px;line-height:1.8;color:var(--ink);margin-bottom:30px;padding:20px;background:rgba(255,255,255,0.05);border-radius:10px">
                </div>
                <input type="text" id="typingInput" placeholder="Start typing..."
                    style="width:100%;padding:15px;font-size:18px;background:var(--btn);color:var(--ink);border:2px solid var(--accent);border-radius:10px;margin-bottom:20px" />
                <div style="text-align:center;font-size:16px;color:var(--accent)">
                    WPM: <span id="typingWPM">0</span> | Accuracy: <span id="typingAccuracy">100</span>%
                </div>
            </div>
        </div>
    </div>

    <!-- Reaction Time View -->
    <div class="gameView" id="reactionView">
        <button class="backToHome" id="backBtn12"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Reaction Time</h2>
                <div id="reactionBox"
                    style="width:100%;height:300px;background:var(--btn);border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:24px;cursor:pointer;margin-bottom:20px">
                    Click when green!
                </div>
                <div style="text-align:center;font-size:18px;color:var(--accent)">
                    Best: <span id="reactionBest">-</span>ms | Avg: <span id="reactionAvg">-</span>ms
                </div>
            </div>
        </div>
    </div>

    <!-- Maze Runner View -->
    <div class="gameView" id="mazeView">
        <button class="backToHome" id="backBtn13"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:700px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Maze Runner</h2>
                <div style="text-align:center;margin-bottom:20px;font-size:18px;color:var(--accent)">
                    Level: <span id="mazeLevel">1</span> | Use Arrow Keys
                </div>
                <canvas id="mazeCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:var(--panel)"></canvas>
            </div>
        </div>
    </div>

    <!-- Flappy Clone View -->
    <div class="gameView" id="flappycloneView">
        <button class="backToHome" id="backBtn14"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Flappy Clone</h2>
                <div style="text-align:center;margin-bottom:20px;font-size:18px;color:var(--accent)">
                    Score: <span id="flappyScore">0</span> | Best: <span id="flappyBest">0</span>
                </div>
                <canvas id="flappyCanvas" width="400" height="600"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#87CEEB;cursor:pointer"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Click or Space to flap</div>
            </div>
        </div>
    </div>

    <!-- Tic Tac Toe View -->
    <div class="gameView" id="tictactoeView">
        <button class="backToHome" id="backBtn15"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:500px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Tic Tac Toe</h2>
                <div id="tttStatus" style="text-align:center;margin-bottom:20px;font-size:18px;color:var(--accent)">Your
                    turn (X)</div>
                <div id="tttBoard" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:20px">
                </div>
                <button class="btn" id="tttReset"
                    style="display:block;margin:0 auto;font-size:16px;padding:10px 30px">New Game</button>
            </div>
        </div>
    </div>

    <!-- Snake Classic View -->
    <div class="gameView" id="snakeView">
        <button class="backToHome" id="backBtn16"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:650px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Snake Classic</h2>
                <div style="text-align:center;margin-bottom:20px;font-size:18px;color:var(--accent)">
                    Score: <span id="snakeScore">0</span> | Best: <span id="snakeBest">0</span>
                </div>
                <canvas id="snakeCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#1a1a1a"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Use Arrow Keys | Press Space to start
                </div>
            </div>
        </div>
    </div>

    <!-- Hangman View -->
    <div class="gameView" id="hangmanView">
        <button class="backToHome" id="backBtn17"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Hangman</h2>
                <div style="text-align:center;margin-bottom:20px">Word: <span id="hangmanWord"
                        style="font-size:24px;font-weight:bold;letter-spacing:8px">_ _ _ _ _ _</span></div>
                <div style="text-align:center;margin-bottom:20px;color:var(--accent)">Guesses Left: <span
                        id="hangmanGuesses">6</span></div>
                <div id="hangmanLetters"
                    style="display:grid;grid-template-columns:repeat(7,1fr);gap:8px;margin-bottom:20px"></div>
                <div style="text-align:center;color:var(--muted)" id="hangmanStatus">Guess the word!</div>
            </div>
        </div>
    </div>

    <!-- 2048 View -->
    <div class="gameView" id="game2048View">
        <button class="backToHome" id="backBtn18"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> 2048</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="score2048">0</span></div>
                <div id="game2048Board"
                    style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;max-width:400px;margin:0 auto;background:#bbada0;padding:10px;border-radius:6px">
                </div>
                <div style="text-align:center;margin-top:20px;color:var(--muted)">Use Arrow Keys to move</div>
            </div>
        </div>
    </div>

    <!-- Breakout View -->
    <div class="gameView" id="breakoutView">
        <button class="backToHome" id="backBtn19"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:550px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Breakout</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="breakoutScore">0</span> | Lives:
                    <span id="breakoutLives">3</span>
                </div>
                <canvas id="breakoutCanvas" width="500" height="400"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#222"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Use Arrow Keys to move paddle</div>
            </div>
        </div>
    </div>

    <!-- Pong View -->
    <div class="gameView" id="pongView">
        <button class="backToHome" id="backBtn20"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:550px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Pong</h2>
                <div style="text-align:center;margin-bottom:20px">Player: <span id="pongScore1">0</span> | AI: <span
                        id="pongScore2">0</span></div>
                <canvas id="pongCanvas" width="500" height="400"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Use W/S or Arrow Keys to move</div>
            </div>
        </div>
    </div>

    <!-- Sudoku View -->
    <div class="gameView" id="sudokuView">
        <button class="backToHome" id="backBtn21"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:550px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Sudoku</h2>
                <div id="sudokuBoard"
                    style="display:grid;grid-template-columns:repeat(9,40px);gap:2px;margin:20px auto;width:fit-content;background:#333;padding:5px">
                </div>
                <div style="text-align:center;margin-top:20px">
                    <button id="sudokuReset"
                        style="padding:10px 20px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer">Reset</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Whack-a-Mole View -->
    <div class="gameView" id="whackasmoleView">
        <button class="backToHome" id="backBtn22"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:500px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Whack-a-Mole</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="moleScore">0</span> | Time: <span
                        id="moleTimer">30</span>s</div>
                <div id="moleBoard"
                    style="display:grid;grid-template-columns:repeat(3,80px);gap:10px;margin:0 auto;width:fit-content">
                </div>
            </div>
        </div>
    </div>

    <!-- Trivia View -->
    <div class="gameView" id="triviaView">
        <button class="backToHome" id="backBtn23"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Trivia Quiz</h2>
                <div style="text-align:center;margin-bottom:20px;color:var(--accent)">Score: <span
                        id="triviaScore">0</span>/10</div>
                <div id="triviaQuestion" style="font-size:18px;margin:30px 0;text-align:center;color:var(--ink)"></div>
                <div id="triviaOptions" style="display:grid;grid-template-columns:1fr;gap:10px;margin:20px 0"></div>
            </div>
        </div>
    </div>

    <!-- Asteroid Blaster View -->
    <div class="gameView" id="asteroidView">
        <button class="backToHome" id="backBtn24"> Back to Home</button>
        <div class="wrap">
            <!-- Power-up Control Panel -->
            <div
                style="text-align:center;margin:20px auto;padding:20px;background:rgba(0,255,0,0.1);border:2px solid var(--accent);border-radius:10px;max-width:600px">
                <div style="margin-bottom:15px;font-weight:bold;color:var(--accent)"> POWER-UPS & WEAPONS</div>
                <div style="display:flex;gap:15px;justify-content:center;flex-wrap:wrap">
                    <button id="weaponNormal"
                        style="padding:8px 16px;background:var(--btn);color:var(--ink);border:2px solid #ffff00;border-radius:6px;cursor:pointer;font-weight:bold">1
                        NORMAL</button>
                    <button id="weaponSpread"
                        style="padding:8px 16px;background:var(--btn);color:var(--ink);border:2px solid #00ff00;border-radius:6px;cursor:pointer;font-weight:bold">2
                        SPREADSHOT</button>
                    <button id="weaponLaser"
                        style="padding:8px 16px;background:var(--btn);color:var(--ink);border:2px solid #ff0000;border-radius:6px;cursor:pointer;font-weight:bold">3
                        LASER</button>
                    <button id="weaponSupernova"
                        style="padding:8px 16px;background:var(--btn);color:var(--ink);border:2px solid #ffaa00;border-radius:6px;cursor:pointer;font-weight:bold">4
                        SUPERNOVA</button>
                </div>
                <div style="margin-top:15px;font-size:12px;color:var(--muted)">Current: <span id="currentWeapon"
                        style="color:var(--accent);font-weight:bold">NORMAL</span></div>
                <div id="spreadsheetRaysControl"
                    style="margin-top:15px;display:none;padding:15px;background:rgba(0,255,0,0.05);border:1px solid #00ff00;border-radius:6px">
                    <div style="font-size:12px;color:var(--accent);margin-bottom:10px;font-weight:bold">Spreadshot Rays:
                        <span id="raysValue">5</span>
                    </div>
                    <input id="raysSlider" type="range" min="2" max="20" value="5" style="width:100%;cursor:pointer">
                    <div style="font-size:11px;color:var(--muted);margin-top:8px">2 rays = narrow | 20 rays = massive
                        spread</div>
                </div>
                <div id="laserWidthControl"
                    style="margin-top:15px;display:none;padding:15px;background:rgba(255,0,0,0.05);border:1px solid #ff0000;border-radius:6px">
                    <div style="font-size:12px;color:var(--accent);margin-bottom:10px;font-weight:bold">Laser Width:
                        <span id="laserWidthValue">50</span>px
                    </div>
                    <input id="laserWidthSlider" type="range" min="1" max="200" value="50"
                        style="width:100%;cursor:pointer">
                    <div style="font-size:11px;color:var(--muted);margin-top:8px">1px = narrow & powerful | 200px = wide
                        & weak</div>
                </div>
            </div>
            <div class="passwordCard" style="max-width:600px;margin:20px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Asteroid Blaster</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="asteroidScore">0</span> | Lives:
                    <span id="asteroidLives">3</span>
                </div>
                <canvas id="asteroidCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Arrow Keys to move | Space to shoot |
                    Press 1/2/3 or click buttons to change weapons</div>
            </div>
        </div>
    </div>

    <!-- Space Invaders View -->
    <div class="gameView" id="spaceInvadersView">
        <button class="backToHome" id="backBtn25"> Back to Home</button>
        <div class="wrap">
            <div id="spaceInvadersMenu" class="passwordCard"
                style="max-width:600px;margin:40px auto;padding:40px;text-align:center">
                <h2 style="margin-bottom:30px"> Space Invaders</h2>
                <p style="margin-bottom:20px;font-size:16px">Select Number of Lives:</p>
                <div style="display:flex;gap:15px;justify-content:center;margin-bottom:20px">
                    <button id="lives3"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">3
                        Lives</button>
                    <button id="lives9"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">9
                        Lives</button>
                    <button id="lives27"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">27
                        Lives</button>
                </div>
                <div style="display:flex;gap:10px;justify-content:center;align-items:center;margin-bottom:20px">
                    <label for="enemyHealthInput" style="color:var(--muted);font-size:14px">Enemy Health
                        (1-200):</label>
                    <input id="enemyHealthInput" type="number" min="1" max="200" value="50"
                        style="width:90px;padding:8px;border-radius:6px;border:1px solid #333;text-align:center;background:#0f1628;color:var(--ink)" />
                </div>
            </div>
            <div id="spaceInvadersGame" class="passwordCard"
                style="max-width:600px;margin:40px auto;padding:40px;display:none">
                <h2 style="text-align:center;margin-bottom:20px"> Space Invaders</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="spaceInvadersScore">0</span> | Level:
                    <span id="spaceInvadersLevel">1</span> | Lives: <span id="spaceInvadersLives">3</span>
                </div>
                <div
                    style="text-align:center;margin-bottom:15px;display:flex;justify-content:center;gap:10px;flex-wrap:wrap">
                    <button id="weaponNormal" class="weaponBtn active"
                        style="padding:8px 15px;background:#667eea;color:white;border:2px solid #667eea;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.2s">
                        Normal</button>
                    <button id="weaponBoost" class="weaponBtn"
                        style="padding:8px 15px;background:#1a1a2e;color:#ffff00;border:2px solid #ffff00;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.2s">
                        Boost</button>
                    <button id="weaponSpreadshot" class="weaponBtn"
                        style="padding:8px 15px;background:#1a1a2e;color:#ff00ff;border:2px solid #ff00ff;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.2s">
                        Spreadshot</button>
                    <label style="padding:8px;color:white;font-weight:bold">Rays: <input id="spreadRayInput"
                            type="number" min="1" max="5000" value="5"
                            style="width:50px;padding:5px;border-radius:4px;border:1px solid #666;background:#1a1a2e;color:#ffff00"></label>
                </div>
                <canvas id="spaceInvadersCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Arrow Keys to move | Space to shoot |
                    Click buttons to change weapon</div>
            </div>
        </div>
    </div>

    <!-- Space Invaders but better View -->
    <div class="gameView" id="spaceinvadersbutbetterView">
        <button class="backToHome" id="backBtn25better"> Back to Home</button>
        <div class="wrap">
            <div id="spaceInvadersMenuBetter" class="passwordCard"
                style="max-width:600px;margin:40px auto;padding:40px;text-align:center">
                <h2 style="margin-bottom:30px"> Space invaders but better</h2>
                <p style="margin-bottom:20px;font-size:16px">Select Number of Lives:</p>
                <div style="display:flex;gap:15px;justify-content:center;margin-bottom:20px">
                    <button id="lives3better"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">3
                        Lives</button>
                    <button id="lives9better"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">9
                        Lives</button>
                    <button id="lives27better"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">27
                        Lives</button>
                </div>
                <div style="display:flex;gap:10px;justify-content:center;align-items:center;margin-bottom:20px">
                    <label for="enemyHealthInputBetter" style="color:var(--muted);font-size:14px">Enemy Health
                        (1-200):</label>
                    <input id="enemyHealthInputBetter" type="number" min="1" max="200" value="50"
                        style="width:90px;padding:8px;border-radius:6px;border:1px solid #333;text-align:center;background:#0f1628;color:var(--ink)" />
                </div>
            </div>
            <div id="spaceInvadersGameBetter" class="passwordCard"
                style="max-width:600px;margin:40px auto;padding:40px;display:none">
                <h2 style="text-align:center;margin-bottom:20px"> Space invaders but better</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="spaceInvadersScoreBetter">0</span> |
                    Level:
                    <span id="spaceInvadersLevelBetter">1</span> | Lives: <span id="spaceInvadersLivesBetter">3</span>
                </div>
                <div
                    style="text-align:center;margin-bottom:15px;display:flex;justify-content:center;gap:10px;flex-wrap:wrap">
                    <button id="weaponNormalBetter" class="weaponBtn active"
                        style="padding:8px 15px;background:#667eea;color:white;border:2px solid #667eea;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.2s">
                        Normal</button>
                    <button id="weaponBoostBetter" class="weaponBtn"
                        style="padding:8px 15px;background:#1a1a2e;color:#ffff00;border:2px solid #ffff00;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.2s">
                        Boost</button>
                    <button id="weaponSpreadshotBetter" class="weaponBtn"
                        style="padding:8px 15px;background:#1a1a2e;color:#ff00ff;border:2px solid #ff00ff;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.2s">
                        Spreadshot</button>
                    <label style="padding:8px;color:white;font-weight:bold">Rays: <input id="spreadRayInputBetter"
                            type="number" min="1" max="5000" value="5"
                            style="width:50px;padding:5px;border-radius:4px;border:1px solid #666;background:#1a1a2e;color:#ffff00"></label>
                </div>
                <canvas id="spaceInvadersCanvasBetter" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Arrow Keys to move | Space to shoot |
                    Click buttons to change weapon</div>
            </div>
        </div>
    </div>

    <!-- Mega Game - Space Invaders Plus View -->
    <div class="gameView" id="megagameView">
        <button class="backToHome" id="backBtnMega"> Back to Home</button>
        <div class="wrap">
            <div id="megagameMenu" class="passwordCard"
                style="max-width:600px;margin:40px auto;padding:40px;text-align:center">
                <h2 style="margin-bottom:30px"> Initiate Mega Game</h2>
                <p style="margin-bottom:20px;font-size:16px">Space Invaders Plus with Boss Battle at Level 7</p>
                <p style="margin-bottom:20px;font-size:14px;color:var(--muted)">8 Powerups: Press 1-8 to activate</p>
                <div style="display:flex;gap:15px;justify-content:center;margin-bottom:20px;flex-wrap:wrap">
                    <button id="megaLives3"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">3
                        Lives</button>
                    <button id="megaLives5"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">5
                        Lives</button>
                    <button id="megaLives10"
                        style="padding:15px 30px;font-size:16px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold">10
                        Lives</button>
                </div>
            </div>
            <div id="megagamePlay" class="passwordCard"
                style="max-width:700px;margin:40px auto;padding:20px;display:none">
                <h2 style="text-align:center;margin-bottom:15px"> Space Invaders Plus</h2>
                <div style="text-align:center;margin-bottom:15px;font-size:14px">
                    Score: <span id="megaScore">0</span> | Level: <span id="megaLevel">1</span> | Lives: <span
                        id="megaLives">3</span> | Health: <span id="megaBossHealth">-</span>
                </div>
                <div style="text-align:center;margin-bottom:10px;font-size:12px;color:var(--muted)">
                    Arrow Keys: Move | Space: Shoot | 1-8: Powerups
                </div>
                <canvas id="megagameCanvas" width="600" height="500"
                    style="display:block;margin:0 auto;border:3px solid #667eea;border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:10px;font-size:12px">
                    <span style="color:#ffff00"> Powerups:</span>
                    <span style="color:#ff6b35">1:Rapid</span> |
                    <span style="color:#06ffa5">2:Shield</span> |
                    <span style="color:#ff00ff">3:Beam</span> |
                    <span style="color:#ffd60a">4:Clone</span> |
                    <span style="color:#a78bfa">5:Slow</span> |
                    <span style="color:#fb7185">6:Damage</span> |
                    <span style="color:#4ade80">7:Heal</span> |
                    <span style="color:#06b6d4">8:Nuke</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Pac-Man View -->
    <div class="gameView" id="pacmanView">
        <button class="backToHome" id="backBtn26"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Pac-Man</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="pacmanScore">0</span> | Lives: <span
                        id="pacmanLives">3</span></div>
                <canvas id="pacmanCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Arrow Keys to move | Eat all pellets
                    to win</div>
            </div>
        </div>
    </div>

    <!-- Jumping Shape View -->
    <div class="gameView" id="jumpingShapeView">
        <button class="backToHome" id="backBtn27"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Jumping Shape</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="jumpingShapeScore">0</span> | Best:
                    <span id="jumpingShapeBest">0</span>
                </div>
                <canvas id="jumpingShapeCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Space or Click to jump | Avoid
                    obstacles</div>
            </div>
        </div>
    </div>

    <!-- Memory Flip View -->
    <div class="gameView" id="memoryFlipView">
        <button class="backToHome" id="backBtn28"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Memory Flip</h2>
                <div style="text-align:center;margin-bottom:20px">Moves: <span id="memoryFlipMoves">0</span> | Matched:
                    <span id="memoryFlipMatched">0</span>/8
                </div>
                <div id="memoryFlipBoard"
                    style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:20px auto;max-width:400px">
                </div>
            </div>
        </div>
    </div>

    <!-- Ball Pusher View -->
    <div class="gameView" id="ballPusherView">
        <button class="backToHome" id="backBtn29"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Ball Pusher</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="ballPusherScore">0</span> | Level:
                    <span id="ballPusherLevel">1</span>
                </div>
                <canvas id="ballPusherCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Arrow Keys to move | Push balls into
                    goals</div>
            </div>
        </div>
    </div>

    <!-- Number Chain View -->
    <div class="gameView" id="numberChainView">
        <button class="backToHome" id="backBtn30"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Number Chain</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="numberChainScore">0</span> | Chains:
                    <span id="numberChainChains">0</span>
                </div>
                <div id="numberChainBoard"
                    style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin:20px auto;max-width:400px">
                </div>
            </div>
        </div>
    </div>

    <!-- Asteroid Fighter View -->
    <div class="gameView" id="asteroidFighterView">
        <button class="backToHome" id="backBtn31"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Asteroid Fighter</h2>
                <div style="text-align:center;margin-bottom:20px">Score: <span id="asteroidFighterScore">0</span> |
                    Wave: <span id="asteroidFighterWave">1</span></div>
                <canvas id="asteroidFighterCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
                <div style="text-align:center;margin-top:15px;color:var(--muted)">Arrow Keys to move | Space to shoot |
                    Defeat all enemies</div>
            </div>
        </div>
    </div>

    <!-- Fast Clicker View -->
    <div class="gameView" id="fastClickerView">
        <button class="backToHome" id="backBtn32"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:40px">
                <h2 style="text-align:center;margin-bottom:20px"> Fast Clicker</h2>
                <div style="text-align:center;margin-bottom:20px">Clicks: <span id="fastClickerCount">0</span> | Time:
                    <span id="fastClickerTime">30</span>s
                </div>
                <button id="fastClickerBtn"
                    style="display:block;margin:40px auto;padding:60px;font-size:48px;background:linear-gradient(135deg,#667eea,#764ba2);color:white;border:none;border-radius:20px;cursor:pointer;transition:all 0.1s">CLICK
                    ME!</button>
                <div id="fastClickerMessage"
                    style="text-align:center;margin-top:20px;color:var(--accent);font-size:18px;font-weight:bold"></div>
            </div>
        </div>
    </div>

    <!-- New Games View Templates -->
    <div class="gameView" id="zombierunnerView">
        <button class="backToHome" id="backBtnZombie"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:20px">
                <h2 style="text-align:center;margin-bottom:15px"> Zombie Runner</h2>
                <div style="text-align:center;margin-bottom:15px;font-size:14px">Score: <span
                        id="zombierunnerScore">0</span> | Lives: <span id="zombierunnerLives">3</span> | Level: <span
                        id="zombierunnerLevel">1</span></div>
                <canvas id="zombierunnerCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="memorymatchView">
        <button class="backToHome" id="backBtnMemory"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:20px">
                <h2 style="text-align:center;margin-bottom:15px"> Memory Match</h2>
                <div style="text-align:center;margin-bottom:15px;font-size:14px">Score: <span
                        id="memorymatchScore">0</span> | Lives: <span id="memorymatchLives">3</span></div>
                <div id="memorymatchGameArea" style="width:100%;height:400px"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="dinojumpView">
        <button class="backToHome" id="backBtnDino"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:20px">
                <h2 style="text-align:center;margin-bottom:15px"> Dino Jump</h2>
                <div style="text-align:center;margin-bottom:15px;font-size:14px">Score: <span
                        id="dinojumpScore">0</span> | Lives: <span id="dinojumpLives">3</span></div>
                <canvas id="dinojumpCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#87CEEB"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="blockblastView">
        <button class="backToHome" id="backBtnBlock"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:20px">
                <h2 style="text-align:center;margin-bottom:15px"> Block Blast</h2>
                <div style="text-align:center;margin-bottom:15px;font-size:14px">Score: <span
                        id="blockblastScore">0</span> | Level: <span id="blockblastLevel">1</span></div>
                <canvas id="blockblastCanvas" width="300" height="600"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#1a1a2e"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="bubbleshooterView">
        <button class="backToHome" id="backBtnBubble"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:20px">
                <h2 style="text-align:center;margin-bottom:15px"> Bubble Shooter</h2>
                <div style="text-align:center;margin-bottom:15px;font-size:14px">Score: <span
                        id="bubbleshooterScore">0</span> | Level: <span id="bubbleshooterLevel">1</span></div>
                <canvas id="bubbleshooterCanvas" width="500" height="500"
                    style="display:block;margin:0 auto;border:2px solid var(--accent);border-radius:10px;background:#000"></canvas>
            </div>
        </div>
    </div>

    <!-- Generic Game Views for Simple Games -->
    <div class="gameView" id="spaceshooterView">
        <button class="backToHome" id="backBtnSpaceShooter"> Back to Home</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto;padding:20px">
                <h2 style="text-align:center"> Space Shooter</h2>
                <div style="text-align:center;margin:10px 0;font-size:14px">Score: <span id="spaceshooterScore">0</span>
                    | Level: <span id="spaceshooterLevel">1</span> | Lives: <span id="spaceshooterLives">3</span></div>
                <div style="text-align:center;margin:10px 0"><button id="spaceshooterSound"></button> <button
                        id="spaceshooterPause"> Pause</button></div>
                <div id="spaceshooterGameArea" style="width:100%;height:300px;background:#000;border-radius:8px"></div>
            </div>
        </div>
    </div>

    <!-- Additional game view templates (condensed for space) -->
    <div class="gameView" id="whackratsView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard" style="max-width:600px;margin:40px auto">
                <h2> Whack Rats</h2>
                <div style="text-align:center;margin:10px">Score: <span id="whackratsScore">0</span></div>
                <div id="whackratsGameArea" style="height:300px;background:#8B4513"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="catchfallingView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Catch Falling</h2>
                <div style="text-align:center">Score: <span id="catchfallingScore">0</span></div><canvas width="500"
                    height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="brickbreakerView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Brick Breaker</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="defendcastleView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Defend Castle</h2>
                <div id="defendcastleGameArea" style="height:300px;background:#8B7355"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="pipepuzzleView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Pipe Puzzle</h2>
                <div id="pipepuzzleGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="matchthreeView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Match Three</h2>
                <div id="matchthreeGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="platformerView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Platformer</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="ballmazeView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Ball Maze</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="cardmemoryView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Card Memory</h2>
                <div id="cardmemoryGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="lightsoutView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Lights Out</h2>
                <div id="lightsoutGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="sokobanView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Sokoban</h2><canvas width="400" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="dotchaseView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Dot Chase</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="wordscrambleView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Word Scramble</h2>
                <div id="wordscrambleGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>

    <div class="gameView" id="bouncemaniaView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Bounce Mania</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="mineslideView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Mine Slide</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <div class="gameView" id="flipcardsView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Flip Cards</h2>
                <div id="flipcardsGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>

    <!-- Remaining games (space-efficient) -->
    <div class="gameView" id="colorblindView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Color Blind</h2>
                <div id="colorblindGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>
    <div class="gameView" id="numberjumpView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Number Jump</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="dragonslayerView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Dragon Slayer</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="fishfeedView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Fish Feed</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="pigsflyView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Pigs Fly</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="bricksbreaker2View"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Bricks Breaker 2</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="slideblockView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Slide Block</h2>
                <div id="slideblockGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>
    <div class="gameView" id="asteroidshootView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Asteroid Shoot</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="ghosthuntView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Ghost Hunt</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="towerstackView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Tower Stack</h2><canvas width="400" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="scrollmatchView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Scroll Match</h2><canvas width="500" height="300" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="starfieldView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Starfield</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="locksmithView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Locksmith</h2>
                <div id="locksmithGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>
    <div class="gameView" id="spiderwebView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Spider Web</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="jetpackView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Jetpack</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="moneystackView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Money Stack</h2><canvas width="400" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="clockworkView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Clockwork</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="cloudwalkView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Cloud Walk</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="gravitasView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Gravitas</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="motionflashView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Motion Flash</h2>
                <div id="motionflashGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>
    <div class="gameView" id="windrunnerView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Wind Runner</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="iceslideView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Ice Slide</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="fireburstView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Fire Burst</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="waterflowView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Water Flow</h2>
                <div id="waterflowGameArea" style="height:300px"></div>
            </div>
        </div>
    </div>
    <div class="gameView" id="shadowjumpView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Shadow Jump</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="lightburstView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Light Burst</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="energyflowView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Energy Flow</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="crystalgemView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Crystal Gem</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="volcanorunView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Volcano Run</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="desertblastView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Desert Blast</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="frozenquestView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Frozen Quest</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="jurassicView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Jurassic</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="deepseadiveView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Deep Sea Dive</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="forestwalkView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Forest Walk</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="skyglideView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Sky Glide</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="moonbaseView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Moon Base</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="sunburstView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Sun Burst</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="rainbowraceView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Rainbow Race</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="thunderstrikeView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Thunder Strike</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="stormchasersView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Storm Chasers</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="blizzardrunView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Blizzard Run</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="tornadoView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Tornado</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="meteorstrikeView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Meteor Strike</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="galaxydefView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Galaxy Defense</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="nebulaView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Nebula</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="blackholeView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Black Hole</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="warpdriveView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Warp Drive</h2><canvas width="500" height="400" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>
    <div class="gameView" id="pulsewaveView"><button class="backToHome"> Back</button>
        <div class="wrap">
            <div class="passwordCard">
                <h2> Pulse Wave</h2><canvas width="500" height="500" style="border:2px solid #667eea"></canvas>
            </div>
        </div>
    </div>

    <script>
        // ========== GAME CENTER NAVIGATION ==========
        const startScreen = document.getElementById('startScreen');
        const calculatorView = document.getElementById('calculatorView');
        const drawingView = document.getElementById('drawingView');
        const practiceView = document.getElementById('practiceView');
        const passwordView = document.getElementById('passwordView');
        const stopwatchView = document.getElementById('stopwatchView');
        const worldtimeView = document.getElementById('worldtimeView');
        const slicepieView = document.getElementById('slicepieView');
        const literallygameView = document.getElementById('literallygameView');
        const colormatchView = document.getElementById('colormatchView');
        const simonmemoryView = document.getElementById('simonmemoryView');
        const typingspeedView = document.getElementById('typingspeedView');
        const reactionView = document.getElementById('reactionView');
        const mazeView = document.getElementById('mazeView');
        const flappycloneView = document.getElementById('flappycloneView');
        const tictactoeView = document.getElementById('tictactoeView');
        const snakeView = document.getElementById('snakeView');
        const hangmanView = document.getElementById('hangmanView');
        const game2048View = document.getElementById('game2048View');
        const breakoutView = document.getElementById('breakoutView');
        const pongView = document.getElementById('pongView');
        const sudokuView = document.getElementById('sudokuView');
        const whackasmoleView = document.getElementById('whackasmoleView');
        const triviaView = document.getElementById('triviaView');
        const asteroidView = document.getElementById('asteroidView');
        const spaceInvadersView = document.getElementById('spaceInvadersView');
        const spaceinvadersbutbetterView = document.getElementById('spaceinvadersbutbetterView');
        const megagameView = document.getElementById('megagameView');
        const pacmanView = document.getElementById('pacmanView');
        const jumpingShapeView = document.getElementById('jumpingShapeView');
        const memoryFlipView = document.getElementById('memoryFlipView');
        const ballPusherView = document.getElementById('ballPusherView');
        const numberChainView = document.getElementById('numberChainView');
        const asteroidFighterView = document.getElementById('asteroidFighterView');
        const fastClickerView = document.getElementById('fastClickerView');
        const asteroidshootView = document.getElementById('asteroidshootView');
        const ballmazeView = document.getElementById('ballmazeView');
        const blackholeView = document.getElementById('blackholeView');
        const blizzardrunView = document.getElementById('blizzardrunView');
        const blockblastView = document.getElementById('blockblastView');
        const bouncemaniaView = document.getElementById('bouncemaniaView');
        const brickbreakerView = document.getElementById('brickbreakerView');
        const bricksbreaker2View = document.getElementById('bricksbreaker2View');
        const bubbleshooterView = document.getElementById('bubbleshooterView');
        const cardmemoryView = document.getElementById('cardmemoryView');
        const catchfallingView = document.getElementById('catchfallingView');
        const clockworkView = document.getElementById('clockworkView');
        const cloudwalkView = document.getElementById('cloudwalkView');
        const colorblindView = document.getElementById('colorblindView');
        const crystalgemView = document.getElementById('crystalgemView');
        const deepseadiveView = document.getElementById('deepseadiveView');
        const defendcastleView = document.getElementById('defendcastleView');
        const desertblastView = document.getElementById('desertblastView');
        const dinojumpView = document.getElementById('dinojumpView');
        const dotchaseView = document.getElementById('dotchaseView');
        const dragonslayerView = document.getElementById('dragonslayerView');
        const energyflowView = document.getElementById('energyflowView');
        const fireburstView = document.getElementById('fireburstView');
        const fishfeedView = document.getElementById('fishfeedView');
        const flipcardsView = document.getElementById('flipcardsView');
        const forestwalkView = document.getElementById('forestwalkView');
        const frozenquestView = document.getElementById('frozenquestView');
        const galaxydefView = document.getElementById('galaxydefView');
        const ghosthuntView = document.getElementById('ghosthuntView');
        const gravitasView = document.getElementById('gravitasView');
        const iceslideView = document.getElementById('iceslideView');
        const jetpackView = document.getElementById('jetpackView');
        const jurassicView = document.getElementById('jurassicView');
        const lightburstView = document.getElementById('lightburstView');
        const lightsoutView = document.getElementById('lightsoutView');
        const locksmithView = document.getElementById('locksmithView');
        const matchthreeView = document.getElementById('matchthreeView');
        const memorymatchView = document.getElementById('memorymatchView');
        const meteorstrikeView = document.getElementById('meteorstrikeView');
        const mineslideView = document.getElementById('mineslideView');
        const moneystackView = document.getElementById('moneystackView');
        const moonbaseView = document.getElementById('moonbaseView');
        const motionflashView = document.getElementById('motionflashView');
        const nebulaView = document.getElementById('nebulaView');
        const numberjumpView = document.getElementById('numberjumpView');
        const pigsflyView = document.getElementById('pigsflyView');
        const pipepuzzleView = document.getElementById('pipepuzzleView');
        const platformerView = document.getElementById('platformerView');
        const pulsewaveView = document.getElementById('pulsewaveView');
        const rainbowraceView = document.getElementById('rainbowraceView');
        const scrollmatchView = document.getElementById('scrollmatchView');
        const shadowjumpView = document.getElementById('shadowjumpView');
        const skyglideView = document.getElementById('skyglideView');
        const slideblockView = document.getElementById('slideblockView');
        const sokobanView = document.getElementById('sokobanView');
        const spaceshooterView = document.getElementById('spaceshooterView');
        const spiderwebView = document.getElementById('spiderwebView');
        const starfieldView = document.getElementById('starfieldView');
        const stormchasersView = document.getElementById('stormchasersView');
        const sunburstView = document.getElementById('sunburstView');
        const thunderstrikeView = document.getElementById('thunderstrikeView');
        const tornadoView = document.getElementById('tornadoView');
        const towerstackView = document.getElementById('towerstackView');
        const volcanorunView = document.getElementById('volcanorunView');
        const warpdriveView = document.getElementById('warpdriveView');
        const waterflowView = document.getElementById('waterflowView');
        const whackratsView = document.getElementById('whackratsView');
        const windrunnerView = document.getElementById('windrunnerView');
        const wordscrambleView = document.getElementById('wordscrambleView');
        const zombierunnerView = document.getElementById('zombierunnerView');
        const settingsView = document.getElementById('settingsView');
        const settingsBtn = document.getElementById('settingsBtn');

        // Scroll disable state
        let scrollDisabled = false;
        let dKeyPressed = false;

        // Keyboard shortcuts for scroll control
        window.addEventListener('keydown', (e) => {
            // Ctrl+Shift+S to toggle scroll
            if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                scrollDisabled = !scrollDisabled;
                document.body.style.overflow = scrollDisabled ? 'hidden' : 'auto';
                console.log(`Scroll ${scrollDisabled ? 'disabled' : 'enabled'}`);
            }

            // D key for sequence D -> S
            if (e.key === 'd' || e.key === 'D') {
                dKeyPressed = true;
                setTimeout(() => { dKeyPressed = false; }, 500);
            }

            // S key after D to toggle scroll
            if ((e.key === 's' || e.key === 'S') && dKeyPressed) {
                e.preventDefault();
                scrollDisabled = !scrollDisabled;
                document.body.style.overflow = scrollDisabled ? 'hidden' : 'auto';
                dKeyPressed = false;
                console.log(`Scroll ${scrollDisabled ? 'disabled' : 'enabled'}`);
            }
        });

        // Game card click handlers
        document.querySelectorAll('.gameCard').forEach(card => {
            card.addEventListener('click', () => {
                const game = card.getAttribute('data-game');
                startScreen.style.display = 'none';

                if (game === 'calculator') {
                    calculatorView.classList.add('active');
                } else if (game === 'drawing') {
                    drawingView.classList.add('active');
                } else if (game === 'practice') {
                    practiceView.classList.add('active');
                } else if (game === 'password') {
                    passwordView.classList.add('active');
                } else if (game === 'stopwatch') {
                    stopwatchView.classList.add('active');
                } else if (game === 'worldtime') {
                    worldtimeView.classList.add('active');
                    initWorldTime();
                } else if (game === 'slicepie') {
                    slicepieView.classList.add('active');
                    initSlicePie();
                } else if (game === 'literallygame') {
                    literallygameView.classList.add('active');
                } else if (game === 'colormatch') {
                    colormatchView.classList.add('active');
                    initColorMatch();
                } else if (game === 'simonmemory') {
                    simonmemoryView.classList.add('active');
                    initMemoryGame();
                } else if (game === 'typingspeed') {
                    typingspeedView.classList.add('active');
                    initTypingGame();
                } else if (game === 'reaction') {
                    reactionView.classList.add('active');
                    initReactionGame();
                } else if (game === 'maze') {
                    mazeView.classList.add('active');
                    initMazeGame();
                } else if (game === 'flappyclone') {
                    flappycloneView.classList.add('active');
                    initFlappyGame();
                } else if (game === 'tictactoe') {
                    tictactoeView.classList.add('active');
                    initTicTacToe();
                } else if (game === 'snake') {
                    snakeView.classList.add('active');
                    initSnakeGame();
                } else if (game === 'hangman') {
                    hangmanView.classList.add('active');
                    initHangman();
                } else if (game === '2048') {
                    game2048View.classList.add('active');
                    init2048();
                } else if (game === 'breakout') {
                    breakoutView.classList.add('active');
                    initBreakout();
                } else if (game === 'pong') {
                    pongView.classList.add('active');
                    initPong();
                } else if (game === 'sudoku') {
                    sudokuView.classList.add('active');
                    initSudoku();
                } else if (game === 'whackamole') {
                    whackasmoleView.classList.add('active');
                    initWhackaMole();
                } else if (game === 'trivia') {
                    triviaView.classList.add('active');
                    initTrivia();
                } else if (game === 'asteroid') {
                    asteroidView.classList.add('active');
                    initAsteroid();
                } else if (game === 'spaceinvaders') {
                    spaceInvadersView.classList.add('active');
                    document.getElementById('spaceInvadersMenu').style.display = 'block';
                    document.getElementById('spaceInvadersGame').style.display = 'none';
                } else if (game === 'spaceinvadersbutbetter') {
                    spaceinvadersbutbetterView.classList.add('active');
                    document.getElementById('spaceInvadersMenuBetter').style.display = 'block';
                    document.getElementById('spaceInvadersGameBetter').style.display = 'none';
                } else if (game === 'megagame') {
                    megagameView.classList.add('active');
                    document.getElementById('megagameMenu').style.display = 'block';
                    document.getElementById('megagamePlay').style.display = 'none';
                } else if (game === 'pacman') {
                    pacmanView.classList.add('active');
                    initPacMan();
                } else if (game === 'jumpingshape') {
                    jumpingShapeView.classList.add('active');
                    initJumpingShape();
                } else if (game === 'memoryflip') {
                    memoryFlipView.classList.add('active');
                    initMemoryFlip();
                } else if (game === 'ballpusher') {
                    ballPusherView.classList.add('active');
                    initBallPusher();
                } else if (game === 'numberchain') {
                    numberChainView.classList.add('active');
                    initNumberChain();
                } else if (game === 'asteroidfighter') {
                    asteroidFighterView.classList.add('active');
                    initAsteroidFighter();
                } else if (game === 'fastclicker') {
                    fastClickerView.classList.add('active');
                    initFastClicker();
                } else if (game === 'asteroidshoot') {
                    asteroidshootView.classList.add('active');
                    initAsteroidshoot();
                } else if (game === 'ballmaze') {
                    ballmazeView.classList.add('active');
                    initBallmaze();
                } else if (game === 'blackhole') {
                    blackholeView.classList.add('active');
                    initBlackhole();
                } else if (game === 'blizzardrun') {
                    blizzardrunView.classList.add('active');
                    initBlizzardrun();
                } else if (game === 'blockblast') {
                    blockblastView.classList.add('active');
                    initBlockblast();
                } else if (game === 'bouncemania') {
                    bouncemaniaView.classList.add('active');
                    initBouncemania();
                } else if (game === 'brickbreaker') {
                    brickbreakerView.classList.add('active');
                    initBrickbreaker();
                } else if (game === 'bricksbreaker2') {
                    bricksbreaker2View.classList.add('active');
                    initBricksbreaker2();
                } else if (game === 'bubbleshooter') {
                    bubbleshooterView.classList.add('active');
                    initBubbleshooter();
                } else if (game === 'cardmemory') {
                    cardmemoryView.classList.add('active');
                    initCardmemory();
                } else if (game === 'catchfalling') {
                    catchfallingView.classList.add('active');
                    initCatchfalling();
                } else if (game === 'clockwork') {
                    clockworkView.classList.add('active');
                    initClockwork();
                } else if (game === 'cloudwalk') {
                    cloudwalkView.classList.add('active');
                    initCloudwalk();
                } else if (game === 'colorblind') {
                    colorblindView.classList.add('active');
                    initColorblind();
                } else if (game === 'crystalgem') {
                    crystalgemView.classList.add('active');
                    initCrystalgem();
                } else if (game === 'deepseadive') {
                    deepseadiveView.classList.add('active');
                    initDeepseadive();
                } else if (game === 'defendcastle') {
                    defendcastleView.classList.add('active');
                    initDefendcastle();
                } else if (game === 'desertblast') {
                    desertblastView.classList.add('active');
                    initDesertblast();
                } else if (game === 'dinojump') {
                    dinojumpView.classList.add('active');
                    initDinojump();
                } else if (game === 'dotchase') {
                    dotchaseView.classList.add('active');
                    initDotchase();
                } else if (game === 'dragonslayer') {
                    dragonslayerView.classList.add('active');
                    initDragonslayer();
                } else if (game === 'energyflow') {
                    energyflowView.classList.add('active');
                    initEnergyflow();
                } else if (game === 'fireburst') {
                    fireburstView.classList.add('active');
                    initFireburst();
                } else if (game === 'fishfeed') {
                    fishfeedView.classList.add('active');
                    initFishfeed();
                } else if (game === 'flipcards') {
                    flipcardsView.classList.add('active');
                    initFlipcards();
                } else if (game === 'forestwalk') {
                    forestwalkView.classList.add('active');
                    initForestwalk();
                } else if (game === 'frozenquest') {
                    frozenquestView.classList.add('active');
                    initFrozenquest();
                } else if (game === 'galaxydef') {
                    galaxydefView.classList.add('active');
                    initGalaxydef();
                } else if (game === 'ghosthunt') {
                    ghosthuntView.classList.add('active');
                    initGhosthunt();
                } else if (game === 'gravitas') {
                    gravitasView.classList.add('active');
                    initGravitas();
                } else if (game === 'iceslide') {
                    iceslideView.classList.add('active');
                    initIceslide();
                } else if (game === 'jetpack') {
                    jetpackView.classList.add('active');
                    initJetpack();
                } else if (game === 'jurassic') {
                    jurassicView.classList.add('active');
                    initJurassic();
                } else if (game === 'lightburst') {
                    lightburstView.classList.add('active');
                    initLightburst();
                } else if (game === 'lightsout') {
                    lightsoutView.classList.add('active');
                    initLightsout();
                } else if (game === 'locksmith') {
                    locksmithView.classList.add('active');
                    initLocksmith();
                } else if (game === 'matchthree') {
                    matchthreeView.classList.add('active');
                    initMatchthree();
                } else if (game === 'memorymatch') {
                    memorymatchView.classList.add('active');
                    initMemorymatch();
                } else if (game === 'meteorstrike') {
                    meteorstrikeView.classList.add('active');
                    initMeteorstrike();
                } else if (game === 'mineslide') {
                    mineslideView.classList.add('active');
                    initMineslide();
                } else if (game === 'moneystack') {
                    moneystackView.classList.add('active');
                    initMoneystack();
                } else if (game === 'moonbase') {
                    moonbaseView.classList.add('active');
                    initMoonbase();
                } else if (game === 'motionflash') {
                    motionflashView.classList.add('active');
                    initMotionflash();
                } else if (game === 'nebula') {
                    nebulaView.classList.add('active');
                    initNebula();
                } else if (game === 'numberjump') {
                    numberjumpView.classList.add('active');
                    initNumberjump();
                } else if (game === 'pigsfly') {
                    pigsflyView.classList.add('active');
                    initPigsfly();
                } else if (game === 'pipepuzzle') {
                    pipepuzzleView.classList.add('active');
                    initPipepuzzle();
                } else if (game === 'platformer') {
                    platformerView.classList.add('active');
                    initPlatformer();
                } else if (game === 'pulsewave') {
                    pulsewaveView.classList.add('active');
                    initPulsewave();
                } else if (game === 'rainbowrace') {
                    rainbowraceView.classList.add('active');
                    initRainbowrace();
                } else if (game === 'scrollmatch') {
                    scrollmatchView.classList.add('active');
                    initScrollmatch();
                } else if (game === 'shadowjump') {
                    shadowjumpView.classList.add('active');
                    initShadowjump();
                } else if (game === 'skyglide') {
                    skyglideView.classList.add('active');
                    initSkyglide();
                } else if (game === 'slideblock') {
                    slideblockView.classList.add('active');
                    initSlideblock();
                } else if (game === 'sokoban') {
                    sokobanView.classList.add('active');
                    initSokoban();
                } else if (game === 'spaceshooter') {
                    spaceshooterView.classList.add('active');
                    initSpaceshooter();
                } else if (game === 'spiderweb') {
                    spiderwebView.classList.add('active');
                    initSpiderweb();
                } else if (game === 'starfield') {
                    starfieldView.classList.add('active');
                    initStarfield();
                } else if (game === 'stormchasers') {
                    stormchasersView.classList.add('active');
                    initStormchasers();
                } else if (game === 'sunburst') {
                    sunburstView.classList.add('active');
                    initSunburst();
                } else if (game === 'thunderstrike') {
                    thunderstrikeView.classList.add('active');
                    initThunderstrike();
                } else if (game === 'tornado') {
                    tornadoView.classList.add('active');
                    initTornado();
                } else if (game === 'towerstack') {
                    towerstackView.classList.add('active');
                    initTowerstack();
                } else if (game === 'volcanorun') {
                    volcanorunView.classList.add('active');
                    initVolcanorun();
                } else if (game === 'warpdrive') {
                    warpdriveView.classList.add('active');
                    initWarpdrive();
                } else if (game === 'waterflow') {
                    waterflowView.classList.add('active');
                    initWaterflow();
                } else if (game === 'whackrats') {
                    whackratsView.classList.add('active');
                    initWhackrats();
                } else if (game === 'windrunner') {
                    windrunnerView.classList.add('active');
                    initWindrunner();
                } else if (game === 'wordscramble') {
                    wordscrambleView.classList.add('active');
                    initWordscramble();
                } else if (game === 'zombierunner') {
                    zombierunnerView.classList.add('active');
                }
            });
        });

        // Back to home handlers
        document.querySelectorAll('.backToHome').forEach(btn => {
            btn.addEventListener('click', () => {
                // Special handler for Literally a Game
                if (btn.id === 'backBtn8' && literallygameView.classList.contains('active')) {
                    triggerLiterallyGameExit();
                    return;
                }

                startScreen.style.display = 'flex';
                calculatorView.classList.remove('active');
                drawingView.classList.remove('active');
                practiceView.classList.remove('active');
                passwordView.classList.remove('active');
                stopwatchView.classList.remove('active');
                worldtimeView.classList.remove('active');
                slicepieView.classList.remove('active');
                literallygameView.classList.remove('active');
                colormatchView.classList.remove('active');
                simonmemoryView.classList.remove('active');
                typingspeedView.classList.remove('active');
                reactionView.classList.remove('active');
                mazeView.classList.remove('active');
                flappycloneView.classList.remove('active');
                tictactoeView.classList.remove('active');
                snakeView.classList.remove('active');
                hangmanView.classList.remove('active');
                game2048View.classList.remove('active');
                breakoutView.classList.remove('active');
                pongView.classList.remove('active');
                sudokuView.classList.remove('active');
                whackasmoleView.classList.remove('active');
                triviaView.classList.remove('active');
                asteroidView.classList.remove('active');
                spaceInvadersView.classList.remove('active');
                spaceinvadersbutbetterView.classList.remove('active');
                megagameView.classList.remove('active');
                pacmanView.classList.remove('active');
                jumpingShapeView.classList.remove('active');
                memoryFlipView.classList.remove('active');
                ballPusherView.classList.remove('active');
                numberChainView.classList.remove('active');
                asteroidFighterView.classList.remove('active');
                fastClickerView.classList.remove('active');
                asteroidshootView.classList.remove('active');
                ballmazeView.classList.remove('active');
                blackholeView.classList.remove('active');
                blizzardrunView.classList.remove('active');
                blockblastView.classList.remove('active');
                bouncemaniaView.classList.remove('active');
                brickbreakerView.classList.remove('active');
                bricksbreaker2View.classList.remove('active');
                bubbleshooterView.classList.remove('active');
                cardmemoryView.classList.remove('active');
                catchfallingView.classList.remove('active');
                clockworkView.classList.remove('active');
                cloudwalkView.classList.remove('active');
                colorblindView.classList.remove('active');
                crystalgemView.classList.remove('active');
                deepseadiveView.classList.remove('active');
                defendcastleView.classList.remove('active');
                desertblastView.classList.remove('active');
                dinojumpView.classList.remove('active');
                dotchaseView.classList.remove('active');
                dragonslayerView.classList.remove('active');
                energyflowView.classList.remove('active');
                fireburstView.classList.remove('active');
                fishfeedView.classList.remove('active');
                flipcardsView.classList.remove('active');
                forestwalkView.classList.remove('active');
                frozenquestView.classList.remove('active');
                galaxydefView.classList.remove('active');
                ghosthuntView.classList.remove('active');
                gravitasView.classList.remove('active');
                iceslideView.classList.remove('active');
                jetpackView.classList.remove('active');
                jurassicView.classList.remove('active');
                lightburstView.classList.remove('active');
                lightsoutView.classList.remove('active');
                locksmithView.classList.remove('active');
                matchthreeView.classList.remove('active');
                memorymatchView.classList.remove('active');
                meteorstrikeView.classList.remove('active');
                mineslideView.classList.remove('active');
                moneystackView.classList.remove('active');
                moonbaseView.classList.remove('active');
                motionflashView.classList.remove('active');
                nebulaView.classList.remove('active');
                numberjumpView.classList.remove('active');
                pigsflyView.classList.remove('active');
                pipepuzzleView.classList.remove('active');
                platformerView.classList.remove('active');
                pulsewaveView.classList.remove('active');
                rainbowraceView.classList.remove('active');
                scrollmatchView.classList.remove('active');
                shadowjumpView.classList.remove('active');
                skyglideView.classList.remove('active');
                slideblockView.classList.remove('active');
                sokobanView.classList.remove('active');
                spaceshooterView.classList.remove('active');
                spiderwebView.classList.remove('active');
                starfieldView.classList.remove('active');
                stormchasersView.classList.remove('active');
                sunburstView.classList.remove('active');
                thunderstrikeView.classList.remove('active');
                tornadoView.classList.remove('active');
                towerstackView.classList.remove('active');
                volcanorunView.classList.remove('active');
                warpdriveView.classList.remove('active');
                waterflowView.classList.remove('active');
                whackratsView.classList.remove('active');
                windrunnerView.classList.remove('active');
                wordscrambleView.classList.remove('active');
                zombierunnerView.classList.remove('active');
                settingsView.classList.remove('active');
            });
        });

        // Utility function to show views
        function showView(viewName) {
            startScreen.style.display = 'none';
            calculatorView.classList.remove('active');
            drawingView.classList.remove('active');
            practiceView.classList.remove('active');
            passwordView.classList.remove('active');
            stopwatchView.classList.remove('active');
            worldtimeView.classList.remove('active');
            slicepieView.classList.remove('active');
            literallygameView.classList.remove('active');
            colormatchView.classList.remove('active');
            simonmemoryView.classList.remove('active');
            typingspeedView.classList.remove('active');
            reactionView.classList.remove('active');
            mazeView.classList.remove('active');
            flappycloneView.classList.remove('active');
            tictactoeView.classList.remove('active');
            snakeView.classList.remove('active');
            settingsView.classList.remove('active');
            spaceinvadersbutbetterView.classList.remove('active');

            if (viewName === 'gameCenter') {
                startScreen.style.display = 'flex';
            } else if (viewName === 'settings') {
                settingsView.classList.add('active');
            }
        }

        // Sync settings between calculator and global settings
        function syncSettingsToGlobal() {
            const duration = document.getElementById('chaosTimerDuration');
            const durationGlobal = document.getElementById('chaosTimerDurationGlobal');
            if (duration && durationGlobal) {
                durationGlobal.value = duration.value;
            }

            const snakeDelay = document.getElementById('snakeCutDelayCalc');
            const snakeDelayGlobal = document.getElementById('snakeCutDelay');
            if (snakeDelay && snakeDelayGlobal) {
                snakeDelayGlobal.value = snakeDelay.value;
            }
        }

        function syncGlobalToSettings() {
            const duration = document.getElementById('chaosTimerDuration');
            const durationGlobal = document.getElementById('chaosTimerDurationGlobal');
            if (duration && durationGlobal) {
                duration.value = durationGlobal.value;
            }

            const snakeDelay = document.getElementById('snakeCutDelayCalc');
            const snakeDelayGlobal = document.getElementById('snakeCutDelay');
            if (snakeDelay && snakeDelayGlobal) {
                snakeDelay.value = snakeDelayGlobal.value;
            }
        }

        // ========== LITERALLY A GAME EXIT SEQUENCE ==========
        function triggerLiterallyGameExit() {
            // Don't exit! Start the chaos sequence

            // 1. Spin the screen like crazy
            document.body.classList.add('chaos-spin', 'chaos-strobe', 'chaos-pulse');

            // 2. Play loud sound announcement
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('You cannot escape! Chaos mode activated!');
                utterance.rate = 0.8;
                utterance.pitch = 0.5;
                utterance.volume = 1.0;
                speechSynthesis.speak(utterance);
            }

            setTimeout(() => {
                // 3. Add all rainbow chaos effects
                document.body.classList.add('chaos-flip', 'chaos-rainbow', 'chaos-shake', 'chaos-glitch', 'chaos-invert', 'chaos-chromatic');
                document.body.style.background = 'linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)';
            }, 300);

            setTimeout(() => {
                // 4. More chaos effects - add wobble and morph
                document.body.classList.add('chaos-zoom', 'chaos-bounce', 'chaos-skew', 'chaos-blur', 'chaos-wobble', 'chaos-morph');
            }, 800);

            setTimeout(() => {
                // 5. Add additional chaos - swirl and crumble
                document.body.classList.add('chaos-swirl', 'chaos-crumble', 'chaos-melt');
            }, 1400);

            setTimeout(() => {
                // 6. Intensify by adding pixelate
                document.body.classList.add('chaos-pixelate');
            }, 1800);

            setTimeout(() => {
                // 7. Start shrinking the screen with more effects
                document.body.style.transform = 'scale(0.8) rotate(-5deg)';
                document.body.style.transition = 'transform 2s ease-in';
                document.body.style.filter = 'saturate(2) contrast(1.5)';
            }, 2200);

            setTimeout(() => {
                document.body.style.transform = 'scale(0.5) rotate(-10deg)';
                document.body.style.filter = 'saturate(0.5) hue-rotate(180deg)';
            }, 3000);

            setTimeout(() => {
                document.body.style.transform = 'scale(0.2) rotate(-20deg)';
                document.body.style.filter = 'saturate(2) brightness(0.5) contrast(3)';
            }, 3800);

            setTimeout(() => {
                // 8. Finally exit and clean up
                document.body.classList.remove('chaos-spin', 'chaos-flip', 'chaos-rainbow', 'chaos-shake', 'chaos-glitch', 'chaos-zoom', 'chaos-bounce', 'chaos-skew', 'chaos-blur', 'chaos-pixelate', 'chaos-strobe', 'chaos-pulse', 'chaos-invert', 'chaos-chromatic', 'chaos-wobble', 'chaos-morph', 'chaos-swirl', 'chaos-crumble', 'chaos-melt');
                document.body.style.background = '';
                document.body.style.transform = '';
                document.body.style.transition = '';
                document.body.style.filter = '';

                literallygameView.classList.remove('active');
                startScreen.style.display = 'flex';
            }, 5500);
        }

        // ========== NEW GAMES LOGIC ==========

        // Color Match Game
        function initColorMatch() {
            let score = 0;
            let timeLeft = 30;
            let currentColor;
            const colorScore = document.getElementById('colorScore');
            const colorTimer = document.getElementById('colorTimer');
            const colorTarget = document.getElementById('colorTarget');
            const colorOptions = document.getElementById('colorOptions');

            function generateColor() {
                return `rgb(${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)})`;
            }

            function newRound() {
                currentColor = generateColor();
                colorTarget.style.background = currentColor;
                colorOptions.innerHTML = '';

                const colors = [currentColor];
                for (let i = 0; i < 8; i++) colors.push(generateColor());
                colors.sort(() => Math.random() - 0.5);

                colors.forEach(color => {
                    const btn = document.createElement('div');
                    btn.style.cssText = `background:${color};height:80px;border-radius:8px;cursor:pointer;border:2px solid transparent`;
                    btn.onclick = () => {
                        if (color === currentColor) {
                            score++;
                            colorScore.textContent = score;
                            newRound();
                        }
                    };
                    colorOptions.appendChild(btn);
                });
            }

            const timer = setInterval(() => {
                timeLeft--;
                colorTimer.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    alert(`Game Over! Score: ${score}`);
                }
            }, 1000);

            newRound();
        }

        // Memory Master Game
        function initMemoryGame() {
            let level = 1;
            let sequence = [];
            let playerSequence = [];
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
            const memoryLevel = document.getElementById('memoryLevel');
            const memoryStatus = document.getElementById('memoryStatus');
            const memoryGrid = document.getElementById('memoryGrid');

            memoryGrid.innerHTML = '';
            colors.forEach((color, i) => {
                const btn = document.createElement('div');
                btn.style.cssText = `background:${color};height:200px;border-radius:15px;cursor:pointer;opacity:0.6;transition:opacity 0.2s`;
                btn.onmousedown = () => { btn.style.opacity = '1'; playSequence(i); };
                btn.onmouseup = () => { btn.style.opacity = '0.6'; };
                memoryGrid.appendChild(btn);
            });

            function playSequence(index) {
                playerSequence.push(index);
                if (playerSequence.length === sequence.length) {
                    if (JSON.stringify(playerSequence) === JSON.stringify(sequence)) {
                        level++;
                        memoryLevel.textContent = level;
                        setTimeout(startRound, 1000);
                    } else {
                        memoryStatus.textContent = 'Wrong! Starting over...';
                        level = 1;
                        setTimeout(startRound, 2000);
                    }
                }
            }

            function startRound() {
                playerSequence = [];
                sequence.push(Math.floor(Math.random() * 4));
                memoryStatus.textContent = 'Watch...';
                let i = 0;
                const interval = setInterval(() => {
                    if (i >= sequence.length) {
                        clearInterval(interval);
                        memoryStatus.textContent = 'Your turn!';
                        return;
                    }
                    const btn = memoryGrid.children[sequence[i]];
                    btn.style.opacity = '1';
                    setTimeout(() => btn.style.opacity = '0.6', 400);
                    i++;
                }, 600);
            }

            startRound();
        }

        // Type Racer Game
        function initTypingGame() {
            const texts = [
                'The quick brown fox jumps over the lazy dog.',
                'Pack my box with five dozen liquor jugs.',
                'How vexingly quick daft zebras jump!',
                'The five boxing wizards jump quickly.'
            ];
            const typingText = document.getElementById('typingText');
            const typingInput = document.getElementById('typingInput');
            const typingWPM = document.getElementById('typingWPM');
            const typingAccuracy = document.getElementById('typingAccuracy');

            let currentText = texts[Math.floor(Math.random() * texts.length)];
            let startTime;

            typingText.textContent = currentText;
            typingInput.value = '';
            typingInput.focus();

            typingInput.oninput = () => {
                if (!startTime) startTime = Date.now();
                const typed = typingInput.value;
                const elapsed = (Date.now() - startTime) / 60000;
                const words = typed.split(' ').length;
                typingWPM.textContent = Math.round(words / elapsed) || 0;

                let correct = 0;
                for (let i = 0; i < typed.length; i++) {
                    if (typed[i] === currentText[i]) correct++;
                }
                typingAccuracy.textContent = Math.round(correct / typed.length * 100) || 100;

                if (typed === currentText) {
                    setTimeout(() => {
                        alert(`Complete! WPM: ${typingWPM.textContent}`);
                        initTypingGame();
                    }, 100);
                }
            };
        }

        // Reaction Time Game
        function initReactionGame() {
            const reactionBox = document.getElementById('reactionBox');
            const reactionBest = document.getElementById('reactionBest');
            const reactionAvg = document.getElementById('reactionAvg');
            let times = [];
            let waiting = false;
            let startTime;

            reactionBox.onclick = () => {
                if (reactionBox.style.background === 'green') {
                    const reactionTime = Date.now() - startTime;
                    times.push(reactionTime);
                    reactionBox.textContent = `${reactionTime}ms! Click to try again`;
                    reactionBox.style.background = '';

                    const best = Math.min(...times);
                    const avg = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
                    reactionBest.textContent = best;
                    reactionAvg.textContent = avg;
                    waiting = false;
                } else if (!waiting) {
                    waiting = true;
                    reactionBox.textContent = 'Wait...';
                    setTimeout(() => {
                        reactionBox.style.background = 'green';
                        reactionBox.textContent = 'CLICK NOW!';
                        startTime = Date.now();
                    }, Math.random() * 3000 + 1000);
                }
            };
        }

        // Maze Runner Game (Simple version)
        function initMazeGame() {
            const mazeCanvas = document.getElementById('mazeCanvas');
            const ctx = mazeCanvas?.getContext('2d');
            if (!ctx) return;

            let level = 1;
            let playerX = 1, playerY = 1;
            const cellSize = 50;

            function generateMaze() {
                const size = Math.min(5 + level, 10);
                const maze = Array(size).fill().map(() => Array(size).fill(1));

                function carve(x, y) {
                    maze[y][x] = 0;
                    const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]].sort(() => Math.random() - 0.5);
                    for (const [dx, dy] of dirs) {
                        const nx = x + dx * 2, ny = y + dy * 2;
                        if (nx > 0 && ny > 0 && nx < size && ny < size && maze[ny][nx] === 1) {
                            maze[y + dy][x + dx] = 0;
                            carve(nx, ny);
                        }
                    }
                }
                carve(1, 1);
                maze[size - 2][size - 2] = 2;
                return maze;
            }

            let maze = generateMaze();
            playerX = 1; playerY = 1;

            function draw() {
                ctx.clearRect(0, 0, 500, 500);
                maze.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        ctx.fillStyle = cell === 1 ? '#333' : cell === 2 ? 'gold' : '#fff';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    });
                });
                ctx.fillStyle = 'blue';
                ctx.fillRect(playerX * cellSize + 10, playerY * cellSize + 10, cellSize - 20, cellSize - 20);
            }

            document.addEventListener('keydown', (e) => {
                if (!mazeView.classList.contains('active')) return;
                let nx = playerX, ny = playerY;
                if (e.key === 'ArrowUp') { ny--; e.preventDefault(); }
                if (e.key === 'ArrowDown') { ny++; e.preventDefault(); }
                if (e.key === 'ArrowLeft') { nx--; e.preventDefault(); }
                if (e.key === 'ArrowRight') { nx++; e.preventDefault(); }

                if (maze[ny]?.[nx] !== 1) {
                    playerX = nx; playerY = ny;
                    if (maze[ny][nx] === 2) {
                        level++;
                        document.getElementById('mazeLevel').textContent = level;
                        maze = generateMaze();
                        playerX = 1; playerY = 1;
                    }
                    draw();
                }
            });
            draw();
        }

        // Flappy Clone Game
        function initFlappyGame() {
            const canvas = document.getElementById('flappyCanvas');
            const ctx = canvas?.getContext('2d');
            if (!ctx) return;

            let bird = { y: 300, velocity: 0 };
            let pipes = [];
            let score = 0;
            let best = 0;
            let gameLoop;

            function reset() {
                bird = { y: 300, velocity: 0 };
                pipes = [{ x: 600, gap: 150, gapY: Math.random() * 200 + 100 }];
                score = 0;
                document.getElementById('flappyScore').textContent = score;
            }

            canvas.onclick = () => bird.velocity = -8;
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ' && flappycloneView.classList.contains('active')) bird.velocity = -8;
            });

            function update() {
                bird.velocity += 0.5;
                bird.y += bird.velocity;

                pipes.forEach(pipe => {
                    pipe.x -= 3;
                    if (pipe.x === 50) score++;
                });
                pipes = pipes.filter(p => p.x > -60);
                if (pipes.length === 0 || pipes[pipes.length - 1].x < 200) {
                    pipes.push({ x: 600, gap: 150, gapY: Math.random() * 200 + 100 });
                }

                // Collision
                if (bird.y < 0 || bird.y > 600 || pipes.some(p => p.x < 80 && p.x > 0 && (bird.y < p.gapY || bird.y > p.gapY + p.gap))) {
                    if (score > best) { best = score; document.getElementById('flappyBest').textContent = best; }
                    reset();
                }

                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, 400, 600);
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(50, bird.y, 20, 0, Math.PI * 2);
                ctx.fill();
                pipes.forEach(p => {
                    ctx.fillStyle = 'green';
                    ctx.fillRect(p.x, 0, 60, p.gapY);
                    ctx.fillRect(p.x, p.gapY + p.gap, 60, 600);
                });
                document.getElementById('flappyScore').textContent = score;
            }

            reset();
            gameLoop = setInterval(update, 1000 / 60);
        }

        // Tic Tac Toe Game
        function initTicTacToe() {
            const board = Array(9).fill('');
            const tttBoard = document.getElementById('tttBoard');
            const tttStatus = document.getElementById('tttStatus');
            let currentPlayer = 'X';

            function checkWin() {
                const wins = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];
                for (const [a, b, c] of wins) {
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) return board[a];
                }
                return board.every(cell => cell) ? 'tie' : null;
            }

            function aiMove() {
                const empty = board.map((v, i) => v === '' ? i : -1).filter(i => i >= 0);
                if (empty.length) {
                    setTimeout(() => {
                        const move = empty[Math.floor(Math.random() * empty.length)];
                        board[move] = 'O';
                        render();
                        const winner = checkWin();
                        if (winner) tttStatus.textContent = winner === 'tie' ? 'Tie!' : 'O Wins!';
                        else { currentPlayer = 'X'; tttStatus.textContent = 'Your turn (X)'; }
                    }, 500);
                }
            }

            function render() {
                tttBoard.innerHTML = '';
                board.forEach((cell, i) => {
                    const btn = document.createElement('div');
                    btn.style.cssText = 'height:100px;background:var(--btn);border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:48px;cursor:pointer;color:var(--accent)';
                    btn.textContent = cell;
                    btn.onclick = () => {
                        if (!cell && currentPlayer === 'X' && !checkWin()) {
                            board[i] = 'X';
                            render();
                            const winner = checkWin();
                            if (winner) tttStatus.textContent = winner === 'tie' ? 'Tie!' : 'X Wins!';
                            else { currentPlayer = 'O'; tttStatus.textContent = 'AI thinking...'; aiMove(); }
                        }
                    };
                    tttBoard.appendChild(btn);
                });
            }

            document.getElementById('tttReset').onclick = initTicTacToe;
            render();
        }

        // Snake Classic Game
        function initSnakeGame() {
            const canvas = document.getElementById('snakeCanvas');
            const ctx = canvas?.getContext('2d');
            if (!ctx) return;

            let snake = [{ x: 10, y: 10 }];
            let food = { x: 15, y: 15 };
            let dx = 0, dy = 0;
            let score = 0;
            let best = parseInt(localStorage.getItem('snakeBest')) || 0;
            let gameLoop;
            let started = false;

            document.getElementById('snakeBest').textContent = best;

            document.addEventListener('keydown', (e) => {
                if (!snakeView.classList.contains('active')) return;
                if (e.key === ' ') { started = true; if (!gameLoop) gameLoop = setInterval(update, 100); return; }
                if (e.key === 'ArrowUp' && dy === 0) { dx = 0; dy = -1; e.preventDefault(); }
                if (e.key === 'ArrowDown' && dy === 0) { dx = 0; dy = 1; e.preventDefault(); }
                if (e.key === 'ArrowLeft' && dx === 0) { dx = -1; dy = 0; e.preventDefault(); }
                if (e.key === 'ArrowRight' && dx === 0) { dx = 1; dy = 0; e.preventDefault(); }
            });

            function update() {
                if (!started) return;
                const head = { x: snake[0].x + dx, y: snake[0].y + dy };

                if (head.x < 0 || head.x >= 25 || head.y < 0 || head.y >= 25 || snake.some(s => s.x === head.x && s.y === head.y)) {
                    if (score > best) { best = score; localStorage.setItem('snakeBest', best); document.getElementById('snakeBest').textContent = best; }
                    snake = [{ x: 10, y: 10 }]; dx = 0; dy = 0; score = 0; started = false; food = { x: 15, y: 15 };
                }

                snake.unshift(head);
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    food = { x: Math.floor(Math.random() * 25), y: Math.floor(Math.random() * 25) };
                } else snake.pop();

                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, 500, 500);
                ctx.fillStyle = 'lime';
                snake.forEach(s => ctx.fillRect(s.x * 20, s.y * 20, 18, 18));
                ctx.fillStyle = 'red';
                ctx.fillRect(food.x * 20, food.y * 20, 18, 18);
                document.getElementById('snakeScore').textContent = score;
            }
        }

        // Hangman Game
        function initHangman() {
            const words = ['JAVASCRIPT', 'PROGRAMMING', 'DEVELOPER', 'HANGMAN', 'COMPUTER', 'INTERNET'];
            let word = words[Math.floor(Math.random() * words.length)];
            let guessed = new Set();
            let guesses = 6;
            const hangmanWord = document.getElementById('hangmanWord');
            const hangmanLetters = document.getElementById('hangmanLetters');
            const hangmanGuesses = document.getElementById('hangmanGuesses');
            const hangmanStatus = document.getElementById('hangmanStatus');

            hangmanLetters.innerHTML = '';
            'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').forEach(letter => {
                const btn = document.createElement('button');
                btn.textContent = letter;
                btn.style.cssText = 'padding:8px;background:var(--btn);color:var(--ink);border:1px solid var(--accent);border-radius:4px;cursor:pointer';
                btn.onclick = () => {
                    if (guessed.has(letter)) return;
                    guessed.add(letter);
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    if (!word.includes(letter)) guesses--;
                    hangmanGuesses.textContent = guesses;
                    render();
                };
                hangmanLetters.appendChild(btn);
            });

            function render() {
                const display = word.split('').map(l => guessed.has(l) ? l : '_').join(' ');
                hangmanWord.textContent = display;
                if (guesses <= 0) { hangmanStatus.textContent = 'Game Over! Word: ' + word; }
                else if (word.split('').every(l => guessed.has(l))) { hangmanStatus.textContent = 'You Won!'; }
            }
            render();
        }

        // 2048 Game
        function init2048() {
            let grid = Array(16).fill(0);
            let score = 0;
            const board = document.getElementById('game2048Board');

            function addTile() {
                const empty = grid.map((v, i) => v === 0 ? i : -1).filter(i => i >= 0);
                if (empty.length) grid[empty[Math.floor(Math.random() * empty.length)]] = Math.random() > 0.9 ? 4 : 2;
            }

            function render() {
                board.innerHTML = '';
                grid.forEach(val => {
                    const tile = document.createElement('div');
                    tile.textContent = val || '';
                    tile.style.cssText = `width:100%;height:80px;background:${val === 0 ? '#cdc1b4' : '#eee4da'};display:flex;align-items:center;justify-content:center;font-size:32px;font-weight:bold;border-radius:4px`;
                    board.appendChild(tile);
                });
                document.getElementById('score2048').textContent = score;
            }

            addTile();
            addTile();
            render();
        }

        // Breakout Game
        function initBreakout() {
            const canvas = document.getElementById('breakoutCanvas');
            const ctx = canvas?.getContext('2d');
            if (!ctx) return;

            let ball = { x: 250, y: 380, vx: 3, vy: -3, r: 8 };
            let paddle = { x: 200, y: 390, w: 100, h: 10 };
            let bricks = [];
            let score = 0;

            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 5; j++) {
                    bricks.push({ x: 100 + j * 80, y: 50 + i * 30, w: 70, h: 20 });
                }
            }

            document.addEventListener('keydown', (e) => {
                if (!breakoutView.classList.contains('active')) return;
                if (e.key === 'ArrowLeft' && paddle.x > 0) { paddle.x -= 20; e.preventDefault(); }
                if (e.key === 'ArrowRight' && paddle.x < 400) { paddle.x += 20; e.preventDefault(); }
            });

            function update() {
                ball.x += ball.vx;
                ball.y += ball.vy;
                if (ball.x - ball.r < 0 || ball.x + ball.r > 500) ball.vx *= -1;
                if (ball.y - ball.r < 0) ball.vy *= -1;
                if (ball.y > 400) { document.getElementById('breakoutScore').textContent = score; return; }

                if (ball.x > paddle.x && ball.x < paddle.x + paddle.w && ball.y > paddle.y) ball.vy *= -1;

                bricks = bricks.filter(b => {
                    if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                        ball.vy *= -1;
                        score++;
                        return false;
                    }
                    return true;
                });

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 400);
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
                bricks.forEach(b => { ctx.fillRect(b.x, b.y, b.w, b.h); });

                document.getElementById('breakoutScore').textContent = score;
                if (bricks.length === 0) {
                    alert('You Won!');
                    return;
                }
                if (ball.y > 400) return;
                requestAnimationFrame(update);
            }
            update();
        }

        // Pong Game
        function initPong() {
            const canvas = document.getElementById('pongCanvas');
            const ctx = canvas?.getContext('2d');
            if (!ctx) return;

            let ball = { x: 250, y: 200, vx: 3, vy: 3, r: 6 };
            let p1 = { y: 150, h: 80 };
            let p2 = { y: 150, h: 80 };
            let score1 = 0, score2 = 0;

            document.addEventListener('keydown', (e) => {
                if (!pongView.classList.contains('active')) return;
                if ((e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') && p1.y > 0) { p1.y -= 15; e.preventDefault(); }
                if ((e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') && p1.y < 320) { p1.y += 15; e.preventDefault(); }
            });

            function update() {
                ball.x += ball.vx;
                ball.y += ball.vy;
                if (ball.y < 0 || ball.y > 400) ball.vy *= -1;
                p2.y = Math.max(0, Math.min(320, ball.y - 40));

                if (ball.x < 10 && ball.y > p1.y && ball.y < p1.y + 80) ball.vx *= -1;
                if (ball.x > 490 && ball.y > p2.y && ball.y < p2.y + 80) ball.vx *= -1;

                if (ball.x < 0) { score2++; ball = { x: 250, y: 200, vx: 3, vy: 3, r: 6 }; }
                if (ball.x > 500) { score1++; ball = { x: 250, y: 200, vx: 3, vy: 3, r: 6 }; }

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 400);
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, p1.y, 8, 80);
                ctx.fillRect(487, p2.y, 8, 80);
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fill();

                document.getElementById('pongScore1').textContent = score1;
                document.getElementById('pongScore2').textContent = score2;
                requestAnimationFrame(update);
            }
            update();
        }

        // Sudoku Game
        function initSudoku() {
            const board = document.getElementById('sudokuBoard');
            let sudokuGrid = Array(81).fill(0);
            sudokuGrid[0] = 5; sudokuGrid[5] = 7; sudokuGrid[10] = 4; sudokuGrid[15] = 8;

            board.innerHTML = '';
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('input');
                cell.type = 'number';
                cell.min = '1';
                cell.max = '9';
                cell.value = sudokuGrid[i] || '';
                cell.style.cssText = 'width:40px;height:40px;text-align:center;border:1px solid #666;background:var(--btn);color:var(--ink)';
                board.appendChild(cell);
            }

            document.getElementById('sudokuReset').onclick = initSudoku;
        }

        // Whack-a-Mole Game
        function initWhackaMole() {
            let score = 0;
            let time = 30;
            const moleBoard = document.getElementById('moleBoard');
            const moleScore = document.getElementById('moleScore');
            const moleTimer = document.getElementById('moleTimer');

            moleBoard.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const hole = document.createElement('div');
                hole.style.cssText = 'width:80px;height:80px;background:#8B4513;border-radius:50%;cursor:pointer;position:relative';
                hole.onclick = () => {
                    if (hole.querySelector('div')) {
                        score++;
                        moleScore.textContent = score;
                        hole.innerHTML = '';
                    }
                };
                moleBoard.appendChild(hole);
            }

            function spawnMole() {
                if (time <= 0) return;
                const holes = document.querySelectorAll('#moleBoard > div');
                const hole = holes[Math.floor(Math.random() * holes.length)];
                const mole = document.createElement('div');
                mole.style.cssText = 'width:60px;height:60px;background:#333;border-radius:50%;position:absolute;top:10px;left:10px';
                hole.appendChild(mole);
                setTimeout(() => hole.innerHTML = '', 500);
            }

            const moleInterval = setInterval(spawnMole, 800);
            const timer = setInterval(() => {
                time--;
                moleTimer.textContent = time;
                if (time <= 0) {
                    clearInterval(moleInterval);
                    clearInterval(timer);
                    alert(`Final Score: ${score}`);
                }
            }, 1000);
        }

        // Trivia Game
        function initTrivia() {
            const triviaData = [
                { q: 'What is 2+2?', o: ['3', '4', '5', '6'], a: 1 },
                { q: 'What is the capital of France?', o: ['London', 'Berlin', 'Paris', 'Madrid'], a: 2 },
                { q: 'Which planet is closest to the sun?', o: ['Venus', 'Mercury', 'Earth', 'Mars'], a: 1 },
                { q: 'What is the largest ocean?', o: ['Atlantic', 'Arctic', 'Indian', 'Pacific'], a: 3 },
                { q: 'Who invented the telephone?', o: ['Tesla', 'Edison', 'Bell', 'Volta'], a: 2 }
            ];

            let current = 0;
            let score = 0;
            const questionEl = document.getElementById('triviaQuestion');
            const optionsEl = document.getElementById('triviaOptions');
            const scoreEl = document.getElementById('triviaScore');

            function showQuestion() {
                if (current >= triviaData.length) {
                    alert(`Quiz Complete! Score: ${score}/${triviaData.length}`);
                    return;
                }
                const q = triviaData[current];
                questionEl.textContent = q.q;
                optionsEl.innerHTML = '';
                q.o.forEach((opt, i) => {
                    const btn = document.createElement('button');
                    btn.textContent = opt;
                    btn.style.cssText = 'padding:12px;background:var(--btn);color:var(--ink);border:1px solid var(--accent);border-radius:6px;cursor:pointer';
                    btn.onclick = () => {
                        if (i === q.a) score++;
                        scoreEl.textContent = score;
                        current++;
                        showQuestion();
                    };
                    optionsEl.appendChild(btn);
                });
            }
            showQuestion();
        }

        // Asteroid Blaster Game
        function initAsteroid() {
            const canvas = document.getElementById('asteroidCanvas');
            const ctx = canvas?.getContext('2d');
            if (!ctx) return;

            let ship = { x: 250, y: 450, angle: 0, r: 15 };
            let bullets = [];
            let asteroids = [];
            let score = 0;
            let lives = 3;
            let gameRunning = true;
            let boss = null;
            let weaponMode = 'normal'; // 'normal', 'spread', 'laser', 'supernova'
            let spreadRays = 5; // Number of rays for spreadshot (2-20)
            let laserWidth = 50; // Laser width in pixels (1-200)
            let weaponCooldown = 0;
            let laserActive = false;
            let laserDuration = 3;
            let supernovaActive = false;
            let supernovaDuration = 5;
            let supernovaRadius = 1000;

            // Damage scaling: 1 ray = 25 damage, scales down with more rays
            const calculateBulletDamage = (numRays) => {
                return Math.max(10, 25 / (numRays / 5)); // At 5 rays: 25 damage, scales down proportionally
            };

            // Laser damage scaling: narrow = high damage, wide = low damage
            const calculateLaserDamage = (width) => {
                return Math.max(100, 10000 / width); // At 1px: 10000 damage, at 200px: ~50 damage
            };

            function createAsteroid(x, y, size = 30) {
                asteroids.push({ x, y, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3 - 1, r: size, health: size * 8, maxHealth: size * 8 });
            }

            for (let i = 0; i < 3; i++) {
                createAsteroid(Math.random() * 500, Math.random() * 200, 30);
            }

            document.addEventListener('keydown', (e) => {
                if (!asteroidView.classList.contains('active')) return;
                if (e.key === 'ArrowLeft') { ship.angle -= 0.15; e.preventDefault(); }
                if (e.key === 'ArrowRight') { ship.angle += 0.15; e.preventDefault(); }
                if (e.key === ' ') {
                    if (weaponCooldown <= 0) {
                        if (weaponMode === 'spread') {
                            // Spreadshot: N bullets in cone (N = spreadRays)
                            const bulletDamage = calculateBulletDamage(spreadRays);
                            const angleSpacing = (spreadRays > 1) ? (1.2 / (spreadRays - 1)) : 0;
                            for (let i = 0; i < spreadRays; i++) {
                                const offsetAngle = (spreadRays > 1) ? (i - (spreadRays - 1) / 2) * angleSpacing : 0;
                                const spreadAngle = ship.angle + offsetAngle;
                                bullets.push({
                                    x: ship.x + Math.cos(ship.angle) * ship.r,
                                    y: ship.y + Math.sin(ship.angle) * ship.r,
                                    vx: Math.cos(spreadAngle) * 5,
                                    vy: Math.sin(spreadAngle) * 5,
                                    damage: bulletDamage
                                });
                            }
                            weaponCooldown = 8;
                        } else if (weaponMode === 'laser') {
                            // Laser: activate laser beam (full screen)
                            laserActive = true;
                            laserDuration = 60;
                            weaponCooldown = 100;
                        } else if (weaponMode === 'supernova') {
                            // Supernova: massive explosion destroying everything
                            supernovaActive = true;
                            supernovaDuration = 30;
                            supernovaRadius = 500;
                            weaponCooldown = 200;
                        } else {
                            // Normal: single bullet (25 damage)
                            bullets.push({
                                x: ship.x + Math.cos(ship.angle) * ship.r,
                                y: ship.y + Math.sin(ship.angle) * ship.r,
                                vx: Math.cos(ship.angle) * 5,
                                vy: Math.sin(ship.angle) * 5,
                                damage: Math.random() * 200
                            });
                            weaponCooldown = 4;
                        }
                    }
                    e.preventDefault();
                }
                if (e.key === '1') weaponMode = 'normal';
                if (e.key === '2') weaponMode = 'spread';
                if (e.key === '3') weaponMode = 'laser';
                if (e.key === '4') weaponMode = 'supernova';
            });

            // Weapon button handlers
            const updateWeaponDisplay = () => {
                document.getElementById('currentWeapon').textContent = weaponMode.toUpperCase();
                document.getElementById('weaponNormal').style.opacity = weaponMode === 'normal' ? '1' : '0.5';
                document.getElementById('weaponSpread').style.opacity = weaponMode === 'spread' ? '1' : '0.5';
                document.getElementById('weaponLaser').style.opacity = weaponMode === 'laser' ? '1' : '0.5';
                document.getElementById('weaponSupernova').style.opacity = weaponMode === 'supernova' ? '1' : '0.5';
                // Show rays control only when spreadshot is selected
                document.getElementById('spreadsheetRaysControl').style.display = weaponMode === 'spread' ? 'block' : 'none';
                // Show laser width control only when laser is selected
                document.getElementById('laserWidthControl').style.display = weaponMode === 'laser' ? 'block' : 'none';
            };

            document.getElementById('weaponNormal').addEventListener('click', () => {
                weaponMode = 'normal';
                updateWeaponDisplay();
            });
            document.getElementById('weaponSpread').addEventListener('click', () => {
                weaponMode = 'spread';
                updateWeaponDisplay();
            });
            document.getElementById('weaponLaser').addEventListener('click', () => {
                weaponMode = 'laser';
                updateWeaponDisplay();
            });
            document.getElementById('weaponSupernova').addEventListener('click', () => {
                weaponMode = 'supernova';
                updateWeaponDisplay();
            });
            document.getElementById('weaponLaser').addEventListener('click', () => {
                weaponMode = 'laser';
                updateWeaponDisplay();
            });

            // Spreadshot rays slider
            document.getElementById('raysSlider').addEventListener('input', (e) => {
                spreadRays = parseInt(e.target.value);
                document.getElementById('raysValue').textContent = spreadRays;
            });

            // Laser width slider
            document.getElementById('laserWidthSlider').addEventListener('input', (e) => {
                laserWidth = parseInt(e.target.value);
                document.getElementById('laserWidthValue').textContent = laserWidth;
            });

            updateWeaponDisplay();

            function update() {
                if (!gameRunning) return;

                weaponCooldown--;
                if (laserActive) laserDuration--;

                // Check if boss should spawn
                if (score >= 400 && !boss) {
                    boss = { x: 250, y: 100, hp: 2000, maxHp: 2000, width: 60, height: 50, attackCooldown: 5, attackType: 0 };
                }

                // Update bullets
                bullets = bullets.filter(b => {
                    b.x += b.vx;
                    b.y += b.vy;
                    return b.x > 0 && b.x < 500 && b.y > 0 && b.y < 500;
                });

                // Update asteroids
                asteroids.forEach(a => {
                    a.x += a.vx;
                    a.y += a.vy;
                    if (a.x < 0) a.x = 500;
                    if (a.x > 500) a.x = 0;
                    if (a.y < 0) a.y = 500;
                    if (a.y > 500) a.y = 0;
                });

                // Update boss position and attacks
                if (boss) {
                    boss.x += Math.sin(Date.now() * 0.001) * 2;
                    if (boss.x < 30) boss.x = 30;
                    if (boss.x > 470) boss.x = 470;

                    boss.attackCooldown--;
                    if (boss.attackCooldown <= 0) {
                        const attackNames = Object.keys(bossAttacks);
                        const attack = bossAttacks[attackNames[Math.floor(Math.random() * attackNames.length)]];
                        attack(boss);
                        boss.attackCooldown = 60 + Math.random() * 40;
                    }
                }

                // Check laser damage (extends full screen)
                if (laserActive && laserDuration > 0) {
                    // Laser extends from ship position to edge of screen (500+ distance)
                    const laserEnd = { x: ship.x + Math.cos(ship.angle) * 1000, y: ship.y + Math.sin(ship.angle) * 1000 };
                    const laserDamage = calculateLaserDamage(laserWidth);

                    // Damage asteroids with laser (damage scales with width)
                    for (let i = asteroids.length - 1; i >= 0; i--) {
                        const a = asteroids[i];
                        const dist = distanceToLine(a.x, a.y, ship.x, ship.y, laserEnd.x, laserEnd.y);
                        if (dist < Math.max(a.r, laserWidth / 2 + 5)) {
                            a.health -= laserDamage; // Laser damage scales with width setting
                            if (a.health <= 0) {
                                score += a.r;
                                const orig = asteroids[i];
                                if (orig.r > 15) {
                                    createAsteroid(orig.x, orig.y, orig.r - 10);
                                    createAsteroid(orig.x, orig.y, orig.r - 10);
                                }
                                asteroids.splice(i, 1);
                            }
                        }
                    }

                    // Damage boss with laser
                    if (boss) {
                        const bDist = distanceToLine(boss.x, boss.y, ship.x, ship.y, laserEnd.x, laserEnd.y);
                        if (bDist < Math.max(boss.width / 2, laserWidth / 2) + 5) {
                            boss.hp -= laserDamage / 50; // Scale boss damage similarly
                            if (boss.hp <= 0) {
                                score += 200;
                                boss = null;
                            }
                        }
                    }
                }

                // Supernova explosion (destroys everything in radius)
                if (supernovaActive && supernovaDuration > 0) {
                    supernovaRadius = (30 - supernovaDuration) * 15; // Expands from 0 to 450 pixels

                    // Destroy all asteroids in radius
                    for (let i = asteroids.length - 1; i >= 0; i--) {
                        const a = asteroids[i];
                        const dx = a.x - ship.x;
                        const dy = a.y - ship.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < supernovaRadius + a.r) {
                            score += a.r * 2; // Double score for supernova kills
                            asteroids.splice(i, 1);
                        }
                    }

                    // Destroy boss if in radius
                    if (boss) {
                        const dx = boss.x - ship.x;
                        const dy = boss.y - ship.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < supernovaRadius + boss.width / 2) {
                            score += 500; // Bonus for destroying boss with supernova
                            boss = null;
                        }
                    }

                    supernovaDuration--;
                }

                // Check collisions - bullets with asteroids
                for (let i = bullets.length - 1; i >= 0; i--) {
                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const dx = bullets[i].x - asteroids[j].x;
                        const dy = bullets[i].y - asteroids[j].y;
                        if (Math.sqrt(dx * dx + dy * dy) < asteroids[j].r + 2) {
                            const bulletDamage = bullets[i].damage || 25;
                            asteroids[j].health -= bulletDamage;
                            bullets.splice(i, 1);

                            if (asteroids[j].health <= 0) {
                                score += asteroids[j].r;
                                const a = asteroids[j];
                                if (a.r > 15) {
                                    createAsteroid(a.x, a.y, a.r - 10);
                                    createAsteroid(a.x, a.y, a.r - 10);
                                }
                                asteroids.splice(j, 1);
                            }
                            break;
                        }
                    }
                }

                // Check collisions - bullets with boss
                if (boss) {
                    for (let i = bullets.length - 1; i >= 0; i--) {
                        if (Math.abs(bullets[i].x - boss.x) < boss.width / 2 && Math.abs(bullets[i].y - boss.y) < boss.height / 2) {
                            boss.hp -= 1;
                            bullets.splice(i, 1);
                            if (boss.hp <= 0) {
                                score += 200;
                                boss = null;
                            }
                        }
                    }
                }

                // Check ship collision with asteroids
                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const a = asteroids[i];
                    const dx = ship.x - a.x;
                    const dy = ship.y - a.y;
                    if (Math.sqrt(dx * dx + dy * dy) < ship.r + a.r) {
                        if (a.isEnemyProjectile) {
                            lives--;
                            asteroids.splice(i, 1);
                            document.getElementById('asteroidLives').textContent = lives;
                            if (lives <= 0) {
                                gameRunning = false;
                                alert(`Game Over! Score: ${score}`);
                                return;
                            }
                            ship.x = 250;
                            ship.y = 450;
                        } else {
                            lives--;
                            document.getElementById('asteroidLives').textContent = lives;
                            if (lives <= 0) {
                                gameRunning = false;
                                alert(`Game Over! Score: ${score}`);
                                return;
                            }
                            ship.x = 250;
                            ship.y = 450;
                            asteroids = [];
                            for (let i = 0; i < 3; i++) {
                                createAsteroid(Math.random() * 500, Math.random() * 200, 30);
                            }
                        }
                        break;
                    }
                }

                // Check ship collision with boss
                if (boss && Math.abs(ship.x - boss.x) < ship.r + boss.width / 2 && Math.abs(ship.y - boss.y) < ship.r + boss.height / 2) {
                    lives--;
                    document.getElementById('asteroidLives').textContent = lives;
                    if (lives <= 0) {
                        gameRunning = false;
                        alert(`Game Over! Score: ${score}`);
                        return;
                    }
                    ship.x = 250;
                    ship.y = 450;
                }

                if (asteroids.length === 0 && !boss) {
                    for (let i = 0; i < 3; i++) {
                        createAsteroid(Math.random() * 500, Math.random() * 200, 30);
                    }
                }

                // Draw
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                // Draw supernova explosion
                if (supernovaActive && supernovaDuration > 0) {
                    // Expanding circle with yellow-orange gradient
                    ctx.fillStyle = `rgba(255, 200, 0, ${supernovaDuration / 30 * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(ship.x, ship.y, supernovaRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Outer edge glow
                    ctx.strokeStyle = `rgba(255, 100, 0, ${supernovaDuration / 30})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(ship.x, ship.y, supernovaRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw laser (extends full screen)
                if (laserActive && laserDuration > 0) {
                    ctx.strokeStyle = `rgba(255, 0, 0, ${laserDuration / 60})`;
                    ctx.lineWidth = laserWidth; // Use laser width setting
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(ship.x, ship.y);
                    ctx.lineTo(ship.x + Math.cos(ship.angle) * 1000, ship.y + Math.sin(ship.angle) * 1000);
                    ctx.stroke();
                }

                // Draw ship
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, -10);
                ctx.lineTo(-5, 0);
                ctx.lineTo(-10, 10);
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                // Draw bullets
                ctx.fillStyle = '#ffff00';
                bullets.forEach(b => {
                    ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
                });

                // Draw asteroids
                asteroids.forEach(a => {
                    if (a.isEnemyProjectile) {
                        // Enemy projectiles are purple
                        ctx.fillStyle = '#ff00ff';
                        ctx.beginPath();
                        ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Regular asteroids
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });

                // Draw boss
                if (boss) {
                    // Pulsing boss effect
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                    ctx.fillRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);

                    // Boss border
                    ctx.strokeStyle = '#ff6666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);

                    // Health bar
                    ctx.fillStyle = '#333';
                    ctx.fillRect(boss.x - boss.width / 2, boss.y - boss.height / 2 - 10, boss.width, 4);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(boss.x - boss.width / 2, boss.y - boss.height / 2 - 10, boss.width * (boss.hp / boss.maxHp), 4);

                    // Boss label
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`BOSS HP: ${Math.ceil(boss.hp)}`, boss.x, boss.y);
                }

                document.getElementById('asteroidScore').textContent = score;
                requestAnimationFrame(update);
            }

            function distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            update();
        }

        // Settings button click handler
        settingsBtn?.addEventListener('click', () => {
            if (calculatorView && calculatorView.classList.contains('active')) {
                // In calculator view - use flip animation
                const flipContainer = calculatorView.querySelector('#flipContainer');
                if (flipContainer) {
                    setTimeout(() => flipContainer.classList.add('flipped'), 50);
                }
            } else {
                // In other views - open settings view with flip animation
                showView('settings');
                syncSettingsToGlobal();
                const flipContainerGlobal = document.getElementById('flipContainerGlobal');
                if (flipContainerGlobal) {
                    setTimeout(() => flipContainerGlobal.classList.add('flipped'), 50);
                }
            }
        });

        // Back to home from settings handler
        const backToHomeFromSettings = document.getElementById('backToHomeFromSettings');
        backToHomeFromSettings?.addEventListener('click', () => {
            const flipContainerGlobal = document.getElementById('flipContainerGlobal');
            if (flipContainerGlobal) {
                flipContainerGlobal.classList.remove('flipped');
            }
            setTimeout(() => {
                syncGlobalToSettings();
                showView('gameCenter');
            }, 600); // Wait for flip animation to complete
        });

        // ========== CALCULATOR ==========
        // --- Utility: superscript/subscript digits for pretty display ---
        const SUP = { "0": "", "1": "", "2": "", "3": "", "4": "", "5": "", "6": "", "7": "", "8": "", "9": "", "+": "", "-": "" };
        const SUB = { "0": "", "1": "", "2": "", "3": "", "4": "", "5": "", "6": "", "7": "", "8": "", "9": "", "+": "", "-": "" };
        function toSup(str) { return str.split('').map(ch => SUP[ch] || ch).join('') }
        function toSub(str) { return str.split('').map(ch => SUB[ch] || ch).join('') }

        function prettyExpr(src) {
            let s = src;
            // simple a_b -> ab for single token b (digits)
            s = s.replace(/([A-Za-ze])_(\d+)/g, (m, a, b) => a + toSub(b));
            // ^(digits) or ^digits -> superscripts
            s = s.replace(/\^(\d+)/g, (m, p) => toSup(p));
            // common constants
            s = s.replace(/PI|pi|/g, '');
            return s;
        }

        // --- Angle mode and math wrappers ---
        let angleMode = 'DEG';
        function toRad(x) { return angleMode === 'DEG' ? (x * Math.PI / 180) : x }
        // makeScope is defined later with extended functions and variables

        // --- Expression handling and evaluation ---
        const exprEl = calculatorView?.querySelector('#expr');
        const resEl = calculatorView?.querySelector('#res');
        const angleBtn = calculatorView?.querySelector('#angleBtn');
        let expression = '';
        let justEvaluated = false;

        function updateDisplay() { exprEl.textContent = prettyExpr(expression); }
        function setResult(v) { resEl.textContent = v; }

        function appendToken(token) {
            if (justEvaluated && /[0-9.(]/.test(token)) {
                expression = '';
            }
            justEvaluated = false;
            expression += token;
            updateDisplay();
        }

        function clearAll() { expression = ''; setResult('0'); updateDisplay(); }
        function deleteOne() { expression = expression.slice(0, -1); updateDisplay(); }
        function toggleSignSafe() {
            const re = /(.*?)([-+*/%]?)(\d*\.?\d+)$/;
            const m = expression.match(re);
            if (!m) return;
            const [, head, op, num] = m;
            let v = parseFloat(num);
            if (Number.isFinite(v)) {
                expression = `${head}${op}${-v}`;
                updateDisplay();
            }
        }

        function normalizeForEval(s, allowX = false) {
            let t = s;
            t = t.replace(//g, '*').replace(//g, '/');
            // percent -> /100
            t = t.replace(/(\d*\.?\d+)%/g, '($1/100)');
            // constants
            t = t.replace(/|\bpi\b/gi, 'PI');
            t = t.replace(/\be\b/g, 'E');
            // exponent
            t = t.replace(/\^/g, '**');
            return t;
        }

        // Memory & variables
        const userVars = Object.create(null);
        const memVars = Object.create(null); // A,B,C,...,M
        let lastStoredSym = null;
        let MVal = 0;

        function makeScope() {
            const sin = (x) => Math.sin(toRad(x));
            const cos = (x) => Math.cos(toRad(x));
            const tan = (x) => Math.tan(toRad(x));
            const csc = (x) => 1 / Math.sin(toRad(x));
            const cot = (x) => 1 / Math.tan(toRad(x));
            const sinh = (x) => Math.sinh(x);
            const cosh = (x) => Math.cosh(x);
            const tanh = (x) => Math.tanh(x);
            const sqrt = (x) => Math.sqrt(x);
            const ln = (x) => Math.log(x);
            const log = (x) => Math.log10(x);
            const log10 = (x) => Math.log10(x);
            const logb = (y, b) => Math.log(y) / Math.log(b);
            const nroot = (x, n) => Math.sign(x) >= 0 ? Math.pow(Math.abs(x), 1 / n) * (x < 0 && n % 2 ? -1 : 1) : Math.pow(x, 1 / n);
            const frac = (a, b) => a / b;
            const inv = (x) => 1 / x;
            const PI = Math.PI, E = Math.E;
            // numeric derivative and integral using the same scope
            const ddx = (exprStr, x0) => {



            };
            const int = (exprStr, a, b, n = 512) => {





            };
            const sum = (exprStr, i0, i1) => {



            };
            return { sin, cos, tan, csc, cot, sinh, cosh, tanh, sqrt, ln, log, log10, logb, nroot, frac, inv, ddx, int, sum, PI, E, ...userVars, ...memVars, M: MVal };
        }

        function evalExprWithVars(exprStr, extraVars) {
            const prepared = normalizeForEval(exprStr, true);
            const scope = { ...makeScope(), ...extraVars };
            const keys = Object.keys(scope);
            const vals = keys.map(k => scope[k]);
            // eslint-disable-next-line no-new-func
            return Function(...keys, `"use strict"; return (${prepared});`)(...vals);
        }

        function evalFuncFactory(expr) {
            const prepared = normalizeForEval(expr, true);
            const scope = makeScope();
            const keys = Object.keys(scope);
            const vals = keys.map(k => scope[k]);
            // eslint-disable-next-line no-new-func
            const f = Function('x', ...keys, `"use strict"; return (${prepared});`);
            return (x) => { try { return f(x, ...vals); } catch { return NaN; } };
        }

        function safeCalcEval(src) {
            if (!src) return;
            try {
                const shown = calcValueString(src);
                setResult(shown); justEvaluated = true;
            } catch (e) { setResult('Error'); }
        }

        // Return the calculated result as a display string, or throw on error
        function calcValueString(src) {
            const prepared = normalizeForEval(src, false);
            const scope = makeScope();
            const keys = Object.keys(scope);
            const vals = keys.map(k => scope[k]);
            // eslint-disable-next-line no-new-func
            const val = Function(...keys, `"use strict";return (${prepared})`)(...vals);
            if (val === undefined) return '0';
            return Number.isFinite(val) ? (Math.round(val * 1e10) / 1e10).toString() : String(val);
        }

        function isFunTheme() { return document.body.classList.contains('theme-fun'); }

        function spawnRipple(e) {
            if (!isFunTheme()) return;
            const btn = e.target.closest('button');
            if (!btn) return;
            const rect = btn.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height) * 1.5;
            const span = document.createElement('span');
            span.className = 'fun-ripple';
            span.style.width = span.style.height = size + 'px';
            const x = (e.clientX ?? (rect.left + rect.width / 2)) - rect.left - size / 2;
            const y = (e.clientY ?? (rect.top + rect.height / 2)) - rect.top - size / 2;
            span.style.left = x + 'px';
            span.style.top = y + 'px';
            btn.appendChild(span);
            span.addEventListener('animationend', () => span.remove());
        }

        function animateThrowToResult(value) {
            // Get source positions (expression digits)
            const exprText = exprEl.getBoundingClientRect();
            const resText = resEl.getBoundingClientRect();
            const sourceText = (exprText + resText).replace(/[^0-9.]/g, ''); // Only digits and decimal
            const resultDigits = [...value.toString()];

            const exprRect = exprEl.getBoundingClientRect();
            const resRect = resEl.getBoundingClientRect();
            const targetRect = resEl.getBoundingClientRect();

            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.inset = '0';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '99999';
            document.body.appendChild(container);

            // Calculate target positions for each digit in result
            const digitWidth = targetRect.width / Math.max(resultDigits.length, 1);

            resultDigits.forEach((digit, idx) => {
                const startX = exprRect.left + (exprRect.width / 2);
                const startY = exprRect.top + (exprRect.height / 2);
                const targetX = targetRect.left + (idx * digitWidth) + (digitWidth / 2);
                const targetY = targetRect.top + (targetRect.height / 2);

                const clone = document.createElement('div');
                clone.textContent = digit;
                clone.className = 'fun-flyClone';
                clone.style.left = startX + 'px';
                clone.style.top = startY + 'px';
                clone.style.fontSize = '24px';
                clone.style.transition = 'all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
                container.appendChild(clone);

                setTimeout(() => {
                    clone.style.left = targetX + 'px';
                    clone.style.top = targetY + 'px';
                    clone.style.fontSize = '48px';
                }, 10);

                clone.addEventListener('transitionend', () => {
                    clone.remove();
                });
            });

            // Set result after animation
            setTimeout(() => {
                setResult(value);
                resEl.classList.add('fun-flash');
                setTimeout(() => resEl.classList.remove('fun-flash'), 600);
                justEvaluated = true;
            }, 500);
        }

        function animateClearExplosion() {
            const exprText = exprEl.textContent || '';
            const resText = resEl.textContent || '';
            if (!exprText && (!resText || resText === '0')) { clearAll(); return; }

            const shards = document.createElement('div');
            shards.className = 'fun-shards';
            shards.style.position = 'fixed';
            shards.style.inset = '0';
            shards.style.pointerEvents = 'none';
            shards.style.zIndex = '99999';
            document.body.appendChild(shards);

            // Track which buttons will be hit
            const buttonHits = new Map(); // digit -> button element

            const addShardGroup = (ch, startRect) => {
                const shard = document.createElement('div');
                shard.className = 'fun-shard';
                shard.textContent = ch;
                shard.style.left = startRect.left + (startRect.width / 2) + 'px';
                shard.style.top = startRect.top + (startRect.height / 2) + 'px';
                const dx = (Math.random() - 0.5) * 200;
                const rot = (Math.random() - 0.5) * 720;
                shard.style.setProperty('--dx', dx + 'px');
                shard.style.setProperty('--rot', rot + 'deg');
                shard.style.animation = 'shardFall 1.2s ease-out forwards';
                shards.appendChild(shard);
            };

            const exprRect = exprEl.getBoundingClientRect();
            const resRect = resEl.getBoundingClientRect();
            [...exprText].forEach(ch => addShardGroup(ch, exprRect));
            [...resText].forEach(ch => addShardGroup(ch, resRect));

            // Trigger button explosions when particles land (around 70% of animation)
            setTimeout(() => {
                buttonHits.forEach((btn) => {
                    btn.style.animation = 'buttonExplosion 0.6s ease-out';
                    setTimeout(() => { btn.style.animation = ''; }, 600);
                });
            }, 840); // 70% of 1200ms

            // Clear displays shortly after particles start
            setTimeout(() => { expression = ''; setResult('0'); updateDisplay(); }, 150);
            // Cleanup
            setTimeout(() => { shards.remove(); }, 1400);
        }

        // Button events
        calculatorView?.querySelectorAll('.keypad button').forEach(btn => {
            const val = btn.getAttribute('data-value');
            const action = btn.getAttribute('data-action');
            const fn = btn.getAttribute('data-fn');
            const tpl = btn.getAttribute('data-template');
            if (val) {
                btn.addEventListener('click', (e) => { spawnRipple(e); appendToken(val); });
            } else if (fn) {
                btn.addEventListener('click', (e) => { spawnRipple(e); appendToken(fn + '('); });
            } else if (tpl) {
                btn.addEventListener('click', (e) => { spawnRipple(e); appendToken(tpl); });
            } else if (action === 'clear') {
                btn.addEventListener('click', (e) => {
                    spawnRipple(e);
                    clearAll();
                });
            } else if (action === 'delete') {
                btn.addEventListener('click', (e) => { spawnRipple(e); deleteOne(); });
            } else if (action === 'equals') {
                btn.addEventListener('click', (e) => {
                    spawnRipple(e);
                    safeCalcEval(expression);
                });
            } else if (action === 'sign') {
                btn.addEventListener('click', (e) => { spawnRipple(e); toggleSignSafe(); });
            } else if (action === 'sto') {
                btn.addEventListener('click', (e) => { spawnRipple(e); const v = Number(resEl.textContent); if (Number.isFinite(v)) { MVal = v; setResult(`M=${MVal}`); } });
            } else if (action === 'rcl') {
                btn.addEventListener('click', (e) => { spawnRipple(e); if (Number.isFinite(MVal)) { setResult(MVal); } });
            } else if (action === 'mplus') {
                btn.addEventListener('click', (e) => { spawnRipple(e); const v = Number(resEl.textContent); if (Number.isFinite(v)) { MVal += v; setResult(`M=${MVal}`); } });
            } else if (action === 'mminus') {
                btn.addEventListener('click', (e) => { spawnRipple(e); const v = Number(resEl.textContent); if (Number.isFinite(v)) { MVal -= v; setResult(`M=${MVal}`); } });
            } else if (action === 'putvar') {
                btn.addEventListener('click', (e) => { spawnRipple(e); appendToken(btn.textContent); });
            }
        });

        // Keyboard support
        window.addEventListener('keydown', (e) => {
            const k = e.key;
            if (/^[0-9]$/.test(k)) { appendToken(k); return; }
            if (/^[a-zA-Z_]$/.test(k)) { appendToken(k); return; }
            if (k === '.') { appendToken('.'); return; }
            if (['+', '-', '*', '/', '%', '^', '(', ')', ','].includes(k)) { appendToken(k); return; }
            if (k === 'Enter' || k === '=') {
                safeCalcEval(expression);
                return;
            }
            if (k === 'Backspace') { deleteOne(); return; }
        });

        // Angle toggle
        angleBtn?.addEventListener('click', () => { angleMode = angleMode === 'DEG' ? 'RAD' : 'DEG'; angleBtn.textContent = angleMode; angleBtn.title = 'Toggle angle mode'; });

        // Calculator settings flip animation (back button)
        const flipContainer = calculatorView?.querySelector('#flipContainer');
        const backToCalc = calculatorView?.querySelector('#backToCalc');

        backToCalc?.addEventListener('click', () => {
            flipContainer.classList.remove('flipped');
        });

        // Tabs switching
        calculatorView?.querySelectorAll('.tab').forEach(t => {
            t.addEventListener('click', () => {
                const id = t.getAttribute('data-panel');
                calculatorView.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                calculatorView.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
                t.classList.add('active');
                calculatorView.querySelector('#' + id)?.classList.add('active');
                if (id === 'graphPanel') setTimeout(plot, 0);
            });
        });

        // --- Graphing ---
        const canvas = document.getElementById('graph');
        const funcInput = document.getElementById('funcInput');
        const xminEl = document.getElementById('xmin');
        const xmaxEl = document.getElementById('xmax');
        const plotBtn = document.getElementById('plotBtn');

        function graphEvalFuncFactory(expr) {
            const prepared = normalizeForEval(expr, true);
            const { sin, cos, tan, csc, cot, sinh, cosh, tanh, PI, E } = makeScope();
            // eslint-disable-next-line no-new-func
            const f = Function('x', 'sin', 'cos', 'tan', 'csc', 'cot', 'sinh', 'cosh', 'tanh', 'PI', 'E', `"use strict"; return (${prepared});`);
            return (x) => { try { return f(x, sin, cos, tan, csc, cot, sinh, cosh, tanh, PI, E); } catch { return NaN; } };
        }

        function plot() {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, rect.width, rect.height);

            const x0 = parseFloat(xminEl.value);
            const x1 = parseFloat(xmaxEl.value);
            if (!(x0 < x1)) { ctx.fillStyle = '#ffb4b4'; ctx.fillText('Invalid range', 10, 20); return; }
            const f = graphEvalFuncFactory(funcInput.value);

            const N = 800; const xs = []; const ys = [];
            for (let i = 0; i <= N; i++) {
                const x = x0 + i * (x1 - x0) / N;
                xs.push(x);
                ys.push(f(x));
            }
            const finite = ys.filter(v => Number.isFinite(v));
            if (!finite.length) { ctx.fillStyle = '#ffb4b4'; ctx.fillText('No finite values to plot', 10, 20); return; }
            let ymin = Math.min(...finite), ymax = Math.max(...finite);
            if (ymin === ymax) { ymin -= 1; ymax += 1; }
            const pad = 10; const W = rect.width, H = rect.height;
            function sx(x) { return pad + (x - x0) * (W - 2 * pad) / (x1 - x0); }
            function sy(y) { return H - pad - (y - ymin) * (H - 2 * pad) / (ymax - ymin); }
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            if (x0 < 0 && x1 > 0) { ctx.beginPath(); ctx.moveTo(sx(0), sy(ymin)); ctx.lineTo(sx(0), sy(ymax)); ctx.stroke(); }
            if (ymin < 0 && ymax > 0) { ctx.beginPath(); ctx.moveTo(sx(x0), sy(0)); ctx.lineTo(sx(x1), sy(0)); ctx.stroke(); }
            ctx.beginPath(); let started = false; ctx.strokeStyle = 'rgba(102,170,255,0.95)'; ctx.lineWidth = 2;
            for (let i = 0; i <= N; i++) {
                if (Number.isFinite(ys[i])) {
                    if (!started) { ctx.moveTo(sx(xs[i]), sy(ys[i])); started = true; }
                    else { ctx.lineTo(sx(xs[i]), sy(ys[i])); }
                } else { started = false; }
            }
            ctx.stroke();
        }

        plotBtn?.addEventListener('click', plot);
        window.addEventListener('resize', () => { if (document.getElementById('graphPanel').classList.contains('active')) plot(); });

        // --- Background Color Controls ---
        const calcEl = calculatorView?.querySelector('.calc');
        const solidModeSettings = calculatorView?.querySelector('#solidModeSettings');
        const gradientModeSettings = calculatorView?.querySelector('#gradientModeSettings');
        const bgAngleSettings = calculatorView?.querySelector('#bgAngleSettings');
        const angleValueSettings = calculatorView?.querySelector('#angleValueSettings');
        const colorStopsContainer = calculatorView?.querySelector('#colorStopsContainer');
        const addColorStopBtn = calculatorView?.querySelector('#addColorStop');

        let bgMode = 'gradient';
        let colorStops = [
            { color: '#0f1628', position: 0 },
            { color: '#0d1426', position: 100 }
        ];

        function renderColorStops() {
            if (!colorStopsContainer) return;
            colorStopsContainer.innerHTML = '';
            colorStops.forEach((stop, idx) => {
                const div = document.createElement('div');
                div.className = 'colorStop';
                div.innerHTML = `
                    <input type="color" class="stopColor" value="${stop.color}" data-idx="${idx}">
                    <input type="range" class="stopPosition" min="0" max="100" value="${stop.position}" data-idx="${idx}">
                    <span>${stop.position}%</span>
                    ${colorStops.length > 2 ? `<button class="badge danger removeStop" data-idx="${idx}"></button>` : ''}
                `;
                colorStopsContainer.appendChild(div);
            });

            calculatorView.querySelectorAll('.stopColor').forEach(input => {
                input.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.dataset.idx, 10);
                    colorStops[idx].color = e.target.value;
                    updateCalcBackground();
                });
            });

            calculatorView.querySelectorAll('.stopPosition').forEach(input => {
                input.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.dataset.idx, 10);
                    colorStops[idx].position = parseInt(e.target.value, 10);
                    e.target.nextElementSibling.textContent = e.target.value + '%';
                    updateCalcBackground();
                });
            });

            calculatorView.querySelectorAll('.removeStop').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.dataset.idx, 10);
                    colorStops.splice(idx, 1);
                    renderColorStops();
                    updateCalcBackground();
                });
            });
        }

        function updateCalcBackground() {
            if (!calcEl || !bgAngleSettings || !angleValueSettings) return;
            const angle = bgAngleSettings.value + 'deg';
            angleValueSettings.textContent = bgAngleSettings.value + '';

            if (bgMode === 'solid') {
                calcEl.style.background = colorStops[0].color;
            } else {
                const sorted = [...colorStops].sort((a, b) => a.position - b.position);
                const gradientStops = sorted.map(s => `${s.color} ${s.position}%`).join(', ');
                calcEl.style.background = `linear-gradient(${angle}, ${gradientStops})`;
            }
        }

        solidModeSettings?.addEventListener('click', () => {
            bgMode = 'solid';
            solidModeSettings.classList.add('active');
            gradientModeSettings.classList.remove('active');
            if (bgAngleSettings) bgAngleSettings.style.display = 'none';
            if (bgAngleSettings && bgAngleSettings.previousElementSibling) bgAngleSettings.previousElementSibling.style.display = 'none';
            if (angleValueSettings) angleValueSettings.style.display = 'none';
            updateCalcBackground();
        });

        gradientModeSettings?.addEventListener('click', () => {
            bgMode = 'gradient';
            gradientModeSettings.classList.add('active');
            solidModeSettings.classList.remove('active');
            if (bgAngleSettings) bgAngleSettings.style.display = '';
            if (bgAngleSettings && bgAngleSettings.previousElementSibling) bgAngleSettings.previousElementSibling.style.display = '';
            if (angleValueSettings) angleValueSettings.style.display = '';
            updateCalcBackground();
        });

        bgAngleSettings?.addEventListener('input', updateCalcBackground);

        addColorStopBtn?.addEventListener('click', () => {
            const newPos = colorStops.length > 0 ? Math.floor(colorStops.reduce((sum, s) => sum + s.position, 0) / colorStops.length) : 50;
            colorStops.push({ color: '#6699ff', position: newPos });
            renderColorStops();
            updateCalcBackground();
        });

        // Initialize
        if (colorStopsContainer) {
            renderColorStops();
            updateCalcBackground();
        }

        // ========== GLOBAL BACKGROUND GRADIENT SETTINGS ==========
        const solidModeSettingsGlobal = document.querySelector('#solidModeSettingsGlobal');
        const gradientModeSettingsGlobal = document.querySelector('#gradientModeSettingsGlobal');
        const bgAngleSettingsGlobal = document.querySelector('#bgAngleSettingsGlobal');
        const angleValueSettingsGlobal = document.querySelector('#angleValueSettingsGlobal');
        const colorStopsContainerGlobal = document.querySelector('#colorStopsContainerGlobal');
        const addColorStopBtnGlobal = document.querySelector('#addColorStopGlobal');

        let globalBgMode = 'gradient';
        let globalColorStops = [
            { color: '#080c14', position: 0 },
            { color: '#0a0f1d', position: 100 }
        ];

        function renderGlobalColorStops() {
            if (!colorStopsContainerGlobal) return;
            colorStopsContainerGlobal.innerHTML = '';
            globalColorStops.forEach((stop, idx) => {
                const div = document.createElement('div');
                div.className = 'colorStop';
                div.innerHTML = `
                    <input type="color" class="stopColor" value="${stop.color}" data-idx="${idx}">
                    <input type="range" class="stopPosition" min="0" max="100" value="${stop.position}" data-idx="${idx}">
                    <span>${stop.position}%</span>
                    ${globalColorStops.length > 2 ? `<button class="badge danger removeStop" data-idx="${idx}"></button>` : ''}
                `;
                colorStopsContainerGlobal.appendChild(div);
            });

            document.querySelectorAll('#colorStopsContainerGlobal .stopColor').forEach(input => {
                input.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.dataset.idx, 10);
                    globalColorStops[idx].color = e.target.value;
                    updateGlobalBackground();
                });
            });

            document.querySelectorAll('#colorStopsContainerGlobal .stopPosition').forEach(input => {
                input.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.dataset.idx, 10);
                    globalColorStops[idx].position = parseInt(e.target.value, 10);
                    e.target.nextElementSibling.textContent = e.target.value + '%';
                    updateGlobalBackground();
                });
            });

            document.querySelectorAll('#colorStopsContainerGlobal .removeStop').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.dataset.idx, 10);
                    globalColorStops.splice(idx, 1);
                    renderGlobalColorStops();
                    updateGlobalBackground();
                });
            });
        }

        function updateGlobalBackground() {
            /* Update the background color based on the settings */
            if (!bgAngleSettingsGlobal || !angleValueSettingsGlobal) return;
            const angle = bgAngleSettingsGlobal.value + 'deg';
            angleValueSettingsGlobal.textContent = bgAngleSettingsGlobal.value + '';
            const startScreen = document.getElementById('startScreen');

            if (globalBgMode === 'solid') {
                const solidColor = globalColorStops[0].color;
                document.body.style.background = solidColor;
                if (startScreen) {
                    startScreen.style.background = solidColor;
                }
            } else {
                const sorted = [...globalColorStops].sort((a, b) => a.position - b.position);
                const gradientStops = sorted.map(s => `${s.color} ${s.position}%`).join(', ');
                const gradientValue = `linear-gradient(${angle}, ${gradientStops})`;
                document.body.style.background = gradientValue;
                if (startScreen) {
                    startScreen.style.background = gradientValue;
                }
            }
        }

        solidModeSettingsGlobal?.addEventListener('click', () => {
            globalBgMode = 'solid';
            solidModeSettingsGlobal.classList.add('active');
            gradientModeSettingsGlobal.classList.remove('active');
            if (bgAngleSettingsGlobal) bgAngleSettingsGlobal.style.display = 'none';
            if (bgAngleSettingsGlobal && bgAngleSettingsGlobal.previousElementSibling) bgAngleSettingsGlobal.previousElementSibling.style.display = 'none';
            if (angleValueSettingsGlobal) angleValueSettingsGlobal.style.display = 'none';
            updateGlobalBackground();
        });

        gradientModeSettingsGlobal?.addEventListener('click', () => {
            globalBgMode = 'gradient';
            gradientModeSettingsGlobal.classList.add('active');
            solidModeSettingsGlobal.classList.remove('active');
            if (bgAngleSettingsGlobal) bgAngleSettingsGlobal.style.display = '';
            if (bgAngleSettingsGlobal && bgAngleSettingsGlobal.previousElementSibling) bgAngleSettingsGlobal.previousElementSibling.style.display = '';
            if (angleValueSettingsGlobal) angleValueSettingsGlobal.style.display = '';
            updateGlobalBackground();
        });

        bgAngleSettingsGlobal?.addEventListener('input', updateGlobalBackground);

        addColorStopBtnGlobal?.addEventListener('click', () => {
            const newPos = globalColorStops.length > 0 ? Math.floor(globalColorStops.reduce((sum, s) => sum + s.position, 0) / globalColorStops.length) : 50;
            globalColorStops.push({ color: '#6699ff', position: newPos });
            renderGlobalColorStops();
            updateGlobalBackground();
        });

        // Initialize global background
        if (colorStopsContainerGlobal) {
            renderGlobalColorStops();
            updateGlobalBackground();
        }

        // --- Practice ---
        const ptype = document.getElementById('ptype');
        const newProb = document.getElementById('newProb');
        const probText = document.getElementById('probText');
        const answer = document.getElementById('answer');

        // ========== DRAWING STUDIO ==========
        const drawCanvas = drawingView?.querySelector('#drawCanvas');
        if (drawCanvas) {
            const drawCtx = drawCanvas.getContext('2d');

            // Drawing state
            let drawIsDrawing = false;
            let drawCurrentTool = 'pen';
            let drawCurrentColor = '#000000';
            let drawBrushSize = 5;
            let drawOpacity = 1;
            let drawLastX = 0;
            let drawLastY = 0;
            let drawHistory = [];
            let drawHistoryStep = -1;
            let drawShowGrid = false;
            let drawRulerActive = false;
            let drawRulerH = null;
            let drawRulerV = null;

            // Initialize canvas
            function initDrawCanvas() {
                drawCtx.fillStyle = 'white';
                drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                saveDrawState();
            }

            function saveDrawState() {
                drawHistoryStep++;
                if (drawHistoryStep < drawHistory.length) {
                    drawHistory.length = drawHistoryStep;
                }
                drawHistory.push(drawCanvas.toDataURL());
            }

            function undoDraw() {
                if (drawHistoryStep > 0) {
                    drawHistoryStep--;
                    const img = new Image();
                    img.src = drawHistory[drawHistoryStep];
                    img.onload = function () {
                        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                        drawCtx.drawImage(img, 0, 0);
                        redrawGrid();
                    };
                }
            }

            // Tool implementations
            const drawTools = {
                pen: (x, y, lastX, lastY) => {
                    drawCtx.lineWidth = drawBrushSize;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.globalAlpha = drawOpacity;
                    drawCtx.strokeStyle = drawCurrentColor;
                    drawCtx.beginPath();
                    drawCtx.moveTo(lastX, lastY);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();
                },
                calligraphy: (x, y, lastX, lastY) => {
                    const angle = Math.atan2(y - lastY, x - lastX);
                    drawCtx.save();
                    drawCtx.translate(x, y);
                    drawCtx.rotate(angle);
                    drawCtx.lineWidth = 1;
                    drawCtx.fillStyle = drawCurrentColor;
                    drawCtx.globalAlpha = drawOpacity;
                    drawCtx.fillRect(-drawBrushSize, -drawBrushSize / 4, drawBrushSize * 2, drawBrushSize / 2);
                    drawCtx.restore();
                    drawCtx.beginPath();
                    drawCtx.moveTo(lastX, lastY);
                    drawCtx.lineTo(x, y);
                    drawCtx.strokeStyle = drawCurrentColor;
                    drawCtx.lineWidth = drawBrushSize / 2;
                    drawCtx.stroke();
                },
                pencil: (x, y, lastX, lastY) => {
                    drawCtx.lineWidth = drawBrushSize * 0.7;
                    drawCtx.lineCap = 'round';
                    drawCtx.globalAlpha = drawOpacity * 0.6;
                    drawCtx.strokeStyle = drawCurrentColor;
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (Math.random() - 0.5) * 2;
                        const offsetY = (Math.random() - 0.5) * 2;
                        drawCtx.beginPath();
                        drawCtx.moveTo(lastX + offsetX, lastY + offsetY);
                        drawCtx.lineTo(x + offsetX, y + offsetY);
                        drawCtx.stroke();
                    }
                },
                colorpencil: (x, y, lastX, lastY) => {
                    drawCtx.lineWidth = drawBrushSize * 0.8;
                    drawCtx.lineCap = 'round';
                    drawCtx.globalAlpha = drawOpacity * 0.7;
                    drawCtx.strokeStyle = drawCurrentColor;
                    for (let i = 0; i < 2; i++) {
                        const offsetX = (Math.random() - 0.5) * 1.5;
                        const offsetY = (Math.random() - 0.5) * 1.5;
                        drawCtx.beginPath();
                        drawCtx.moveTo(lastX + offsetX, lastY + offsetY);
                        drawCtx.lineTo(x + offsetX, y + offsetY);
                        drawCtx.stroke();
                    }
                },
                gel: (x, y, lastX, lastY) => {
                    // Main gel pen stroke
                    drawCtx.lineWidth = drawBrushSize;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.globalAlpha = drawOpacity;
                    drawCtx.strokeStyle = drawCurrentColor;
                    drawCtx.shadowBlur = drawBrushSize * 0.5;
                    drawCtx.shadowColor = drawCurrentColor;
                    drawCtx.beginPath();
                    drawCtx.moveTo(lastX, lastY);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();
                    drawCtx.shadowBlur = 0;

                    // Add sparkle effect
                    drawCtx.globalAlpha = drawOpacity * 0.8;
                    for (let i = 0; i < 5; i++) {
                        const sparkleX = x + (Math.random() - 0.5) * drawBrushSize * 2;
                        const sparkleY = y + (Math.random() - 0.5) * drawBrushSize * 2;
                        const sparkleSize = Math.random() * 2 + 1;

                        // Draw sparkle as a small star
                        drawCtx.fillStyle = 'rgba(255, 255, 255, ' + (Math.random() * 0.7 + 0.3) + ')';
                        drawCtx.beginPath();
                        drawCtx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        drawCtx.fill();

                        // Add tiny cross for star effect
                        drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        drawCtx.lineWidth = 0.5;
                        drawCtx.beginPath();
                        drawCtx.moveTo(sparkleX - sparkleSize, sparkleY);
                        drawCtx.lineTo(sparkleX + sparkleSize, sparkleY);
                        drawCtx.moveTo(sparkleX, sparkleY - sparkleSize);
                        drawCtx.lineTo(sparkleX, sparkleY + sparkleSize);
                        drawCtx.stroke();
                    }
                },
                marker: (x, y, lastX, lastY) => {
                    drawCtx.lineWidth = drawBrushSize * 2;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.globalAlpha = drawOpacity * 0.4;
                    drawCtx.strokeStyle = drawCurrentColor;
                    drawCtx.beginPath();
                    drawCtx.moveTo(lastX, lastY);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();
                },
                crayon: (x, y, lastX, lastY) => {
                    drawCtx.lineWidth = drawBrushSize * 2;
                    drawCtx.lineCap = 'round';
                    drawCtx.globalAlpha = drawOpacity * 0.7;
                    drawCtx.strokeStyle = drawCurrentColor;

                    // Draw strokes with very small random gaps (1-2 pixels)
                    const distance = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);
                    const gapSize = Math.random() * 1 + 1; // Random gap between 1-2 pixels (very small)
                    const steps = Math.max(1, Math.floor(distance / gapSize));

                    for (let i = 0; i < steps; i++) {
                        // Skip some segments randomly to create small gaps
                        if (Math.random() > 0.15) { // 85% chance to draw, 15% chance to skip (less gaps)
                            const t = i / steps;
                            const px = lastX + (x - lastX) * t;
                            const py = lastY + (y - lastY) * t;

                            // Draw small waxy chunks
                            drawCtx.beginPath();
                            drawCtx.arc(px, py, drawBrushSize * 0.8, 0, Math.PI * 2);
                            drawCtx.fill();

                            // Add texture particles
                            for (let j = 0; j < 2; j++) {
                                const offsetX = (Math.random() - 0.5) * drawBrushSize;
                                const offsetY = (Math.random() - 0.5) * drawBrushSize;
                                drawCtx.fillStyle = drawCurrentColor;
                                drawCtx.fillRect(px + offsetX, py + offsetY, 2, 2);
                            }
                        }
                    }
                },
                spray: (x, y) => {
                    const density = drawBrushSize * 2;
                    drawCtx.globalAlpha = drawOpacity * 0.1;
                    drawCtx.fillStyle = drawCurrentColor;
                    for (let i = 0; i < density; i++) {
                        const offsetX = (Math.random() - 0.5) * drawBrushSize * 4;
                        const offsetY = (Math.random() - 0.5) * drawBrushSize * 4;
                        drawCtx.fillRect(x + offsetX, y + offsetY, 1, 1);
                    }
                },
                graffiti: (x, y, lastX, lastY) => {
                    // Main graffiti stroke
                    drawCtx.lineWidth = drawBrushSize * 3;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.globalAlpha = drawOpacity * 0.7;
                    drawCtx.strokeStyle = drawCurrentColor;
                    drawCtx.beginPath();
                    drawCtx.moveTo(lastX, lastY);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();

                    // Strong fade effect - multiple layers with decreasing opacity
                    const fadeRadius = drawBrushSize * 6; // Reasonable fade distance
                    const fadeLayers = 8;

                    for (let layer = 0; layer < fadeLayers; layer++) {
                        const layerRadius = (layer + 1) * (fadeRadius / fadeLayers);
                        const layerAlpha = drawOpacity * (1 - layer / fadeLayers) * 0.15;

                        drawCtx.globalAlpha = layerAlpha;
                        drawCtx.lineWidth = drawBrushSize * 3 + layerRadius;
                        drawCtx.strokeStyle = drawCurrentColor;
                        drawCtx.beginPath();
                        drawCtx.moveTo(lastX, lastY);
                        drawCtx.lineTo(x, y);
                        drawCtx.stroke();
                    }

                    // Add occasional drips
                    if (Math.random() > 0.95) {
                        drawCtx.globalAlpha = drawOpacity * 0.4;
                        drawCtx.beginPath();
                        drawCtx.moveTo(x, y);
                        drawCtx.lineTo(x + (Math.random() - 0.5) * 5, y + drawBrushSize * 2);
                        drawCtx.lineWidth = drawBrushSize * 0.5;
                        drawCtx.stroke();
                    }
                },
                eraser: (x, y, lastX, lastY) => {
                    drawCtx.globalAlpha = 1;
                    drawCtx.lineWidth = drawBrushSize * 2;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.globalCompositeOperation = 'destination-out';
                    drawCtx.beginPath();
                    drawCtx.moveTo(lastX, lastY);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();
                    drawCtx.globalCompositeOperation = 'source-over';
                },
                bucket: (x, y) => {
                    // Flood fill algorithm
                    const imageData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
                    const pixels = imageData.data;
                    const startPos = (Math.floor(y) * drawCanvas.width + Math.floor(x)) * 4;

                    const startR = pixels[startPos];
                    const startG = pixels[startPos + 1];
                    const startB = pixels[startPos + 2];
                    const startA = pixels[startPos + 3];

                    // Parse fill color
                    const fillColor = drawCurrentColor;
                    const tempDiv = document.createElement('div');
                    tempDiv.style.color = fillColor;
                    document.body.appendChild(tempDiv);
                    const computed = getComputedStyle(tempDiv).color;
                    document.body.removeChild(tempDiv);

                    const rgb = computed.match(/\d+/g);
                    const fillR = parseInt(rgb[0]);
                    const fillG = parseInt(rgb[1]);
                    const fillB = parseInt(rgb[2]);
                    const fillA = Math.round(drawOpacity * 255);

                    // Don't fill if color is the same
                    if (startR === fillR && startG === fillG && startB === fillB && startA === fillA) {
                        return;
                    }

                    const colorMatch = (pos) => {
                        return pixels[pos] === startR &&
                            pixels[pos + 1] === startG &&
                            pixels[pos + 2] === startB &&
                            pixels[pos + 3] === startA;
                    };

                    const stack = [[Math.floor(x), Math.floor(y)]];
                    const visited = new Set();

                    while (stack.length > 0) {
                        const [cx, cy] = stack.pop();

                        if (cx < 0 || cx >= drawCanvas.width || cy < 0 || cy >= drawCanvas.height) continue;

                        const key = cy * drawCanvas.width + cx;
                        if (visited.has(key)) continue;
                        visited.add(key);

                        const pos = key * 4;

                        if (!colorMatch(pos)) continue;

                        // Fill pixel
                        pixels[pos] = fillR;
                        pixels[pos + 1] = fillG;
                        pixels[pos + 2] = fillB;
                        pixels[pos + 3] = fillA;

                        // Add neighbors
                        stack.push([cx + 1, cy]);
                        stack.push([cx - 1, cy]);
                        stack.push([cx, cy + 1]);
                        stack.push([cx, cy - 1]);
                    }

                    drawCtx.putImageData(imageData, 0, 0);
                    saveDrawState();
                }
            };

            function startDrawing(e) {
                const rect = drawCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Bucket tool works on click, not drag
                if (drawCurrentTool === 'bucket') {
                    drawTools.bucket(x, y);
                    return;
                }

                drawIsDrawing = true;
                drawLastX = x;
                drawLastY = y;
            }

            function draw(e) {
                if (!drawIsDrawing) return;
                const rect = drawCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (drawTools[drawCurrentTool]) {
                    drawTools[drawCurrentTool](x, y, drawLastX, drawLastY);
                }
                drawLastX = x;
                drawLastY = y;
                updateRuler(e);
            }

            function stopDrawing() {
                if (drawIsDrawing) {
                    drawIsDrawing = false;
                    saveDrawState();
                    redrawGrid();
                }
            }

            function updateRuler(e) {
                if (!drawRulerActive) return;
                const rect = drawCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (drawRulerH) {
                    drawRulerH.style.top = (rect.top + y) + 'px';
                    drawRulerH.style.left = rect.left + 'px';
                    drawRulerH.style.width = rect.width + 'px';
                }
                if (drawRulerV) {
                    drawRulerV.style.left = (rect.left + x) + 'px';
                    drawRulerV.style.top = rect.top + 'px';
                    drawRulerV.style.height = rect.height + 'px';
                }
            }

            function redrawGrid() {
                if (drawShowGrid) {
                    drawCtx.save();
                    drawCtx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                    drawCtx.lineWidth = 1;
                    for (let x = 0; x <= drawCanvas.width; x += 50) {
                        drawCtx.beginPath();
                        drawCtx.moveTo(x, 0);
                        drawCtx.lineTo(x, drawCanvas.height);
                        drawCtx.stroke();
                    }
                    for (let y = 0; y <= drawCanvas.height; y += 50) {
                        drawCtx.beginPath();
                        drawCtx.moveTo(0, y);
                        drawCtx.lineTo(drawCanvas.width, y);
                        drawCtx.stroke();
                    }
                    drawCtx.restore();
                }
            }

            // Event listeners
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', (e) => {
                draw(e);
                updateRuler(e);
            });
            drawCanvas.addEventListener('mouseup', stopDrawing);
            drawCanvas.addEventListener('mouseout', stopDrawing);

            // Tool selection - Scoped to drawing view
            drawingView.querySelectorAll('.drawToolBtn').forEach(btn => {
                btn.addEventListener('click', () => {
                    drawingView.querySelectorAll('.drawToolBtn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    drawCurrentTool = btn.getAttribute('data-tool');
                });
            });

            // Color picker
            const drawColorPicker = drawingView.querySelector('#drawColorPicker');
            const drawColorHex = drawingView.querySelector('#drawColorHex');
            if (drawColorPicker) {
                drawColorPicker.addEventListener('input', (e) => {
                    drawCurrentColor = e.target.value;
                    if (drawColorHex) drawColorHex.textContent = e.target.value.toUpperCase();
                });
            }

            // Preset colors - Scoped to drawing view
            drawingView.querySelectorAll('.colorPreset').forEach(preset => {
                preset.addEventListener('click', () => {
                    const color = preset.getAttribute('data-color');
                    drawCurrentColor = color;
                    if (drawColorPicker) drawColorPicker.value = color;
                    if (drawColorHex) drawColorHex.textContent = color;
                });
            });

            // Size slider
            const drawSizeSlider = drawingView.querySelector('#drawSizeSlider');
            const drawSizeVal = drawingView.querySelector('#drawSizeVal');
            if (drawSizeSlider) {
                drawSizeSlider.addEventListener('input', (e) => {
                    drawBrushSize = parseInt(e.target.value);
                    if (drawSizeVal) drawSizeVal.textContent = drawBrushSize;
                });
            }

            // Opacity slider
            const drawOpacitySlider = drawingView.querySelector('#drawOpacitySlider');
            const drawOpacityVal = drawingView.querySelector('#drawOpacityVal');
            if (drawOpacitySlider) {
                drawOpacitySlider.addEventListener('input', (e) => {
                    drawOpacity = parseInt(e.target.value) / 100;
                    if (drawOpacityVal) drawOpacityVal.textContent = e.target.value + '%';
                });
            }

            // Control buttons
            drawingView.querySelector('#drawUndoBtn')?.addEventListener('click', undoDraw);
            drawingView.querySelector('#drawClearBtn')?.addEventListener('click', () => {
                if (confirm('Clear canvas?')) {
                    // Reset all drawing properties
                    drawCtx.globalAlpha = 1;
                    drawCtx.shadowBlur = 0;
                    drawCtx.shadowColor = 'transparent';
                    // Clear canvas completely
                    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                    // Fill with white
                    drawCtx.fillStyle = 'white';
                    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                    // Reset history
                    drawHistory = [];
                    drawHistoryStep = -1;
                    saveDrawState();
                    redrawGrid();
                }
            });
            drawingView.querySelector('#drawSaveBtn')?.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'my-drawing.png';
                link.href = drawCanvas.toDataURL();
                link.click();
            });

            // Grid toggle
            drawingView.querySelector('#drawGridBtn')?.addEventListener('click', function () {
                drawShowGrid = !drawShowGrid;
                this.textContent = drawShowGrid ? ' Hide Grid' : ' Show Grid';
                if (drawShowGrid) {
                    redrawGrid();
                } else {
                    const imgData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
                    drawCtx.fillStyle = 'white';
                    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                    drawCtx.putImageData(imgData, 0, 0);
                }
            });

            // Ruler toggle
            drawingView.querySelector('#drawRulerBtn')?.addEventListener('click', function () {
                drawRulerActive = !drawRulerActive;
                this.textContent = drawRulerActive ? ' Hide Ruler' : ' Show Ruler';
                if (drawRulerActive) {
                    if (!drawRulerH) {
                        drawRulerH = document.createElement('div');
                        drawRulerH.className = 'rulerOverlay rulerH';
                        document.body.appendChild(drawRulerH);
                        drawRulerV = document.createElement('div');
                        drawRulerV.className = 'rulerOverlay rulerV';
                        document.body.appendChild(drawRulerV);
                    }
                    drawRulerH.style.display = 'block';
                    drawRulerV.style.display = 'block';
                } else {
                    if (drawRulerH) drawRulerH.style.display = 'none';
                    if (drawRulerV) drawRulerV.style.display = 'none';
                }
            });

            // AI Assistant
            const aiPanel = drawingView.querySelector('#aiPanel');
            const aiPrompt = drawingView.querySelector('#aiPrompt');

            drawingView.querySelector('#aiToggleBtn')?.addEventListener('click', () => {
                aiPanel.classList.add('active');
            });

            drawingView.querySelector('#aiCloseBtn')?.addEventListener('click', () => {
                aiPanel.classList.remove('active');
            });

            // AI Drawing function
            function aiDraw(prompt) {
                const centerX = drawCanvas.width / 2;
                const centerY = drawCanvas.height / 2;

                // Save current state
                const oldTool = drawCurrentTool;
                const oldColor = drawCurrentColor;
                drawCurrentTool = 'pen';

                function drawLine(x1, y1, x2, y2, color = drawCurrentColor) {
                    drawCurrentColor = color;
                    drawTools.pen(x2, y2, x1, y1);
                }

                function drawCircle(x, y, radius, color = drawCurrentColor) {
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, radius, 0, Math.PI * 2);
                    drawCtx.strokeStyle = color;
                    drawCtx.lineWidth = drawBrushSize;
                    drawCtx.globalAlpha = drawOpacity;
                    drawCtx.stroke();
                }

                function drawStar(x, y, size) {
                    drawCurrentColor = '#FFD700';
                    const points = 5;
                    const outerRadius = size;
                    const innerRadius = size / 2.5;
                    drawCtx.beginPath();
                    for (let i = 0; i < points * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i * Math.PI) / points - Math.PI / 2;
                        const px = x + radius * Math.cos(angle);
                        const py = y + radius * Math.sin(angle);
                        if (i === 0) drawCtx.moveTo(px, py);
                        else drawCtx.lineTo(px, py);
                    }
                    drawCtx.closePath();
                    drawCtx.fillStyle = '#FFD700';
                    drawCtx.fill();
                    drawCtx.strokeStyle = '#FFA500';
                    drawCtx.stroke();
                }

                function drawHeart(x, y, size) {
                    drawCurrentColor = '#FF0000';
                    drawCtx.beginPath();
                    const topY = y - size / 2;
                    drawCtx.moveTo(x, topY + size / 4);
                    drawCtx.bezierCurveTo(x, topY, x - size / 2, topY, x - size / 2, topY + size / 4);
                    drawCtx.bezierCurveTo(x - size / 2, topY + size / 2, x, topY + size * 0.75, x, topY + size);
                    drawCtx.bezierCurveTo(x, topY + size * 0.75, x + size / 2, topY + size / 2, x + size / 2, topY + size / 4);
                    drawCtx.bezierCurveTo(x + size / 2, topY, x, topY, x, topY + size / 4);
                    drawCtx.fillStyle = '#FF0000';
                    drawCtx.fill();
                    drawCtx.strokeStyle = '#CC0000';
                    drawCtx.stroke();
                }

                function drawHouse(x, y, size) {
                    // Walls
                    drawCurrentColor = '#8B4513';
                    drawCtx.fillStyle = '#DEB887';
                    drawCtx.fillRect(x - size / 2, y, size, size);
                    drawCtx.strokeStyle = '#8B4513';
                    drawCtx.strokeRect(x - size / 2, y, size, size);

                    // Roof
                    drawCtx.beginPath();
                    drawCtx.moveTo(x - size * 0.6, y);
                    drawCtx.lineTo(x, y - size * 0.5);
                    drawCtx.lineTo(x + size * 0.6, y);
                    drawCtx.closePath();
                    drawCtx.fillStyle = '#8B0000';
                    drawCtx.fill();
                    drawCtx.strokeStyle = '#660000';
                    drawCtx.stroke();

                    // Door
                    drawCtx.fillStyle = '#654321';
                    drawCtx.fillRect(x - size * 0.15, y + size * 0.5, size * 0.3, size * 0.5);

                    // Window
                    drawCtx.fillStyle = '#87CEEB';
                    drawCtx.fillRect(x + size * 0.15, y + size * 0.25, size * 0.25, size * 0.25);
                }

                function drawTree(x, y, size) {
                    // Trunk
                    drawCtx.fillStyle = '#8B4513';
                    drawCtx.fillRect(x - size * 0.1, y, size * 0.2, size * 0.6);

                    // Leaves
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                    drawCtx.fillStyle = '#228B22';
                    drawCtx.fill();
                    drawCtx.strokeStyle = '#006400';
                    drawCtx.stroke();

                    drawCtx.beginPath();
                    drawCtx.arc(x - size * 0.2, y - size * 0.2, size * 0.3, 0, Math.PI * 2);
                    drawCtx.fillStyle = '#32CD32';
                    drawCtx.fill();
                    drawCtx.stroke();

                    drawCtx.beginPath();
                    drawCtx.arc(x + size * 0.2, y - size * 0.2, size * 0.3, 0, Math.PI * 2);
                    drawCtx.fillStyle = '#228B22';
                    drawCtx.fill();
                    drawCtx.stroke();
                }

                function drawSun(x, y, size) {
                    // Center circle
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, size * 0.5, 0, Math.PI * 2);
                    drawCtx.fillStyle = '#FFD700';
                    drawCtx.fill();
                    drawCtx.strokeStyle = '#FFA500';
                    drawCtx.stroke();

                    // Rays
                    drawCtx.strokeStyle = '#FFD700';
                    drawCtx.lineWidth = drawBrushSize * 2;
                    for (let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI) / 6;
                        const x1 = x + size * 0.6 * Math.cos(angle);
                        const y1 = y + size * 0.6 * Math.sin(angle);
                        const x2 = x + size * Math.cos(angle);
                        const y2 = y + size * Math.sin(angle);
                        drawCtx.beginPath();
                        drawCtx.moveTo(x1, y1);
                        drawCtx.lineTo(x2, y2);
                        drawCtx.stroke();
                    }
                }

                // Parse prompt and draw
                const lower = prompt.toLowerCase();
                if (lower.includes('star')) {
                    drawStar(centerX, centerY, 60);
                } else if (lower.includes('heart')) {
                    drawHeart(centerX, centerY, 80);
                } else if (lower.includes('house')) {
                    drawHouse(centerX, centerY, 100);
                } else if (lower.includes('tree')) {
                    drawTree(centerX, centerY + 50, 80);
                } else if (lower.includes('sun')) {
                    drawSun(centerX, centerY, 60);
                } else if (lower.includes('flower')) {
                    // Draw flower
                    drawCurrentColor = '#FF69B4';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4;
                        const x = centerX + 30 * Math.cos(angle);
                        const y = centerY + 30 * Math.sin(angle);
                        drawCircle(x, y, 15, '#FF69B4');
                    }
                    drawCircle(centerX, centerY, 20, '#FFD700');
                    drawLine(centerX, centerY + 20, centerX, centerY + 100, '#228B22');
                } else if (lower.includes('sunset') || lower.includes('mountain')) {
                    // Draw sunset with mountains
                    drawSun(centerX, centerY - 100, 50);
                    // Mountains
                    drawCurrentColor = '#4169E1';
                    drawCtx.beginPath();
                    drawCtx.moveTo(0, centerY + 100);
                    drawCtx.lineTo(centerX - 150, centerY - 50);
                    drawCtx.lineTo(centerX - 50, centerY + 100);
                    drawCtx.closePath();
                    drawCtx.fillStyle = '#4169E1';
                    drawCtx.fill();

                    drawCtx.beginPath();
                    drawCtx.moveTo(centerX, centerY + 100);
                    drawCtx.lineTo(centerX + 100, centerY - 30);
                    drawCtx.lineTo(drawCanvas.width, centerY + 100);
                    drawCtx.closePath();
                    drawCtx.fillStyle = '#4682B4';
                    drawCtx.fill();
                } else {
                    // Default: draw a smiley face
                    drawCircle(centerX, centerY, 80, '#FFD700');
                    drawCircle(centerX - 25, centerY - 20, 8, '#000000');
                    drawCircle(centerX + 25, centerY - 20, 8, '#000000');
                    drawCtx.beginPath();
                    drawCtx.arc(centerX, centerY + 10, 40, 0, Math.PI);
                    drawCtx.strokeStyle = '#000000';
                    drawCtx.lineWidth = 3;
                    drawCtx.stroke();
                }

                // Restore state
                drawCurrentTool = oldTool;
                drawCurrentColor = oldColor;
                saveDrawState();
                redrawGrid();
            }

            document.getElementById('aiDrawBtn')?.addEventListener('click', () => {
                const prompt = aiPrompt.value.trim();
                if (prompt) {
                    aiDraw(prompt);
                    aiPrompt.value = '';
                }
            });

            drawingView.querySelector('#aiQuickStar')?.addEventListener('click', () => aiDraw('star'));
            drawingView.querySelector('#aiQuickHeart')?.addEventListener('click', () => aiDraw('heart'));
            drawingView.querySelector('#aiQuickHouse')?.addEventListener('click', () => aiDraw('house'));
            drawingView.querySelector('#aiQuickTree')?.addEventListener('click', () => aiDraw('tree'));
            drawingView.querySelector('#aiQuickSun')?.addEventListener('click', () => aiDraw('sun'));

            // Color Selector Modal
            const colorSelectorModal = document.getElementById('colorSelectorModal');
            const colorWheelCanvas = document.getElementById('colorWheelCanvas');
            const colorPointer = document.getElementById('colorPointer');
            const selectedColorBox = document.getElementById('selectedColorBox');
            const colorHexDisplay = document.getElementById('colorHexDisplay');
            const colorSelectorBtn = drawingView.querySelector('#colorSelectorBtn');
            const applyColorBtn = document.getElementById('applyColorBtn');
            const closeColorSelectorBtn = document.getElementById('closeColorSelectorBtn');

            let selectedColor = { h: 0, s: 100, v: 100 }; // HSV color
            let pointerX = 150; // Center of wheel
            let pointerY = 150;
            let isDraggingPointer = false;

            // Draw color wheel
            function drawColorWheel() {
                const ctx = colorWheelCanvas.getContext('2d');
                const centerX = 150;
                const centerY = 150;
                const radius = 140;

                // Clear canvas
                ctx.clearRect(0, 0, 300, 300);

                // Draw color wheel
                for (let angle = 0; angle < 360; angle++) {
                    const startAngle = (angle - 90) * Math.PI / 180;
                    const endAngle = (angle + 1 - 90) * Math.PI / 180;

                    // Draw outer ring (full saturation)
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    const hue = angle;
                    gradient.addColorStop(0, `hsl(${hue}, 0%, 100%)`); // White center
                    gradient.addColorStop(0.7, `hsl(${hue}, 100%, 50%)`); // Full saturation
                    gradient.addColorStop(1, `hsl(${hue}, 100%, 25%)`); // Darker edge

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw white gradient in center
                const whiteGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.3);
                whiteGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                whiteGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = whiteGradient;
                ctx.fillRect(0, 0, 300, 300);
            }

            // Convert HSV to RGB
            function hsvToRgb(h, s, v) {
                s /= 100;
                v /= 100;
                const c = v * s;
                const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                const m = v - c;
                let r, g, b;

                if (h >= 0 && h < 60) {
                    [r, g, b] = [c, x, 0];
                } else if (h >= 60 && h < 120) {
                    [r, g, b] = [x, c, 0];
                } else if (h >= 120 && h < 180) {
                    [r, g, b] = [0, c, x];
                } else if (h >= 180 && h < 240) {
                    [r, g, b] = [0, x, c];
                } else if (h >= 240 && h < 300) {
                    [r, g, b] = [x, 0, c];
                } else {
                    [r, g, b] = [c, 0, x];
                }

                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);

                return { r, g, b };
            }

            // Convert RGB to Hex
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }

            // Update color display
            function updateColorDisplay() {
                const { r, g, b } = hsvToRgb(selectedColor.h, selectedColor.s, selectedColor.v);
                const hex = rgbToHex(r, g, b);
                selectedColorBox.style.backgroundColor = hex;
                colorHexDisplay.textContent = hex;

                // Update pointer position
                const centerX = 150;
                const centerY = 150;
                const angle = (selectedColor.h + 90) * Math.PI / 180;
                const distance = (selectedColor.s / 100) * 140 * (selectedColor.v / 100);
                pointerX = centerX + Math.cos(angle) * distance;
                pointerY = centerY + Math.sin(angle) * distance;

                colorPointer.style.left = pointerX + 'px';
                colorPointer.style.top = pointerY + 'px';
            }

            // Get color from position
            function getColorFromPosition(x, y) {
                const centerX = 150;
                const centerY = 150;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                if (distance > 140) return; // Outside wheel

                selectedColor.h = (angle - 90 + 360) % 360;
                selectedColor.s = Math.min(100, (distance / 140) * 100);
                selectedColor.v = Math.max(25, 100 - (distance / 140) * 75);

                updateColorDisplay();
            }

            // Mouse events
            colorWheelCanvas.addEventListener('mousedown', (e) => {
                isDraggingPointer = true;
                const rect = colorWheelCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                getColorFromPosition(x, y);
            });

            colorWheelCanvas.addEventListener('mousemove', (e) => {
                if (isDraggingPointer) {
                    const rect = colorWheelCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    getColorFromPosition(x, y);
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingPointer = false;
            });

            // Keyboard controls (arrow keys move pointer 1px at a time)
            document.addEventListener('keydown', (e) => {
                if (!colorSelectorModal.classList.contains('active')) return;

                const moveStep = 1;
                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        pointerY = Math.max(10, pointerY - moveStep);
                        getColorFromPosition(pointerX, pointerY);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        pointerY = Math.min(290, pointerY + moveStep);
                        getColorFromPosition(pointerX, pointerY);
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        pointerX = Math.max(10, pointerX - moveStep);
                        getColorFromPosition(pointerX, pointerY);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        pointerX = Math.min(290, pointerX + moveStep);
                        getColorFromPosition(pointerX, pointerY);
                        break;
                }
            });

            // Button events
            colorSelectorBtn?.addEventListener('click', () => {
                colorSelectorModal.classList.add('active');
                drawColorWheel();
                updateColorDisplay();
            });

            closeColorSelectorBtn?.addEventListener('click', () => {
                colorSelectorModal.classList.remove('active');
            });

            applyColorBtn?.addEventListener('click', () => {
                const { r, g, b } = hsvToRgb(selectedColor.h, selectedColor.s, selectedColor.v);
                const hex = rgbToHex(r, g, b);
                drawCurrentColor = hex;

                // Update the color picker in drawing panel
                const colorPicker = drawingView.querySelector('#drawColorPicker');
                if (colorPicker) colorPicker.value = hex;

                const colorHex = drawingView.querySelector('#drawColorHex');
                if (colorHex) colorHex.textContent = hex;

                colorSelectorModal.classList.remove('active');
            });

            // Initialize
            initDrawCanvas();
        }
        // ========== END DRAWING STUDIO ==========

        // ========== STOPWATCH ==========
        let stopwatchRunning = false;
        let stopwatchStartTime = 0;
        let stopwatchElapsed = 0;
        let stopwatchInterval = null;
        let lapCounter = 0;

        const stopwatchDisplay = document.getElementById('stopwatchDisplay');
        const startStopBtn = document.getElementById('startStopBtn');
        const resetStopBtn = document.getElementById('resetStopBtn');
        const lapBtn = document.getElementById('lapBtn');
        const lapsContainer = document.getElementById('lapsContainer');

        function updateStopwatch() {
            const now = Date.now();
            const total = stopwatchElapsed + (now - stopwatchStartTime);

            const hours = Math.floor(total / 3600000);
            const minutes = Math.floor((total % 3600000) / 60000);
            const seconds = Math.floor((total % 60000) / 1000);
            const milliseconds = total % 1000;

            stopwatchDisplay.textContent =
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
        }

        startStopBtn?.addEventListener('click', () => {
            if (!stopwatchRunning) {
                // Start
                stopwatchRunning = true;
                stopwatchStartTime = Date.now();
                startStopBtn.innerHTML = ' Pause';
                startStopBtn.classList.remove('primary');
                stopwatchInterval = setInterval(updateStopwatch, 10);
            } else {
                // Pause
                stopwatchRunning = false;
                stopwatchElapsed += Date.now() - stopwatchStartTime;
                startStopBtn.innerHTML = ' Resume';
                startStopBtn.classList.add('primary');
                clearInterval(stopwatchInterval);
            }
        });

        resetStopBtn?.addEventListener('click', () => {
            stopwatchRunning = false;
            stopwatchElapsed = 0;
            stopwatchStartTime = 0;
            lapCounter = 0;
            stopwatchDisplay.textContent = '00:00:00.000';
            startStopBtn.innerHTML = ' Start';
            startStopBtn.classList.add('primary');
            lapsContainer.innerHTML = '';
            clearInterval(stopwatchInterval);
        });

        lapBtn?.addEventListener('click', () => {
            if (stopwatchRunning || stopwatchElapsed > 0) {
                lapCounter++;
                const lapTime = stopwatchDisplay.textContent;
                const lapDiv = document.createElement('div');
                lapDiv.style.cssText = 'padding:12px 20px;background:rgba(255,255,255,0.05);border-radius:8px;margin-top:10px;display:flex;justify-content:space-between;border-left:3px solid var(--accent)';
                lapDiv.innerHTML = `<span style="font-weight:600;color:var(--accent)">Lap ${lapCounter}</span><span style="font-family:monospace;font-size:18px">${lapTime}</span>`;
                lapsContainer.insertBefore(lapDiv, lapsContainer.firstChild);
            }
        });

        // ========== WORLD TIME ==========
        const worldTimeGrid = document.getElementById('worldTimeGrid');
        const timeZones = [
            { name: 'New York', zone: 'America/New_York', flag: '' },
            { name: 'London', zone: 'Europe/London', flag: '' },
            { name: 'Paris', zone: 'Europe/Paris', flag: '' },
            { name: 'Tokyo', zone: 'Asia/Tokyo', flag: '' },
            { name: 'Sydney', zone: 'Australia/Sydney', flag: '' },
            { name: 'Dubai', zone: 'Asia/Dubai', flag: '' },
            { name: 'Los Angeles', zone: 'America/Los_Angeles', flag: '' },
            { name: 'Mumbai', zone: 'Asia/Kolkata', flag: '' },
            { name: 'Beijing', zone: 'Asia/Shanghai', flag: '' },
            { name: 'Moscow', zone: 'Europe/Moscow', flag: '' },
            { name: 'So Paulo', zone: 'America/Sao_Paulo', flag: '' },
            { name: 'Singapore', zone: 'Asia/Singapore', flag: '' }
        ];

        let worldTimeInterval = null;

        function initWorldTime() {
            worldTimeGrid.innerHTML = '';

            timeZones.forEach(tz => {
                const card = document.createElement('div');
                card.style.cssText = 'background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;border:1px solid rgba(255,255,255,0.1);text-align:center';
                card.innerHTML = `
                    <div style="font-size:32px;margin-bottom:8px">${tz.flag}</div>
                    <div style="font-size:18px;font-weight:600;color:var(--ink);margin-bottom:12px">${tz.name}</div>
                    <div class="world-time-display" data-zone="${tz.zone}" style="font-size:28px;font-weight:800;color:var(--accent);font-family:monospace;margin-bottom:8px">--:--:--</div>
                    <div class="world-date-display" data-zone="${tz.zone}" style="font-size:13px;color:var(--muted)">-- --- ----</div>
                `;
                worldTimeGrid.appendChild(card);
            });

            updateWorldTimes();
            if (worldTimeInterval) clearInterval(worldTimeInterval);
            worldTimeInterval = setInterval(updateWorldTimes, 1000);
        }

        function updateWorldTimes() {
            document.querySelectorAll('.world-time-display').forEach(el => {
                const zone = el.getAttribute('data-zone');
                try {
                    const time = new Date().toLocaleTimeString('en-US', {
                        timeZone: zone,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    el.textContent = time;
                } catch (e) {
                    el.textContent = '--:--:--';
                }
            });

            document.querySelectorAll('.world-date-display').forEach(el => {
                const zone = el.getAttribute('data-zone');
                try {
                    const date = new Date().toLocaleDateString('en-US', {
                        timeZone: zone,
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric'
                    });
                    el.textContent = date;
                } catch (e) {
                    el.textContent = '-- --- ----';
                }
            });
        }

        // ========== SLICE THE PI GAME ==========
        const pieCanvas = document.getElementById('pieCanvas');
        const pieCtx = pieCanvas ? pieCanvas.getContext('2d') : null;
        const pieLevelDisplay = document.getElementById('pieLevel');
        const pieScoreDisplay = document.getElementById('pieScore');
        const pieTargetDisplay = document.getElementById('pieTarget');
        const pieSliceBtn = document.getElementById('pieSliceBtn');
        const pieResetBtn = document.getElementById('pieResetBtn');
        const pieMessage = document.getElementById('pieMessage');

        let pieLevel = 1;
        let pieScore = 0;
        let pieSlices = [];
        let pieTargetSlices = 2;
        let pieCurrentCut = null;
        let pieDrawnLine = null;
        let pieDrawing = false;

        const challenges = [
            { slices: 2, desc: '2 equal slices' },
            { slices: 3, desc: '3 equal slices' },
            { slices: 4, desc: '4 equal slices' },
            { slices: 5, desc: '5 equal slices' },
            { slices: 6, desc: '6 equal slices' },
            { slices: 8, desc: '8 equal slices' },
            { slices: 10, desc: '10 equal slices' },
            { slices: 12, desc: '12 equal slices' },
            { slices: 16, desc: '16 equal slices' },
            { slices: 20, desc: '20 equal slices' }
        ];

        function initSlicePie() {
            pieLevel = 1;
            pieScore = 0;
            pieSlices = [];
            pieDrawnLine = null;
            pieTargetSlices = challenges[0].slices;
            updatePieDisplay();
            drawPie();
        }

        function updatePieDisplay() {
            if (pieLevelDisplay) pieLevelDisplay.textContent = pieLevel;
            if (pieScoreDisplay) pieScoreDisplay.textContent = pieScore;
            if (pieTargetDisplay) {
                const challenge = challenges[Math.min(pieLevel - 1, challenges.length - 1)];
                pieTargetDisplay.textContent = challenge.desc;
                pieTargetSlices = challenge.slices;
            }
        }

        function drawPie() {
            if (!pieCtx) return;

            const centerX = pieCanvas.width / 2;
            const centerY = pieCanvas.height / 2;
            const radius = 180;

            // Clear canvas
            pieCtx.clearRect(0, 0, pieCanvas.width, pieCanvas.height);

            // Draw pie
            pieCtx.fillStyle = '#FFB347';
            pieCtx.beginPath();
            pieCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            pieCtx.fill();

            // Draw crust
            pieCtx.strokeStyle = '#8B4513';
            pieCtx.lineWidth = 6;
            pieCtx.stroke();

            // Draw slice lines
            pieCtx.strokeStyle = 'rgba(139,69,19,0.5)';
            pieCtx.lineWidth = 2;
            pieSlices.forEach(angle => {
                pieCtx.beginPath();
                pieCtx.moveTo(centerX, centerY);
                const endX = centerX + Math.cos(angle) * radius;
                const endY = centerY + Math.sin(angle) * radius;
                pieCtx.lineTo(endX, endY);
                pieCtx.stroke();
            });

            // Draw drawn line (if exists)
            if (pieDrawnLine) {
                pieCtx.strokeStyle = '#00ff00';
                pieCtx.lineWidth = 3;
                pieCtx.setLineDash([5, 5]);
                pieCtx.beginPath();
                pieCtx.moveTo(pieDrawnLine.startX, pieDrawnLine.startY);
                pieCtx.lineTo(pieDrawnLine.endX, pieDrawnLine.endY);
                pieCtx.stroke();
                pieCtx.setLineDash([]);
            }

            // Draw knife cursor (follows mouse)
            if (pieCurrentCut) {
                // Draw knife blade
                pieCtx.strokeStyle = '#C0C0C0';
                pieCtx.lineWidth = 4;
                pieCtx.beginPath();
                pieCtx.moveTo(pieCurrentCut.x - 20, pieCurrentCut.y - 20);
                pieCtx.lineTo(pieCurrentCut.x + 15, pieCurrentCut.y + 15);
                pieCtx.stroke();

                // Draw knife edge highlight
                pieCtx.strokeStyle = '#FFFFFF';
                pieCtx.lineWidth = 2;
                pieCtx.beginPath();
                pieCtx.moveTo(pieCurrentCut.x - 20, pieCurrentCut.y - 20);
                pieCtx.lineTo(pieCurrentCut.x + 15, pieCurrentCut.y + 15);
                pieCtx.stroke();

                // Draw knife handle
                pieCtx.fillStyle = '#8B4513';
                pieCtx.beginPath();
                pieCtx.arc(pieCurrentCut.x - 25, pieCurrentCut.y - 25, 8, 0, Math.PI * 2);
                pieCtx.fill();
                pieCtx.strokeStyle = '#654321';
                pieCtx.lineWidth = 2;
                pieCtx.stroke();
            }
        }

        function animateCutAlongLine(line, angle) {
            // Create explosion particles along the drawn line
            const numExplosions = 15;
            let currentExplosion = 0;

            const explosionInterval = setInterval(() => {
                if (currentExplosion >= numExplosions) {
                    clearInterval(explosionInterval);
                    pieSlices.push(angle);
                    pieSlices.sort((a, b) => a - b);

                    // Check if we have enough slices
                    if (pieSlices.length === pieTargetSlices) {
                        setTimeout(() => checkSlices(), 200);
                    }

                    drawPie();
                    return;
                }

                // Calculate position along the drawn line
                const progress = currentExplosion / numExplosions;
                const explosionX = line.startX + (line.endX - line.startX) * progress;
                const explosionY = line.startY + (line.endY - line.startY) * progress;

                // Draw explosion
                drawExplosion(explosionX, explosionY);

                currentExplosion++;
            }, 40);
        }

        function drawExplosion(x, y) {
            if (!pieCtx) return;

            // Redraw pie first
            drawPie();

            // Draw explosion particles
            const particles = 8;
            for (let i = 0; i < particles; i++) {
                const angle = (Math.PI * 2 * i) / particles;
                const distance = Math.random() * 15 + 10;
                const px = x + Math.cos(angle) * distance;
                const py = y + Math.sin(angle) * distance;

                pieCtx.fillStyle = `hsl(${Math.random() * 60 + 20}, 100%, 50%)`;
                pieCtx.beginPath();
                pieCtx.arc(px, py, Math.random() * 4 + 2, 0, Math.PI * 2);
                pieCtx.fill();
            }

            // Draw bright flash at center
            const gradient = pieCtx.createRadialGradient(x, y, 0, x, y, 20);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            pieCtx.fillStyle = gradient;
            pieCtx.beginPath();
            pieCtx.arc(x, y, 20, 0, Math.PI * 2);
            pieCtx.fill();
        }

        if (pieCanvas) {
            pieCanvas.addEventListener('mousedown', (e) => {
                const rect = pieCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                pieDrawing = true;
                pieDrawnLine = { startX: x, startY: y, endX: x, endY: y };
                drawPie();
            });

            pieCanvas.addEventListener('mousemove', (e) => {
                const rect = pieCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                pieCurrentCut = { x, y };

                if (pieDrawing && pieDrawnLine) {
                    pieDrawnLine.endX = x;
                    pieDrawnLine.endY = y;
                }

                drawPie();
            });

            pieCanvas.addEventListener('mouseup', () => {
                pieDrawing = false;
            });

            pieCanvas.addEventListener('mouseleave', () => {
                pieCurrentCut = null;
                pieDrawing = false;
                drawPie();
            });
        }

        pieSliceBtn?.addEventListener('click', () => {
            if (!pieDrawnLine) {
                pieMessage.textContent = 'Draw a line on the pie first!';
                pieMessage.style.color = '#ff9900';
                setTimeout(() => { pieMessage.textContent = ''; }, 2000);
                return;
            }

            const centerX = pieCanvas.width / 2;
            const centerY = pieCanvas.height / 2;

            // Calculate angle based on the drawn line (average of start and end points)
            const midX = (pieDrawnLine.startX + pieDrawnLine.endX) / 2;
            const midY = (pieDrawnLine.startY + pieDrawnLine.endY) / 2;
            const angle = Math.atan2(midY - centerY, midX - centerX);

            // Animate the cut with explosions along the drawn line
            animateCutAlongLine(pieDrawnLine, angle);
            pieDrawnLine = null;
        });

        function checkSlices() {
            // Calculate angles between slices
            const angles = [];
            for (let i = 0; i < pieSlices.length; i++) {
                const next = (i + 1) % pieSlices.length;
                let diff = pieSlices[next] - pieSlices[i];
                if (diff < 0) diff += Math.PI * 2;
                angles.push(diff);
            }

            // Check if all angles are approximately equal
            const targetAngle = (Math.PI * 2) / pieTargetSlices;
            const tolerance = 0.15; // Tolerance in radians

            const allEqual = angles.every(angle =>
                Math.abs(angle - targetAngle) < tolerance
            );

            if (allEqual) {
                pieScore += pieLevel * 10;
                pieLevel++;
                pieMessage.textContent = ' Perfect! Moving to next level...';
                pieMessage.style.color = '#00ff00';

                setTimeout(() => {
                    pieSlices = [];
                    pieMessage.textContent = '';
                    updatePieDisplay();
                    drawPie();
                }, 1500);
            } else {
                pieMessage.textContent = ' Not equal slices! Game Over. Final Score: ' + pieScore;
                pieMessage.style.color = '#ff0000';
                setTimeout(() => {
                    initSlicePie();
                    pieMessage.textContent = '';
                }, 3000);
            }
        }

        pieResetBtn?.addEventListener('click', () => {
            pieSlices = [];
            pieDrawnLine = null;
            drawPie();
            pieMessage.textContent = '';
        });

        // ========== RAINBOW CHAOS TIMER ==========
        const rainbowTimerBtn = document.getElementById('rainbowTimerBtn');
        const timerModal = document.getElementById('timerModal');
        const timerDisplay = document.getElementById('timerDisplay');
        const timerInput = document.getElementById('timerInput');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const closeTimerBtn = document.getElementById('closeTimerBtn');

        let timerInterval = null;
        let timeRemaining = 0;

        rainbowTimerBtn?.addEventListener('click', () => {
            // Sync max duration from settings
            const durationSetting = document.getElementById('chaosTimerDuration');
            if (durationSetting && timerInput) {
                timerInput.max = durationSetting.value;
            }
            timerModal.classList.add('active');
        });

        closeTimerBtn?.addEventListener('click', () => {
            timerModal.classList.remove('active');
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        });

        startTimerBtn?.addEventListener('click', () => {
            // Get duration from settings or use input
            const durationSetting = document.getElementById('chaosTimerDuration');
            const maxDuration = durationSetting ? parseInt(durationSetting.value) : 2000;

            const seconds = parseInt(timerInput.value);
            if (seconds < 1 || seconds > maxDuration) {
                alert(`Please enter a time between 1 and ${maxDuration} seconds!`);
                return;
            }

            timeRemaining = seconds;
            timerDisplay.classList.add('timerRunning');
            updateTimerDisplay();

            if (timerInterval) clearInterval(timerInterval);

            timerInterval = setInterval(() => {
                timeRemaining--;
                updateTimerDisplay();

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    timerDisplay.classList.remove('timerRunning');
                    triggerChaos();
                }
            }, 1000);
        });

        function updateTimerDisplay() {
            const mins = Math.floor(timeRemaining / 60);
            const secs = timeRemaining % 60;
            timerDisplay.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        // Snake screen cut effect
        let screenIsCut = false;

        function createSnakeCut() {
            if (screenIsCut) return; // Already cut

            // Create snake element
            const snake = document.createElement('div');
            snake.style.position = 'fixed';
            snake.style.left = '-100px';
            snake.style.top = '50%';
            snake.style.transform = 'translateY(-50%)';
            snake.style.width = '80px';
            snake.style.height = '20px';
            snake.style.background = 'linear-gradient(90deg, #00ff00, #00aa00, #006600)';
            snake.style.borderRadius = '10px';
            snake.style.zIndex = '99999';
            snake.style.boxShadow = '0 0 20px #00ff00, inset 0 0 10px #00ff00';
            snake.style.transition = 'left 2s linear';
            document.body.appendChild(snake);

            // Animate snake across screen
            setTimeout(() => {
                snake.style.left = 'calc(100% + 100px)';
            }, 50);

            // Cut the screen after snake passes
            setTimeout(() => {
                // Remove snake
                snake.remove();

                // Split screen into top and bottom
                document.body.style.position = 'relative';
                document.body.style.overflow = 'hidden';

                const topHalf = document.createElement('div');
                topHalf.id = 'screen-cut-top';
                topHalf.style.position = 'fixed';
                topHalf.style.top = '0';
                topHalf.style.left = '0';
                topHalf.style.width = '100%';
                topHalf.style.height = '50%';
                topHalf.style.borderBottom = '3px solid red';
                topHalf.style.boxShadow = '0 5px 20px rgba(255,0,0,0.8)';
                topHalf.style.clipPath = 'polygon(0 0, 100% 0, 100% 100%, 0 100%)';
                topHalf.style.zIndex = '9997';
                topHalf.style.pointerEvents = 'none';
                topHalf.style.animation = 'screen-shake 0.5s infinite';

                const bottomHalf = document.createElement('div');
                bottomHalf.id = 'screen-cut-bottom';
                bottomHalf.style.position = 'fixed';
                bottomHalf.style.top = '50%';
                bottomHalf.style.left = '0';
                bottomHalf.style.width = '100%';
                bottomHalf.style.height = '50%';
                bottomHalf.style.borderTop = '3px solid red';
                bottomHalf.style.boxShadow = '0 -5px 20px rgba(255,0,0,0.8)';
                bottomHalf.style.clipPath = 'polygon(0 0, 100% 0, 100% 100%, 0 100%)';
                bottomHalf.style.zIndex = '9997';
                bottomHalf.style.pointerEvents = 'none';
                bottomHalf.style.animation = 'screen-shake 0.5s infinite';

                document.body.appendChild(topHalf);
                document.body.appendChild(bottomHalf);

                screenIsCut = true;

                // Show recovery message
                const message = document.createElement('div');
                message.style.position = 'fixed';
                message.style.top = '50%';
                message.style.left = '50%';
                message.style.transform = 'translate(-50%, -50%)';
                message.style.background = 'rgba(255,0,0,0.9)';
                message.style.color = 'white';
                message.style.padding = '20px 40px';
                message.style.borderRadius = '15px';
                message.style.fontSize = '24px';
                message.style.fontWeight = 'bold';
                message.style.zIndex = '99998';
                message.style.boxShadow = '0 0 30px rgba(255,0,0,0.8)';
                message.style.animation = 'chaos-flip 1s infinite';
                message.textContent = 'SCREEN CUT! Press Ctrl+G or Cmd+G to recover!';
                document.body.appendChild(message);

                setTimeout(() => message.remove(), 5000);
            }, 2100);
        }

        // Keyboard handler for Ctrl+G or Cmd+G recovery
        document.addEventListener('keydown', function (e) {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'g') {
                if (!screenIsCut) return;

                e.preventDefault();

                // Remove cut elements
                const topHalf = document.getElementById('screen-cut-top');
                const bottomHalf = document.getElementById('screen-cut-bottom');

                if (topHalf) topHalf.remove();
                if (bottomHalf) bottomHalf.remove();

                screenIsCut = false;

                // Show recovery effect
                const recoveryFlash = document.createElement('div');
                recoveryFlash.style.position = 'fixed';
                recoveryFlash.style.top = '0';
                recoveryFlash.style.left = '0';
                recoveryFlash.style.width = '100%';
                recoveryFlash.style.height = '100%';
                recoveryFlash.style.background = 'linear-gradient(180deg, rgba(0,255,0,0.7), rgba(0,200,0,0.7))';
                recoveryFlash.style.zIndex = '99998';
                recoveryFlash.style.pointerEvents = 'none';
                recoveryFlash.style.animation = 'fade-out 1s forwards';
                document.body.appendChild(recoveryFlash);

                // Show success message
                const message = document.createElement('div');
                message.style.position = 'fixed';
                message.style.top = '50%';
                message.style.left = '50%';
                message.style.transform = 'translate(-50%, -50%)';
                message.style.background = 'rgba(0,255,0,0.9)';
                message.style.color = 'white';
                message.style.padding = '30px 60px';
                message.style.borderRadius = '20px';
                message.style.fontSize = '36px';
                message.style.fontWeight = 'bold';
                message.style.zIndex = '99999';
                message.style.boxShadow = '0 0 40px rgba(0,255,0,0.9)';
                message.style.animation = 'chaos-zoom 0.5s ease-out';
                message.textContent = ' RECOVERED!';
                document.body.appendChild(message);

                // Play success sound
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance('Screen recovered!');
                    utterance.rate = 1.2;
                    utterance.pitch = 1.5;
                    speechSynthesis.speak(utterance);
                }

                setTimeout(() => {
                    recoveryFlash.remove();
                    message.remove();

                    // Clean up timer and return to game center
                    const timerModal = document.getElementById('timerModal');
                    if (timerModal) {
                        timerModal.classList.remove('active');
                    }
                    const timerDisplay = document.getElementById('timerDisplay');
                    if (timerDisplay) {
                        timerDisplay.textContent = '00:00';
                    }

                    // Remove all chaos effects from body
                    document.body.classList.remove('chaos-spin', 'chaosSpin', 'chaosFlip', 'chaosRainbow', 'chaosShake', 'chaosZoom', 'chaos-glitch', 'chaos-bounce', 'chaos-skew', 'chaos-blur', 'chaos-pixelate');
                    document.body.style.filter = '';
                    document.body.style.background = '';
                    document.body.style.transform = '';
                    document.body.style.opacity = '';
                    document.body.style.transition = '';
                    document.body.style.animation = '';

                    // Remove explosion overlay if it exists
                    const explosionOverlay = document.querySelector('.explosion-overlay');
                    if (explosionOverlay) {
                        explosionOverlay.remove();
                    }

                    // Show game center
                    showView('gameCenter');
                }, 1000);
            }
        });

        // Helper function to check if effect is enabled
        function isEffectEnabled(effectName) {
            const checkbox = document.getElementById(effectName) || document.getElementById(effectName + 'Calc');
            return checkbox ? checkbox.checked : true;
        }

        function triggerChaos() {
            // Get configured duration before snake cut
            const snakeCutDelay = parseInt(document.getElementById('snakeCutDelay')?.value || document.getElementById('snakeCutDelayCalc')?.value || 60);
            const snakeCutDelayMs = snakeCutDelay * 1000; // Convert to milliseconds

            let effectsInterval;
            const startTime = Date.now();

            // Continuous effects loop
            function runEffects() {
                const elapsed = Date.now() - startTime;

                // Check if it's time for snake cut
                if (elapsed >= snakeCutDelayMs && isEffectEnabled('enableScreenCut')) {
                    clearInterval(effectsInterval);
                    // Trigger snake cut
                    setTimeout(() => {
                        createSnakeCut();
                    }, 300);
                    return;
                }

                // Random chaos effect - build effects array based on enabled settings
                const effects = [];

                // Add SPIN as a frequent pulsing effect - spins fast then takes a break
                if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enableChaosEffects')) {
                    effects.push(
                        () => {
                            // SPIN PULSE - fast spin then stops
                            document.body.classList.add('chaos-spin');
                            setTimeout(() => document.body.classList.remove('chaos-spin'), 500);
                        },
                        () => {
                            // SPIN PULSE (duplicate for higher frequency)
                            document.body.classList.add('chaos-spin');
                            setTimeout(() => document.body.classList.remove('chaos-spin'), 500);
                        },
                        () => {
                            // SPIN PULSE (triple for even more spin occurrences)
                            document.body.classList.add('chaos-spin');
                            setTimeout(() => document.body.classList.remove('chaos-spin'), 500);
                        }
                    );
                }

                // Add other visual effects based on settings
                if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enableChaosEffects')) {
                    effects.push(
                        () => {
                            // 1. Rainbow background
                            document.body.style.background = `linear-gradient(${Math.random() * 360}deg, red, orange, yellow, green, blue, indigo, violet)`;
                            setTimeout(() => { document.body.style.background = ''; }, 500);
                        },
                        () => {
                            // 2. Flip
                            document.body.classList.add('chaos-flip');
                            setTimeout(() => document.body.classList.remove('chaos-flip'), 500);
                        },
                        () => {
                            // 3. Rainbow filter + Shake
                            document.body.classList.add('chaos-rainbow', 'chaos-shake');
                            setTimeout(() => document.body.classList.remove('chaos-rainbow', 'chaos-shake'), 300);
                        },
                        () => {
                            // 4. Zoom
                            document.body.classList.add('chaos-zoom');
                            setTimeout(() => document.body.classList.remove('chaos-zoom'), 400);
                        },
                        () => {
                            // 5. GLITCH EFFECT
                            document.body.classList.add('chaos-glitch');
                            setTimeout(() => document.body.classList.remove('chaos-glitch'), 300);
                        },
                        () => {
                            // 6. BOUNCE
                            document.body.classList.add('chaos-bounce');
                            setTimeout(() => document.body.classList.remove('chaos-bounce'), 500);
                        },
                        () => {
                            // 7. SKEW
                            document.body.classList.add('chaos-skew');
                            setTimeout(() => document.body.classList.remove('chaos-skew'), 400);
                        },
                        () => {
                            // 8. BLUR
                            document.body.classList.add('chaos-blur');
                            setTimeout(() => document.body.classList.remove('chaos-blur'), 500);
                        },
                        () => {
                            // 9. PIXELATE
                            document.body.classList.add('chaos-pixelate');
                            setTimeout(() => document.body.classList.remove('chaos-pixelate'), 425);
                        },
                        () => {
                            // 10. TRIPLE CHAOS: Shake + Flip + Rainbow
                            document.body.classList.add('chaos-shake', 'chaos-flip', 'chaos-rainbow');
                            setTimeout(() => document.body.classList.remove('chaos-shake', 'chaos-flip', 'chaos-rainbow'), 500);
                        },
                        () => {
                            // 11. Random canvas fireworks
                            if (drawCanvas && drawCtx) {
                                for (let i = 0; i < 50; i++) {
                                    const x = Math.random() * drawCanvas.width;
                                    const y = Math.random() * drawCanvas.height;
                                    const radius = Math.random() * 20 + 10;
                                    const hue = Math.random() * 360;
                                    drawCtx.beginPath();
                                    drawCtx.arc(x, y, radius, 0, Math.PI * 2);
                                    drawCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                                    drawCtx.globalAlpha = 0.7;
                                    drawCtx.fill();
                                }
                                drawCtx.globalAlpha = 1;
                            }
                        },
                        () => {
                            // 12. Invert colors + Shake
                            document.body.style.filter = 'invert(1) hue-rotate(180deg)';
                            document.body.classList.add('chaos-shake');
                            setTimeout(() => {
                                document.body.style.filter = '';
                                document.body.classList.remove('chaos-shake');
                            }, 400);
                        },
                        () => {
                            // 13. Explosion overlay
                            const overlay = document.createElement('div');
                            overlay.style.position = 'fixed';
                            overlay.style.inset = '0';
                            overlay.style.background = `radial-gradient(circle, transparent 0%, hsl(${Math.random() * 360}, 100%, 50%) 100%)`;
                            overlay.style.pointerEvents = 'none';
                            overlay.style.zIndex = '999999';
                            overlay.style.animation = 'chaosZoom 0.5s ease-out';
                            document.body.appendChild(overlay);
                            setTimeout(() => overlay.remove(), 500);
                        },
                        () => {
                            // 14. EXTREME COMBO: All effects at once!
                            document.body.classList.add('chaos-shake', 'chaos-glitch', 'chaos-rainbow');
                            document.body.style.filter = 'contrast(2) saturate(3)';
                            setTimeout(() => {
                                document.body.classList.remove('chaos-shake', 'chaos-glitch', 'chaos-rainbow');
                                document.body.style.filter = '';
                            }, 600);
                        }
                    );
                }

                // Poop sounds
                if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enablePoopSounds')) {
                    effects.push(() => {
                        const utterance = new SpeechSynthesisUtterance('Poop!');
                        utterance.rate = 0.5;
                        utterance.pitch = 0.1;
                        speechSynthesis.speak(utterance);
                    });
                }

                // 90db sound
                if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enable90dbSound')) {
                    effects.push(() => {
                        const utterance = new SpeechSynthesisUtterance(`EXPLOSION ${explosionCount}!`);
                        utterance.rate = 3;
                        utterance.pitch = 2;
                        utterance.volume = 1;
                        speechSynthesis.speak(utterance);
                    });
                }

                // Elements jumping out
                if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enableElementsJump')) {
                    const jumpCount = parseInt(document.getElementById('elementsJumpCount')?.value || document.getElementById('elementsJumpCountCalc')?.value || 10);
                    for (let j = 0; j < Math.min(jumpCount, 5); j++) {
                        effects.push(() => {
                            const elements = document.querySelectorAll('button, .gameCard, .calc, h1, h2');
                            if (elements.length > 0) {
                                const elem = elements[Math.floor(Math.random() * elements.length)];
                                const originalTransform = elem.style.transform;
                                elem.style.transition = 'transform 0.3s ease-out';
                                elem.style.transform = `translate(${Math.random() * 200 - 100}px, ${Math.random() * 200 - 100}px) rotate(${Math.random() * 360}deg) scale(${Math.random() + 0.5})`;
                                setTimeout(() => {
                                    elem.style.transform = originalTransform;
                                    elem.style.transition = '';
                                }, 300);
                            }
                        });
                    }
                }

                // Trigger 2-3 random effects
                const numEffects = Math.floor(Math.random() * 2) + 2;
                for (let i = 0; i < numEffects; i++) {
                    const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                    randomEffect();
                }
            }

            // Start effects loop - runs every 200ms
            effectsInterval = setInterval(runEffects, 200);
            runEffects(); // Run immediately
        }

        function triggerFinalExplosion() {
            // Create screen shatter effect (if enabled)
            if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enableScreenExplosion')) {
                createScreenShatter();
            }

            // Screen cut in half effect
            if (isEffectEnabled('enableAllEffects') && isEffectEnabled('enableScreenCut')) {
                setTimeout(() => {
                    const cutLine = document.createElement('div');
                    cutLine.style.cssText = 'position:fixed;top:50%;left:0;right:0;height:4px;background:red;z-index:9999999;box-shadow:0 0 20px red';
                    document.body.appendChild(cutLine);

                    document.body.style.clipPath = 'polygon(0 0, 100% 0, 100% 50%, 0 50%)';
                    setTimeout(() => {
                        document.body.style.clipPath = 'polygon(0 50%, 100% 50%, 100% 100%, 0 100%)';
                        setTimeout(() => {
                            document.body.style.clipPath = '';
                            cutLine.remove();
                        }, 300);
                    }, 300);
                }, 200);
            }

            const utterance = new SpeechSynthesisUtterance('Maximum chaos level 5 complete!');
            utterance.rate = 1.5;
            utterance.pitch = 2;
            speechSynthesis.speak(utterance);

            setTimeout(() => {
                // Remove shatter and bring screen back
                const shatterContainer = document.getElementById('shatterContainer');
                if (shatterContainer) {
                    shatterContainer.remove();
                }

                // Start rapid color flashing
                let flashCount = 0;
                const colors = ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0000ff', '#9400ff', '#ff00ff'];
                const flashInterval = setInterval(() => {
                    flashCount++;
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];
                    document.body.style.filter = `hue-rotate(${Math.random() * 360}deg) saturate(3)`;
                    document.body.style.background = randomColor;

                    if (flashCount >= 12) {
                        clearInterval(flashInterval);

                        // Cover screen with rainbow glitter
                        createRainbowGlitter();

                        // After glitter, cut the screen with snake!
                        setTimeout(() => {
                            // Remove glitter first
                            const glitterContainer = document.getElementById('glitterContainer');
                            if (glitterContainer) {
                                glitterContainer.remove();
                            }

                            // SNAKE CUTS SCREEN after particles!
                            if (isEffectEnabled('enableScreenCut')) {
                                createSnakeCut();

                                // Don't auto-close - wait for user to press Ctrl+G or Cmd+G
                                // Screen stays cut until they recover it manually
                            } else {
                                // If screen cut disabled, clean up and close
                                setTimeout(() => {
                                    timerModal.classList.remove('active');
                                    timerDisplay.textContent = '00:00';

                                    // Remove all chaos effects from body
                                    document.body.classList.remove('chaos-spin', 'chaosSpin', 'chaosFlip', 'chaosRainbow', 'chaosShake', 'chaosZoom', 'chaos-glitch', 'chaos-bounce', 'chaos-skew', 'chaos-blur', 'chaos-pixelate');
                                    document.body.style.filter = '';
                                    document.body.style.background = '';
                                    document.body.style.transform = '';
                                    document.body.style.opacity = '';
                                    document.body.style.transition = '';
                                    document.body.style.animation = '';

                                    // Remove explosion overlay if it exists
                                    const explosionOverlay = document.querySelector('.explosion-overlay');
                                    if (explosionOverlay) {
                                        explosionOverlay.remove();
                                    }

                                    // Show game center
                                    showView('gameCenter');
                                }, 200);
                            }
                        }, 1800);
                    }
                }, 100); // Flash every 100ms
            }, 800);
        }

        function createScreenShatter() {
            // Create loud shatter sound effect
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const duration = 0.5;
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(2, duration * sampleRate, sampleRate);

            // Generate glass breaking sound with high volume
            for (let channel = 0; channel < 2; channel++) {
                const data = buffer.getChannelData(channel);
                for (let i = 0; i < data.length; i++) {
                    // Mix of high frequency noise and crackling
                    const noise = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.1));
                    const crackle = Math.sin(i * 0.1) * Math.random() * Math.exp(-i / (sampleRate * 0.2));
                    data[i] = (noise + crackle) * 1.0; // Maximum amplitude
                }
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 1.0; // Maximum volume for ~60 dB
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();

            const shatterContainer = document.createElement('div');
            shatterContainer.id = 'shatterContainer';
            shatterContainer.style.position = 'fixed';
            shatterContainer.style.inset = '0';
            shatterContainer.style.zIndex = '9999999';
            shatterContainer.style.pointerEvents = 'none';
            document.body.appendChild(shatterContainer);

            // Create 30 screen pieces
            const pieces = 30;
            const cols = 6;
            const rows = 5;
            const pieceWidth = 100 / cols;
            const pieceHeight = 100 / rows;

            for (let i = 0; i < pieces; i++) {
                const piece = document.createElement('div');
                const col = i % cols;
                const row = Math.floor(i / cols);

                piece.style.position = 'absolute';
                piece.style.left = col * pieceWidth + '%';
                piece.style.top = row * pieceHeight + '%';
                piece.style.width = pieceWidth + '%';
                piece.style.height = pieceHeight + '%';
                piece.style.background = `linear-gradient(${Math.random() * 360}deg, rgba(255,255,255,0.3), rgba(0,0,0,0.3))`;
                piece.style.border = '2px solid rgba(255,255,255,0.5)';
                piece.style.backdropFilter = 'blur(5px)';
                piece.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';

                // Random explosion direction
                const angle = Math.random() * Math.PI * 2;
                const distance = 300 + Math.random() * 500;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                const rotation = Math.random() * 720 - 360;

                piece.style.animation = `shatterPiece 0.8s ease-out forwards`;
                piece.style.setProperty('--tx', tx + 'px');
                piece.style.setProperty('--ty', ty + 'px');
                piece.style.setProperty('--rotation', rotation + 'deg');

                shatterContainer.appendChild(piece);
            }

            // Add shatter animation
            if (!document.getElementById('shatterStyles')) {
                const style = document.createElement('style');
                style.id = 'shatterStyles';
                style.textContent = `
                    @keyframes shatterPiece {
                        0% {
                            transform: translate(0, 0) rotate(0deg);
                            opacity: 1;
                        }
                        100% {
                            transform: translate(var(--tx), var(--ty)) rotate(var(--rotation));
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function createRainbowGlitter() {
            const glitterContainer = document.createElement('div');
            glitterContainer.id = 'glitterContainer';
            glitterContainer.style.position = 'fixed';
            glitterContainer.style.inset = '0';
            glitterContainer.style.pointerEvents = 'none';
            glitterContainer.style.zIndex = '999999';
            glitterContainer.style.overflow = 'hidden';
            document.body.appendChild(glitterContainer);

            // Create 200 glitter particles
            for (let i = 0; i < 200; i++) {
                const glitter = document.createElement('div');
                glitter.className = 'glitter-particle';
                glitter.style.position = 'absolute';
                glitter.style.left = Math.random() * 100 + '%';
                glitter.style.top = Math.random() * 100 + '%';
                glitter.style.width = Math.random() * 8 + 4 + 'px';
                glitter.style.height = glitter.style.width;
                glitter.style.borderRadius = '50%';
                glitter.style.background = `hsl(${Math.random() * 360}, 100%, 60%)`;
                glitter.style.animation = `glitterFloat ${Math.random() * 3 + 2}s ease-in-out infinite, glitterColor ${Math.random() * 2 + 1}s linear infinite`;
                glitter.style.boxShadow = '0 0 10px currentColor';
                glitter.style.animationDelay = `${Math.random() * 2}s`;
                glitterContainer.appendChild(glitter);
            }

            // Add glitter animations to page
            if (!document.getElementById('glitterStyles')) {
                const style = document.createElement('style');
                style.id = 'glitterStyles';
                style.textContent = `
                    @keyframes glitterFloat {
                        0%, 100% { transform: translate(0, 0) rotate(0deg); }
                        25% { transform: translate(20px, -20px) rotate(90deg); }
                        50% { transform: translate(-20px, 20px) rotate(180deg); }
                        75% { transform: translate(20px, 20px) rotate(270deg); }
                    }
                    @keyframes glitterColor {
                        0% { filter: hue-rotate(0deg) brightness(1.5); }
                        50% { filter: hue-rotate(180deg) brightness(2); }
                        100% { filter: hue-rotate(360deg) brightness(1.5); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Glitter will be removed by timer completion logic after 3 seconds
        }

        // ========== MATH PRACTICE GAME ==========
        if (practiceView) {
            const ageInput = practiceView.querySelector('#ageInput');
            const numProblems = practiceView.querySelector('#numProblems');
            const generateProblemsBtn = practiceView.querySelector('#generateProblemsBtn');
            const practiceArea = practiceView.querySelector('#practiceArea');
            const problemsList = practiceView.querySelector('#problemsList');
            const checkAllAnswersBtn = practiceView.querySelector('#checkAllAnswersBtn');
            const generateNewProblemsBtn = practiceView.querySelector('#generateNewProblemsBtn');
            const practiceFeedback = practiceView.querySelector('#practiceFeedback');

            let currentProblems = [];

            function generateProblems() {
                const age = parseInt(ageInput.value);
                const count = parseInt(numProblems.value);

                if (age < 3 || age > 50) {
                    showPracticeFeedback('Please enter an age between 3 and 50!', 'wrong');
                    return;
                }

                if (count < 1 || count > 20) {
                    showPracticeFeedback('Please enter between 1 and 20 problems!', 'wrong');
                    return;
                }

                // Generate problems based on age difficulty
                currentProblems = [];
                problemsList.innerHTML = '';

                for (let i = 0; i < count; i++) {
                    const problem = generateProblemByAge(age);
                    currentProblems.push(problem);

                    const problemDiv = document.createElement('div');
                    problemDiv.className = 'settingGroup';
                    problemDiv.innerHTML = `
                        <label style="font-size: 16px; min-width: 250px;">${i + 1}. ${problem.question}</label>
                        <input type="text" class="guessInput" data-idx="${i}" placeholder="Your answer" style="width: 150px;" />
                        <span class="feedback" data-idx="${i}"></span>
                    `;
                    problemsList.appendChild(problemDiv);
                }

                practiceArea.style.display = 'block';
                showPracticeFeedback('Problems generated! Solve them and check your answers.', 'hint');
            }

            function generateProblemByAge(age) {
                // AI-inspired difficulty scaling based on age
                let num1, num2, operation, answer, question;

                if (age >= 3 && age <= 6) {
                    // Simple addition and subtraction (1-10)
                    num1 = Math.floor(Math.random() * 10) + 1;
                    num2 = Math.floor(Math.random() * 10) + 1;
                    operation = Math.random() < 0.5 ? '+' : '-';
                    if (operation === '+') {
                        answer = num1 + num2;
                        question = `${num1} + ${num2} = ?`;
                    } else {
                        if (num1 < num2) [num1, num2] = [num2, num1];
                        answer = num1 - num2;
                        question = `${num1} - ${num2} = ?`;
                    }
                } else if (age >= 7 && age <= 10) {
                    // Addition, subtraction, simple multiplication (1-20)
                    num1 = Math.floor(Math.random() * 20) + 1;
                    num2 = Math.floor(Math.random() * 12) + 1;
                    const ops = ['+', '-', ''];
                    operation = ops[Math.floor(Math.random() * ops.length)];

                    if (operation === '+') {
                        answer = num1 + num2;
                        question = `${num1} + ${num2} = ?`;
                    } else if (operation === '-') {
                        if (num1 < num2) [num1, num2] = [num2, num1];
                        answer = num1 - num2;
                        question = `${num1} - ${num2} = ?`;
                    } else {
                        answer = num1 * num2;
                        question = `${num1}  ${num2} = ?`;
                    }
                } else if (age >= 11 && age <= 14) {
                    // All four operations, larger numbers
                    num1 = Math.floor(Math.random() * 50) + 10;
                    num2 = Math.floor(Math.random() * 20) + 1;
                    const ops = ['+', '-', '', ''];
                    operation = ops[Math.floor(Math.random() * ops.length)];

                    if (operation === '+') {
                        answer = num1 + num2;
                        question = `${num1} + ${num2} = ?`;
                    } else if (operation === '-') {
                        answer = num1 - num2;
                        question = `${num1} - ${num2} = ?`;
                    } else if (operation === '') {
                        answer = num1 * num2;
                        question = `${num1}  ${num2} = ?`;
                    } else {
                        const dividend = num1 * num2;
                        answer = num1;
                        question = `${dividend}  ${num2} = ?`;
                    }
                } else if (age >= 15 && age <= 20) {
                    // Algebra, fractions, percentages
                    const types = ['algebra', 'fraction', 'percent'];
                    const type = types[Math.floor(Math.random() * types.length)];

                    if (type === 'algebra') {
                        num1 = Math.floor(Math.random() * 10) + 1;
                        num2 = Math.floor(Math.random() * 20) + 5;
                        answer = num2 - num1;
                        question = `Solve for x: ${num1} + x = ${num2}`;
                    } else if (type === 'fraction') {
                        num1 = Math.floor(Math.random() * 5) + 1;
                        num2 = Math.floor(Math.random() * 5) + 1;
                        answer = (num1 / 2 + num2 / 3).toFixed(2);
                        question = `${num1}/2 + ${num2}/3 = ? (round to 2 decimals)`;
                    } else {
                        num1 = Math.floor(Math.random() * 100) + 50;
                        num2 = Math.floor(Math.random() * 30) + 10;
                        answer = Math.round((num1 * num2) / 100);
                        question = `What is ${num2}% of ${num1}?`;
                    }
                } else {
                    // Advanced (21-50): Complex algebra, trigonometry, calculus
                    const types = ['quadratic', 'trig', 'exponent'];
                    const type = types[Math.floor(Math.random() * types.length)];

                    if (type === 'quadratic') {
                        num1 = Math.floor(Math.random() * 5) + 1;
                        num2 = Math.floor(Math.random() * 10) + 5;
                        answer = Math.sqrt(num2 / num1).toFixed(2);
                        question = `Solve for x: ${num1}x = ${num2} (positive root, 2 decimals)`;
                    } else if (type === 'trig') {
                        const angles = [0, 30, 45, 60, 90];
                        const angle = angles[Math.floor(Math.random() * angles.length)];
                        const funcs = ['sin', 'cos', 'tan'];
                        const func = funcs[Math.floor(Math.random() * funcs.length)];

                        if (func === 'sin') answer = Math.sin(angle * Math.PI / 180).toFixed(2);
                        else if (func === 'cos') answer = Math.cos(angle * Math.PI / 180).toFixed(2);
                        else answer = angle === 90 ? 'undefined' : Math.tan(angle * Math.PI / 180).toFixed(2);

                        question = `${func}(${angle}) = ? (2 decimals)`;
                    } else {
                        num1 = Math.floor(Math.random() * 5) + 2;
                        num2 = Math.floor(Math.random() * 4) + 2;
                        answer = Math.pow(num1, num2);
                        question = `${num1}^${num2} = ?`;
                    }
                }

                return { question, answer: String(answer) };
            }

            function checkAllAnswers() {
                let correct = 0;
                let total = currentProblems.length;

                currentProblems.forEach((problem, idx) => {
                    const input = practiceArea.querySelector(`input[data-idx="${idx}"]`);
                    const feedback = practiceArea.querySelector(`span[data-idx="${idx}"]`);
                    const userAnswer = input.value.trim();

                    if (userAnswer === problem.answer) {
                        feedback.textContent = ' Correct!';
                        feedback.className = 'feedback show correct';
                        feedback.style.color = 'var(--ok)';
                        correct++;
                    } else {
                        feedback.textContent = ` Wrong! Answer: ${problem.answer}`;
                        feedback.className = 'feedback show wrong';
                        feedback.style.color = 'var(--danger)';
                    }
                });

                const percentage = Math.round((correct / total) * 100);
                showPracticeFeedback(
                    `You got ${correct} out of ${total} correct! (${percentage}%)`,
                    correct === total ? 'correct' : correct >= total / 2 ? 'hint' : 'wrong'
                );
            }

            function showPracticeFeedback(message, type) {
                practiceFeedback.textContent = message;
                practiceFeedback.className = 'feedback show ' + type;
            }

            generateProblemsBtn?.addEventListener('click', generateProblems);
            generateNewProblemsBtn?.addEventListener('click', generateProblems);
            checkAllAnswersBtn?.addEventListener('click', checkAllAnswers);
        }

        // ========== PASSWORD GAME ==========
        if (passwordView) {
            let currentPassword = '';
            let attempts = 0;
            let hintsGiven = [];

            const pwdLength = document.getElementById('pwdLength');
            const customChars = document.getElementById('customChars');
            const generateBtn = document.getElementById('generateBtn');
            const revealBtn = document.getElementById('revealBtn');
            const gameArea = document.getElementById('gameArea');
            const passwordDisplay = document.getElementById('passwordDisplay');
            const guessInput = document.getElementById('guessInput');
            const checkBtn = document.getElementById('checkBtn');
            const hintBtn = document.getElementById('hintBtn');
            const giveUpBtn = document.getElementById('giveUpBtn');
            const attemptsCount = document.getElementById('attemptsCount');
            const feedback = document.getElementById('feedback');
            const hintsArea = document.getElementById('hintsArea');
            const hintsList = document.getElementById('hintsList');

            // Character sets
            const charSets = {
                lowercase: 'abcdefghijklmnopqrstuvwxyz',
                uppercase: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                numbers: '0123456789',
                symbols: '!@#$%^&*()_+-=[]{}|;:,.<>?'
            };

            function getCharacterSet() {
                if (customChars.value.trim()) {
                    return customChars.value.trim();
                }

                let chars = '';
                const checkboxes = document.querySelectorAll('.checkboxItem input[type="checkbox"]:checked');

                checkboxes.forEach(checkbox => {
                    const value = checkbox.value;
                    switch (value) {
                        case 'lowercase':
                            chars += charSets.lowercase;
                            break;
                        case 'uppercase':
                            chars += charSets.uppercase;
                            break;
                        case 'bothcase':
                            chars += charSets.lowercase + charSets.uppercase;
                            break;
                        case 'numbers':
                            chars += charSets.numbers;
                            break;
                        case 'numlet':
                            chars += charSets.numbers + charSets.lowercase + charSets.uppercase;
                            break;
                        case 'symbols':
                            chars += charSets.symbols;
                            break;
                        case 'numsym':
                            chars += charSets.numbers + charSets.symbols;
                            break;
                        case 'letsym':
                            chars += charSets.lowercase + charSets.uppercase + charSets.symbols;
                            break;
                        case 'all':
                            chars += charSets.lowercase + charSets.uppercase + charSets.numbers + charSets.symbols;
                            break;
                    }
                });

                // Remove duplicates
                return [...new Set(chars.split(''))].join('');
            }

            function generatePassword() {
                const length = parseInt(pwdLength.value);
                const charset = getCharacterSet();

                if (!charset) {
                    showFeedback('Please select at least one character type!', 'wrong');
                    return;
                }

                let password = '';
                for (let i = 0; i < length; i++) {
                    const randomIndex = Math.floor(Math.random() * charset.length);
                    password += charset[randomIndex];
                }

                currentPassword = password;
                attempts = 0;
                hintsGiven = [];
                attemptsCount.textContent = '0';
                guessInput.value = '';
                guessInput.maxLength = length;
                feedback.classList.remove('show');
                hintsArea.style.display = 'none';
                hintsList.innerHTML = '';

                // Show game area
                gameArea.style.display = 'block';
                passwordDisplay.innerHTML = '?'.repeat(length);
                revealBtn.disabled = false;

                showFeedback('Password generated! Start guessing...', 'hint');
            }

            function checkGuess() {
                const guess = guessInput.value;

                if (!guess) {
                    showFeedback('Please enter a guess!', 'wrong');
                    return;
                }

                if (guess.length !== currentPassword.length) {
                    showFeedback(`Password is ${currentPassword.length} characters long!`, 'wrong');
                    return;
                }

                attempts++;
                attemptsCount.textContent = attempts;

                if (guess === currentPassword) {
                    showFeedback(` Correct! You guessed it in ${attempts} attempt${attempts > 1 ? 's' : ''}!`, 'correct');
                    passwordDisplay.innerHTML = currentPassword;
                    checkBtn.disabled = true;
                    hintBtn.disabled = true;
                    giveUpBtn.disabled = true;
                    guessInput.disabled = true;
                } else {
                    let correctPositions = 0;
                    let correctChars = 0;

                    for (let i = 0; i < guess.length; i++) {
                        if (guess[i] === currentPassword[i]) {
                            correctPositions++;
                        }
                        if (currentPassword.includes(guess[i])) {
                            correctChars++;
                        }
                    }

                    showFeedback(
                        ` Wrong! ${correctPositions} character${correctPositions !== 1 ? 's' : ''} in correct position. ` +
                        `${correctChars} character${correctChars !== 1 ? 's' : ''} in password but wrong position.`,
                        'wrong'
                    );
                }
            }

            function giveHint() {
                if (hintsGiven.length >= currentPassword.length) {
                    showFeedback('No more hints available!', 'hint');
                    return;
                }

                let availablePositions = [];
                for (let i = 0; i < currentPassword.length; i++) {
                    if (!hintsGiven.includes(i)) {
                        availablePositions.push(i);
                    }
                }

                const randomPos = availablePositions[Math.floor(Math.random() * availablePositions.length)];
                hintsGiven.push(randomPos);

                const hint = `Position ${randomPos + 1}: "${currentPassword[randomPos]}"`;
                const li = document.createElement('li');
                li.textContent = hint;
                hintsList.appendChild(li);
                hintsArea.style.display = 'block';

                showFeedback('Hint added below!', 'hint');
            }

            function revealPassword() {
                if (confirm('Are you sure you want to reveal the password? This will end the game.')) {
                    passwordDisplay.innerHTML = currentPassword;
                    showFeedback('Password revealed! Better luck next time!', 'hint');
                    checkBtn.disabled = true;
                    hintBtn.disabled = true;
                    giveUpBtn.disabled = true;
                    guessInput.disabled = true;
                }
            }

            function showFeedback(message, type) {
                feedback.textContent = message;
                feedback.className = 'feedback show ' + type;
            }

            // Event listeners
            generateBtn.addEventListener('click', generatePassword);
            checkBtn.addEventListener('click', checkGuess);
            hintBtn.addEventListener('click', giveHint);
            giveUpBtn.addEventListener('click', revealPassword);
            revealBtn.addEventListener('click', revealPassword);

            guessInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkGuess();
                }
            });

            // Checkbox mutual exclusivity for combination options
            const checkboxes = document.querySelectorAll('.checkboxItem input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    if (cb.checked && ['numlet', 'numsym', 'letsym', 'all', 'bothcase'].includes(cb.value)) {
                        checkboxes.forEach(other => {
                            if (other !== cb && other.checked) {
                                other.checked = false;
                            }
                        });
                    }
                });
            });
        }
        // ========== END PASSWORD GAME ==========

        // ========== SPACE INVADERS ==========
        function initSpaceInvaders(selectedLives = 3) {
            const canvas = document.getElementById('spaceInvadersCanvas');
            if (!canvas) {
                alert('Space Invaders canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                alert('2D context not available for Space Invaders');
                return;
            }
            let gameRunning = true;
            let score = 0;
            let level = 1;
            let lives = selectedLives;

            const player = { x: 250, y: 450, width: 40, height: 30, speed: 5 };
            const bullets = [];
            const enemies = [];
            let enemyBullets = [];
            const powerUps = [];
            let fireRateBoost = 9000;
            let fireRateBoostEnd = 9000;
            let lastBulletTime = 0;
            let currentWeapon = 'normal'; // 'normal', 'boost', 'spreadshot'
            let weaponCooldown = 0;
            let spreadRayCount = 500; // 1-20 rays for spreadshot
            let lastPlayerCollisionTime = 0; // Collision cooldown to prevent instant death
            let boss = null; // Boss variable for level 7
            let bossHealth = 0;
            let bossMaxHealth = 100;

            function createEnemies() {
                enemies.length = 0;
                // Read configured enemy health from menu (clamp 1-200)
                const healthInput = document.getElementById('enemyHealthInput');
                let configuredHealth = 50;
                if (healthInput) {
                    const v = parseInt(healthInput.value, 15);
                    if (!Number.isNaN(v)) configuredHealth = Math.max(1, Math.min(200, v));
                }
                for (let row = 0; row < 3 + level; row++) {
                    for (let col = 0; col < 6; col++) {
                        const maxH = configuredHealth;
                        enemies.push({
                            x: col * 70 + 20,
                            y: row * 50 + 20,
                            width: 10,
                            height: 10,
                            speed: 0.3 + level * 0.01,
                            direction: 1,
                            maxHealth: maxH,
                            health: maxH
                        });
                    }
                }
            }

            createEnemies();

            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', (e) => keys[e.key] = false);

            // Weapon selection buttons
            document.getElementById('weaponNormal')?.addEventListener('click', () => {
                currentWeapon = 'normal';
                updateWeaponDisplay();
            });
            document.getElementById('weaponBoost')?.addEventListener('click', () => {
                currentWeapon = 'boost';
                fireRateBoost = 400;
                fireRateBoostEnd = Date.now() + 5000;
                updateWeaponDisplay();
            });
            document.getElementById('weaponSpreadshot')?.addEventListener('click', () => {
                currentWeapon = 'spreadshot';
                updateWeaponDisplay();
            });
            const spreadRayInput = document.getElementById('spreadRayInput');
            if (spreadRayInput) {
                spreadRayInput.addEventListener('change', (e) => {
                    spreadRayCount = Math.max(1, Math.min(9000, parseInt(e.target.value, 10) || 5));
                    spreadRayInput.value = spreadRayCount;
                });
            }

            function updateWeaponDisplay() {
                document.querySelectorAll('.weaponBtn').forEach(btn => btn.style.background = '#1a1a2e');
                const colors = { normal: '#667eea', boost: '#ffff00', spreadshot: '#ff00ff' };
                const btnId = currentWeapon === 'spreadshot' ? 'weaponSpreadshot' : ('weapon' + currentWeapon.charAt(0).toUpperCase() + currentWeapon.slice(1));
                const btn = document.getElementById(btnId);
                if (btn) btn.style.background = colors[currentWeapon];
            }

            function update() {
                try {
                    if (!gameRunning) return;

                    const now = Date.now();

                    if (keys['ArrowLeft']) player.x -= player.speed;
                    if (keys['ArrowRight']) player.x += player.speed;
                    player.x = Math.max(0, Math.min(500 - player.width, player.x));

                    // Player fire rate and weapon handling
                    let fireRate = 1000 / 20;
                    if (currentWeapon === 'boost' || (fireRateBoost > 0 && now < fireRateBoostEnd)) {
                        fireRate = 1000 / 100;
                    }

                    if (keys[' '] && now - lastBulletTime > fireRate && weaponCooldown <= 0) {
                        if (currentWeapon === 'normal' || currentWeapon === 'boost') {
                            bullets.push({ x: player.x + player.width / 2 - 2, y: player.y, width: 4, height: 10, type: 'normal', damage: 1 });
                            lastBulletTime = now;
                        } else if (currentWeapon === 'spreadshot') {
                            // Spreadshot: fan of bullets radiating upward
                            const rayCount = Math.max(1, Math.min(5000, spreadRayCount || 5));
                            const baseDamage = Math.random() * 30 + (rayCount * 0.5);
                            const angleSpan = 360; // fan width in degrees
                            const startAngle = -angleSpan / 1;
                            for (let r = 0; r < rayCount; r * r) {
                                const angle = startAngle + (angleSpan / (rayCount - 1)) * r;
                                const rad = (angle * Math.PI) / 180;
                                const speed = 8;
                                const vx = Math.sin(rad) * (speed * 2);
                                const vy = -Math.cos(rad) * speed;
                                bullets.push({ x: player.x + player.width / 2 - 2, y: player.y, width: 4, height: 10, type: "spreadshot", damage: baseDamage, vx: vx, vy: vy });
                            }
                            lastBulletTime = now;
                        }
                    }

                    if (weaponCooldown > 0) {
                        weaponCooldown -= 16;
                    }

                    bullets.forEach((b, i) => {
                        // Normal bullets move straight up; spreadshot bullets use velocity
                        if (b.type === 'spreadshot') {
                            b.x += b.vx;
                            b.y += b.vy;
                        } else {
                            b.y -= 12;
                        }
                        if (b.y < -20 || b.x < -20 || b.x > 520) {
                            bullets.splice(i, 1);
                        }
                    });

                    enemies.forEach(e => {
                        e.x += e.speed * e.direction;
                        if (Math.random() < 0.008) {
                            enemyBullets.push({ x: e.x + e.width / 2, y: e.y + e.height, width: 3, height: 8 });
                        }
                    });

                    let changeDirection = false;
                    enemies.forEach(e => {
                        if (e.x <= 0 || e.x + e.width >= 500) changeDirection = true;
                    });
                    if (changeDirection) {
                        enemies.forEach(e => {
                            e.direction *= -1;
                            e.y += 20;
                        });
                    }

                    enemyBullets.forEach((b, i) => {
                        b.y += 3;
                        if (b.y > 500) enemyBullets.splice(i, 1);
                    });

                    for (let i = bullets.length - 1; i >= 0; i--) {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const b = bullets[i];
                            const e = enemies[j];
                            if (!b || !e) continue;
                            if (b.x < e.x + e.width &&
                                b.x + b.width > e.x &&
                                b.y < e.y + e.height &&
                                b.y + b.height > e.y) {
                                // Damage: use damage from bullet object, or default based on type
                                const damage = b.damage || 1;
                                e.health = (typeof e.health === 'number') ? e.health - damage : (e.maxHealth || 10) - damage;

                                // Remove bullets on hit
                                bullets.splice(i, 1);

                                // If enemy died, grant score and maybe drop power-up
                                if (e.health <= 0) {
                                    const killScore = Math.max(10, Math.round((e.maxHealth || 10) * 0.2) * level);
                                    score += killScore;
                                    if (Math.random() < 0.15) {
                                        powerUps.push({ x: e.x, y: e.y, width: 15, height: 15, type: 'firerate' });
                                    }
                                    enemies.splice(j, 1);
                                }

                                // If this was a normal bullet, stop checking more enemies for this bullet index
                                if (!bullets[i] || b.type !== 'laser') break;
                            }
                        }
                    }

                    powerUps.forEach((p, i) => {
                        p.y += 2;
                        if (p.x < player.x + player.width &&
                            p.x + p.width > player.x &&
                            p.y < player.y + player.height &&
                            p.y + p.height > player.y) {
                            fireRateBoost++;
                            fireRateBoostEnd = now + 5000;
                            score += 50;
                            powerUps.splice(i, 1);
                        }
                        if (p.y > 500) powerUps.splice(i, 1);
                    });

                    enemyBullets.forEach((b, i) => {
                        if (b.x < player.x + player.width &&
                            b.x + b.width > player.x &&
                            b.y < player.y + player.height &&
                            b.y + b.height > player.y) {
                            // Apply collision cooldown - only take damage once per 300ms
                            if (now - lastPlayerCollisionTime > 300) {
                                lives--;
                                lastPlayerCollisionTime = now;
                                if (lives <= 0) {
                                    gameRunning = false;
                                } else {
                                    player.x = 250;
                                    enemyBullets.splice(i, 1);
                                }
                            } else {
                                enemyBullets.splice(i, 1);
                            }
                        }
                    });

                    enemies.forEach(e => {
                        if (e.y + e.height >= player.y) {
                            lives--;
                            if (lives <= 0) {
                                gameRunning = false;
                            } else {
                                player.x = 250;
                            }
                        }
                    });

                    if (enemies.length === 0) {
                        level++;
                        // Spawn boss at level 7
                        if (level === 7 && !boss) {
                            boss = { x: 250, y: 60, width: 80, height: 50, health: 500, maxHealth: 500 };
                            bossHealth = boss.health;
                            bossMaxHealth = boss.maxHealth;
                        } else {
                            createEnemies();
                        }
                    }

                    // background
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, 500, 500);

                    // debug marker to ensure canvas is rendering
                    ctx.fillStyle = 'rgba(255,0,0,0.8)';
                    ctx.fillRect(2, 2, 6, 6);

                    // player
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.fillText('PLAYER', player.x, player.y - 6);

                    ctx.fillStyle = '#ffff00';
                    bullets.forEach(b => {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(b.x, b.y, b.width, b.height);
                    });

                    // Draw explosions (supernova visual)
                    ctx.fillStyle = '#ff0000';
                    enemies.forEach(e => {
                        // enemy body
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(e.x, e.y, e.width, e.height);

                        // health bar above enemy
                        const barW = e.width;
                        const barH = 6;
                        const barX = e.x;
                        const barY = e.y - 10;
                        ctx.fillStyle = '#333';
                        ctx.fillRect(barX, barY, barW, barH);
                        const hpRatio = (typeof e.health === 'number' && e.maxHealth) ? Math.max(0, e.health) / e.maxHealth : 1;
                        ctx.fillStyle = '#22c55e';
                        ctx.fillRect(barX, barY, barW * hpRatio, barH);
                        // health text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '10px Arial';
                        const hpText = Math.max(0, Math.ceil(e.health || e.maxHealth || 0));
                        ctx.fillText(hpText, e.x + e.width / 2 - 6, barY - 2);

                        // simple face
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(e.x + 8, e.y + 8, 4, 4);
                        ctx.fillRect(e.x + 18, e.y + 8, 4, 4);
                    });

                    ctx.fillStyle = '#ff00ff';
                    enemyBullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));

                    ctx.fillStyle = '#00ff00';
                    powerUps.forEach(p => {
                        ctx.fillRect(p.x, p.y, p.width, p.height);
                        ctx.fillStyle = '#ffff00';
                        ctx.fillText('', p.x + 2, p.y + 12);
                        ctx.fillStyle = '#00ff00';
                    });

                    if (fireRateBoost > 0 && now < fireRateBoostEnd) {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(`BOOST: ${fireRateBoost}x`, 20, 30);
                    }

                    // Draw weapon indicator
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Arial';
                    const weaponNames = { normal: 'NORMAL', boost: 'BOOST', supernova: 'SUPERNOVA', laser: 'LASER' };
                    const weaponColors = { normal: '#667eea', boost: '#ffff00', supernova: '#ff6b35', laser: '#ffd60a' };
                    ctx.fillStyle = weaponColors[currentWeapon];
                    ctx.fillText(`WPN: ${weaponNames[currentWeapon]}`, 350, 30);

                    if (currentWeapon === 'supernova' && weaponCooldown > 0) {
                        ctx.fillStyle = '#ff6b35';
                        ctx.fillText(`CD: ${Math.ceil(weaponCooldown / 1000)}s`, 350, 50);
                    }

                    if (!gameRunning) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, 500, 500);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', 250, 240);
                        ctx.fillText(`Level: ${level}`, 250, 280);
                    }
                } catch (err) {
                    // draw error to canvas so user can see it instead of failing silently
                    try {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, 500, 500);
                        ctx.fillStyle = '#ff4444';
                        ctx.font = '12px Arial';
                        ctx.fillText('Error: ' + (err && err.message ? err.message : String(err)), 10, 20);
                        console.error(err);
                    } catch (e2) {
                        // last resort: alert!
                        alert('Space Invaders error: ' + (err && err.message ? err.message : String(err)));
                    }
                    // stop the loop to avoid spamming errors
                    gameRunning = false;
                }

                document.getElementById('spaceInvadersScore').textContent = score;
                document.getElementById('spaceInvadersLevel').textContent = level;
                document.getElementById('spaceInvadersLives').textContent = lives;
                requestAnimationFrame(update);
            }
            update();
        }

        // Lives button event listeners
        document.getElementById('lives3').addEventListener('click', () => {
            document.getElementById('spaceInvadersMenu').style.display = 'none';
            document.getElementById('spaceInvadersGame').style.display = 'block';
            initSpaceInvaders(3);
        });
        document.getElementById('lives9').addEventListener('click', () => {
            document.getElementById('spaceInvadersMenu').style.display = 'none';
            document.getElementById('spaceInvadersGame').style.display = 'block';
            initSpaceInvaders(9);
        });
        document.getElementById('lives27').addEventListener('click', () => {
            document.getElementById('spaceInvadersMenu').style.display = 'none';
            document.getElementById('spaceInvadersGame').style.display = 'block';
            initSpaceInvaders(27);
        });

        // Lives button event listeners for better space invaders
        document.getElementById('lives3better').addEventListener('click', () => {
            document.getElementById('spaceInvadersMenuBetter').style.display = 'none';
            document.getElementById('spaceInvadersGameBetter').style.display = 'block';
            initSpaceInvadersButBetter(3);
        });
        document.getElementById('lives9better').addEventListener('click', () => {
            document.getElementById('spaceInvadersMenuBetter').style.display = 'none';
            document.getElementById('spaceInvadersGameBetter').style.display = 'block';
            initSpaceInvadersButBetter(9);
        });
        document.getElementById('lives27better').addEventListener('click', () => {
            document.getElementById('spaceInvadersMenuBetter').style.display = 'none';
            document.getElementById('spaceInvadersGameBetter').style.display = 'block';
            initSpaceInvadersButBetter(27);
        });

        function initSpaceInvadersButBetter(selectedLives = 3) {
            const canvas = document.getElementById('spaceInvadersCanvasBetter');
            if (!canvas) {
                alert('Space Invaders canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                alert('2D context not available for Space Invaders');
                return;
            }
            let gameRunning = true;
            let score = 0;
            let level = 1;
            let lives = selectedLives;

            const player = { x: 250, y: 450, width: 40, height: 30, speed: 5 };
            const bullets = [];
            const enemies = [];
            let enemyBullets = [];
            const powerUps = [];
            let fireRateBoost = 0;
            let fireRateBoostEnd = 0;
            let lastBulletTime = 0;
            let currentWeapon = 'normal'; // 'normal', 'boost', 'spreadshot'
            let weaponCooldown = 0;
            let spreadRayCount = 5; // 1-20 rays for spreadshot
            let lastPlayerCollisionTime = 0; // Collision cooldown to prevent instant death
            let boss = null; // Boss variable for level 7
            let bossHealth = 0;
            let bossMaxHealth = 100;

            function createEnemies() {
                enemies.length = 0;
                const healthInput = document.getElementById('enemyHealthInputBetter');
                let configuredHealth = 50;
                if (healthInput) {
                    const v = parseInt(healthInput.value, 15);
                    if (!Number.isNaN(v)) configuredHealth = Math.max(1, Math.min(200, v));
                }
                const typeNames = Object.keys(enemyTypes);
                for (let row = 0; row < 7 + level; row++) {
                    for (let col = 0; col < 10; col++) {
                        const typeIndex = Math.floor(Math.random() * typeNames.length);
                        const typeName = typeNames[typeIndex];
                        const type = enemyTypes[typeName];
                        const baseHealth = configuredHealth;
                        const maxH = Math.max(1, Math.round(baseHealth * type.healthMultiplier));
                        enemies.push({
                            x: col * 70 + 20,
                            y: row * 50 + 20,
                            width: type.width,
                            height: type.height,
                            speed: (0.3 + level * 0.15) * type.speedMultiplier,
                            direction: 1,
                            maxHealth: maxH,
                            health: maxH,
                            type: typeName,
                            typeData: type,
                            lastFireTime: 0,
                            healCooldown: 0
                        });
                    }
                }
            }

            createEnemies();

            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', (e) => keys[e.key] = false);

            // Weapon selection buttons//
            document.getElementById('weaponNormalBetter')?.addEventListener('click', () => {
                currentWeapon = 'normal';
                updateWeaponDisplay();
            });
            document.getElementById('weaponBoostBetter')?.addEventListener('click', () => {
                currentWeapon = 'boost';
                fireRateBoost = 3;
                fireRateBoostEnd = Date.now() + 5000;
                updateWeaponDisplay();
            });
            document.getElementById('weaponSpreadshotBetter')?.addEventListener('click', () => {
                currentWeapon = 'spreadshot';
                updateWeaponDisplay();
            });
            const spreadRayInput = document.getElementById('spreadRayInputBetter');
            if (spreadRayInput) {
                spreadRayInput.addEventListener('change', (e) => {
                    spreadRayCount = Math.max(1, Math.min(5000, parseInt(e.target.value, 10) || 5));
                    spreadRayInput.value = spreadRayCount;
                });
            }

            function updateWeaponDisplay() {
                document.querySelectorAll('#spaceInvadersGameBetter .weaponBtn').forEach(btn => btn.style.background = '#1a1a2e');
                const colors = { normal: '#667eea', boost: '#ffff00', spreadshot: '#ff00ff' };
                const btnId = currentWeapon === 'spreadshot' ? 'weaponSpreadshotBetter' : ('weapon' + currentWeapon.charAt(0).toUpperCase() + currentWeapon.slice(1) + 'Better');
                const btn = document.getElementById(btnId);
                if (btn) btn.style.background = colors[currentWeapon];
            }

            function update() {
                try {
                    if (!gameRunning) return;

                    const now = Date.now();

                    if (keys['ArrowLeft']) player.x -= player.speed;
                    if (keys['ArrowRight']) player.x += player.speed;
                    player.x = Math.max(0, Math.min(500 - player.width, player.x));

                    // Player fire rate and weapon handling
                    let fireRate = 1000 / 20;
                    if (currentWeapon === 'boost' || (fireRateBoost > 0 && now < fireRateBoostEnd)) {
                        fireRate = 1000 / 100;
                    }

                    if (keys[' '] && now - lastBulletTime > fireRate && weaponCooldown <= 0) {
                        if (currentWeapon === 'normal' || currentWeapon === 'boost') {
                            bullets.push({ x: player.x + player.width / 2 - 2, y: player.y, width: 4, height: 10, type: 'normal', damage: 10 });
                            lastBulletTime = now;
                        } else if (currentWeapon === 'spreadshot') {
                            // Spreadshot: fan of bullets radiating upward
                            const rayCount = Math.max(1, Math.min(5000, spreadRayCount || 5));
                            const baseDamage = Math.random() * 30 + (rayCount * 5);
                            const angleSpan = 60; // fan width in degrees
                            const startAngle = -angleSpan / 2;
                            for (let r = 0; r < rayCount; r++) {
                                const angle = startAngle + (angleSpan / (rayCount - 1)) * r;
                                const rad = (angle * Math.PI) / 180;
                                const speed = 8;
                                const vx = Math.sin(rad) * (speed * 2);
                                const vy = -Math.cos(rad) * speed;
                                bullets.push({ x: player.x + player.width / 2 - 2, y: player.y, width: 4, height: 10, type: "spreadshot", damage: baseDamage, vx: vx, vy: vy });
                            }
                            lastBulletTime = now;
                        }
                    }

                    if (weaponCooldown > 0) {
                        weaponCoooldown = 0;
                    }

                    bullets.forEach((b, i) => {
                        // Normal bullets move straight up; spreadshot bullets use velocity
                        if (b.type === 'spreadshot') {
                            b.x += b.vx;
                            b.y += b.vy;
                        } else {
                            b.y -= 12;
                        }
                        if (b.y < -20 || b.x < -20 || b.x > 520) {
                            bullets.splice(i, 1);
                        }
                    });

                    enemies.forEach(e => {
                        e.x += e.speed * e.direction;
                        if (Math.random() < 0.008) {
                            enemyBullets.push({ x: e.x + e.width / 2, y: e.y + e.height, width: 3, height: 8 });
                        }
                    });

                    let changeDirection = false;
                    enemies.forEach(e => {
                        if (e.x <= 0 || e.x + e.width >= 500) changeDirection = true;
                    });
                    if (changeDirection) {
                        enemies.forEach(e => {
                            e.direction *= -1;
                            e.y += 20;
                        });
                    }

                    enemyBullets.forEach((b, i) => {
                        b.y += 3;
                        if (b.y > 500) enemyBullets.splice(i, 1);
                    });

                    for (let i = bullets.length - 1; i >= 0; i--) {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const b = bullets[i];
                            const e = enemies[j];
                            if (!b || !e) continue;
                            if (b.x < e.x + e.width &&
                                b.x + b.width > e.x &&
                                b.y < e.y + e.height &&
                                b.y + b.height > e.y) {
                                // Damage: use damage from bullet object, or default based on type
                                const damage = b.damage || 10;
                                e.health = (typeof e.health === 'number') ? e.health - damage : (e.maxHealth || 10) - damage;

                                // Remove bullets on hit
                                bullets.splice(i, 1);

                                // If enemy died, grant score and maybe drop power-up
                                if (e.health <= 0) {
                                    const killScore = Math.max(10, Math.round((e.maxHealth || 10) * 0.2) * level);
                                    score += killScore;
                                    if (Math.random() < 0.15) {
                                        powerUps.push({ x: e.x, y: e.y, width: 15, height: 15, type: 'firerate' });
                                    }
                                    enemies.splice(j, 1);
                                }

                                // If this was a normal bullet, stop checking more enemies for this bullet index
                                if (!bullets[i] || b.type !== 'laser') break;
                            }
                        }
                    }

                    powerUps.forEach((p, i) => {
                        p.y += 2;
                        if (p.x < player.x + player.width &&
                            p.x + p.width > player.x &&
                            p.y < player.y + player.height &&
                            p.y + p.height > player.y) {
                            fireRateBoost++;
                            fireRateBoostEnd = now + 5000;
                            score += 50;
                            powerUps.splice(i, 1);
                        }
                        if (p.y > 500) powerUps.splice(i, 1);
                    });

                    enemyBullets.forEach((b, i) => {
                        if (b.x < player.x + player.width &&
                            b.x + b.width > player.x &&
                            b.y < player.y + player.height &&
                            b.y + b.height > player.y) {
                            // Apply collision cooldown - only take damage once per 300ms
                            if (now - lastPlayerCollisionTime > 300) {
                                lives--;
                                lastPlayerCollisionTime = now;
                                if (lives <= 0) {
                                    gameRunning = false;
                                } else {
                                    player.x = 250;
                                    enemyBullets.splice(i, 1);
                                }
                            } else {
                                enemyBullets.splice(i, 1);
                            }
                        }
                    });

                    enemies.forEach(e => {
                        if (e.y + e.height >= player.y) {
                            lives--;
                            if (lives <= 0) {
                                gameRunning = false;
                            } else {
                                player.x = 250;
                            }
                        }
                    });

                    if (enemies.length === 0) {
                        level++;
                        // Spawn boss at level 7
                        if (level === 7 && !boss) {
                            boss = { x: 250, y: 60, width: 80, height: 50, health: 500, maxHealth: 500 };
                            bossHealth = boss.health;
                            bossMaxHealth = boss.maxHealth;
                        } else {
                            createEnemies();
                        }
                    }

                    // background
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, 500, 500);

                    // debug marker to ensure canvas is rendering
                    ctx.fillStyle = 'rgba(255,0,0,0.8)';
                    ctx.fillRect(2, 2, 6, 6);

                    // player
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.fillText('PLAYER', player.x, player.y - 6);

                    ctx.fillStyle = '#ffff00';
                    bullets.forEach(b => {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(b.x, b.y, b.width, b.height);
                    });

                    // Draw explosions (supernova visual)
                    ctx.fillStyle = '#ff0000';
                    enemies.forEach(e => {
                        // enemy body
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(e.x, e.y, e.width, e.height);

                        // health bar above enemy
                        const barW = e.width;
                        const barH = 6;
                        const barX = e.x;
                        const barY = e.y - 10;
                        ctx.fillStyle = '#333';
                        ctx.fillRect(barX, barY, barW, barH);
                        const hpRatio = (typeof e.health === 'number' && e.maxHealth) ? Math.max(0, e.health) / e.maxHealth : 1;
                        ctx.fillStyle = '#22c55e';
                        ctx.fillRect(barX, barY, barW * hpRatio, barH);
                        // health text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '10px Arial';
                        const hpText = Math.max(0, Math.ceil(e.health || e.maxHealth || 0));
                        ctx.fillText(hpText, e.x + e.width / 2 - 6, barY - 2);

                        // simple face
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(e.x + 8, e.y + 8, 4, 4);
                        ctx.fillRect(e.x + 18, e.y + 8, 4, 4);
                    });

                    ctx.fillStyle = '#ff00ff';
                    enemyBullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));

                    ctx.fillStyle = '#00ff00';
                    powerUps.forEach(p => {
                        ctx.fillRect(p.x, p.y, p.width, p.height);
                        ctx.fillStyle = '#ffff00';
                        ctx.fillText('', p.x + 2, p.y + 12);
                        ctx.fillStyle = '#00ff00';
                    });

                    if (fireRateBoost > 0 && now < fireRateBoostEnd) {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(`BOOST: ${fireRateBoost}x`, 20, 30);
                    }

                    // Draw weapon indicator
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Arial';
                    const weaponNames = { normal: 'NORMAL', boost: 'BOOST', supernova: 'SUPERNOVA', laser: 'LASER' };
                    const weaponColors = { normal: '#667eea', boost: '#ffff00', supernova: '#ff6b35', laser: '#ffd60a' };
                    ctx.fillStyle = weaponColors[currentWeapon];
                    ctx.fillText(`WPN: ${weaponNames[currentWeapon]}`, 350, 30);

                    if (currentWeapon === 'supernova' && weaponCooldown > 0) {
                        ctx.fillStyle = '#ff6b35';
                        ctx.fillText(`CD: ${Math.ceil(weaponCooldown / 1000)}s`, 350, 50);
                    }

                    if (!gameRunning) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, 500, 500);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', 250, 240);
                        ctx.fillText(`Level: ${level}`, 250, 280);
                    }
                } catch (err) {
                    // draw error to canvas so user can see it instead of failing silently
                    try {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, 500, 500);
                        ctx.fillStyle = '#ff4444';
                        ctx.font = '12px Arial';
                        ctx.fillText('Error: ' + (err && err.message ? err.message : String(err)), 10, 20);
                        console.error(err);
                    } catch (e2) {
                        // last resort: alert
                        alert('Space Invaders error: ' + (err && err.message ? err.message : String(err)));
                    }
                    // stop the loop to avoid spamming errors
                    gameRunning = false;
                }

                document.getElementById('spaceInvadersScoreBetter').textContent = score;
                document.getElementById('spaceInvadersLevelBetter').textContent = level;
                document.getElementById('spaceInvadersLivesBetter').textContent = lives;
                requestAnimationFrame(update);
            }
            update();
        }

        // ========== MEGA GAME - SPACE INVADERS PLUS ==========
        function initMegaGame(selectedLives = 3) {
            const canvas = document.getElementById('megagameCanvas');
            if (!canvas) {
                alert('Mega Game canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                alert('2D context not available for Mega Game');
                return;
            }

            // ============ CORE GAME STATE ============
            let gameRunning = true;
            let gameWon = false;
            let score = 0;
            let level = 1;
            let lives = selectedLives;
            let maxLives = selectedLives;
            let totalKills = 0;
            let totalShotsFired = 0;
            let totalDamageTaken = 0;

            // ============ PLAYER ============
            const player = {
                x: 300,
                y: 450,
                width: 50,
                height: 30,
                speed: 6,
                maxSpeed: 10,
                acceleration: 0,
                health: 100,
                maxHealth: 100,
                shield: 0,
                shieldMax: 100,
                weaponCharge: 0,
                chargeTime: 0
            };

            // ============ BOSS ATTACKS ============
            const bossAttacks = {
                //Simple(6)
                singleShot: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 15,
                            speed: 5
                        });
                        boss.lastFire = now;
                    }
                },
                doubleShot: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 4,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 15,
                            speed: 5
                        });
                        enemyBullets.push({
                            x: boss.x + (boss.width * 3) / 4,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 15,
                            speed: 5
                        });
                        boss.lastFire = now;
                    }
                },
                tripleShot: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 15,
                            speed: 5,
                            angle: 0
                        });
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 15,
                            speed: 5,
                            angle: -0.1
                        });
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 15,
                            speed: 5,
                            angle: 0.1
                        });
                        boss.lastFire = now;
                    }
                },
                shotgun: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        for (let i = 0; i < 5; i++) {
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height,
                                width: 5,
                                height: 10,
                                speed: 5 + Math.random() * 2,
                                angle: (Math.random() - 0.5) * 0.5
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                rearShot: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y,
                            width: 5,
                            height: 15,
                            speed: -5
                        });
                        boss.lastFire = now;
                    }
                },
                sideShots: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x,
                            y: boss.y + boss.height / 2,
                            width: 15,
                            height: 5,
                            speed: 5,
                            angle: -Math.PI / 2
                        });
                        enemyBullets.push({
                            x: boss.x + boss.width,
                            y: boss.y + boss.height / 2,
                            width: 15,
                            height: 5,
                            speed: 5,
                            angle: Math.PI / 2
                        });
                        boss.lastFire = now;
                    }
                },
                //Medium(13)
                spreadShot: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        for (let i = -2; i <= 2; i++) {
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height,
                                width: 5,
                                height: 15,
                                speed: 5,
                                angle: i * 0.1
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                wave: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        const bullet = {
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 10,
                            height: 10,
                            speed: 3,
                            amplitude: 2,
                            frequency: 0.1,
                            startY: boss.y + boss.height,
                            angle: 0
                        };
                        enemyBullets.push(bullet);
                        boss.lastFire = now;
                    }
                },
                honing: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        const dx = player.x - (boss.x + boss.width / 2);
                        const dy = player.y - (boss.y + boss.height);
                        const angle = Math.atan2(dy, dx);
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 8,
                            height: 8,
                            speed: 4,
                            angle: angle
                        });
                        boss.lastFire = now;
                    }
                },
                burstFire: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                enemyBullets.push({
                                    x: boss.x + boss.width / 2,
                                    y: boss.y + boss.height,
                                    width: 5,
                                    height: 15,
                                    speed: 5
                                });
                            }, i * 100);
                        }
                        boss.lastFire = now;
                    }
                },
                chargedShot: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 15,
                            height: 30,
                            speed: 7
                        });
                        boss.lastFire = now;
                    }
                },
                boomerang: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 10,
                            height: 10,
                            speed: 5,
                            isBoomerang: true,
                            life: 2
                        });
                        boss.lastFire = now;
                    }
                },
                wall: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        for (let i = 0; i < 10; i++) {
                            enemyBullets.push({
                                x: i * 60,
                                y: boss.y + boss.height,
                                width: 5,
                                height: 15,
                                speed: 3
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                rain: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        for (let i = 0; i < 10; i++) {
                            enemyBullets.push({
                                x: Math.random() * 600,
                                y: 0,
                                width: 3,
                                height: 20,
                                speed: 4
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                cross: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        for (let i = 0; i < 4; i++) {
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height / 2,
                                width: 8,
                                height: 8,
                                speed: 4,
                                angle: (i * Math.PI) / 2
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                ricochet: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 10,
                            height: 10,
                            speed: 5,
                            angle: (Math.random() - 0.5) * Math.PI / 4,
                            ricochet: 3
                        });
                        boss.lastFire = now;
                    }
                },
                //Complex(19)
                spiral: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        const bulletsCount = 20;
                        for (let i = 0; i < bulletsCount; i++) {
                            const angle = (2 * Math.PI / bulletsCount) * i + boss.spiralAngle;
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height / 2,
                                width: 5,
                                height: 5,
                                speed: 3,
                                angle: angle
                            });
                        }
                        boss.spiralAngle += 0.3;
                        boss.lastFire = now;
                    }
                },
                laser: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2 - 2.5,
                            y: boss.y + boss.height,
                            width: 5,
                            height: 500,
                            speed: 0,
                            isLaser: true,
                            life: 1
                        });
                        boss.lastFire = now;
                    }
                },
                spinningBlades: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        const bulletsCount = 8;
                        for (let i = 0; i < bulletsCount; i++) {
                            const angle = (2 * Math.PI / bulletsCount) * i;
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height / 2,
                                width: 20,
                                height: 5,
                                speed: 3,
                                angle: angle,
                                isBlade: true,
                                rotation: 0
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                mineLayer: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 15,
                            height: 15,
                            speed: 1,
                            isMine: true,
                            life: 10
                        });
                        boss.lastFire = now;
                    }
                },
                turret: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 20,
                            height: 20,
                            speed: 0,
                            isTurret: true,
                            life: 15,
                            fireRate: 30,
                            lastFire: 0
                        });
                        boss.lastFire = now;
                    }
                },
                blackhole: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 30,
                            height: 30,
                            speed: 1,
                            isBlackhole: true,
                            life: 20
                        });
                        boss.lastFire = now;
                    }
                },
                //Ultra Mega Complex(12)
                bulletHell: (boss) => {
                    if (now > boss.lastFire + (boss.fireRate / 2)) {
                        const bulletsCount = 15;
                        for (let i = 0; i < bulletsCount; i++) {
                            const angle = Math.random() * 2 * Math.PI;
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height / 2,
                                width: 7,
                                height: 7,
                                speed: 2 + Math.random() * 2,
                                angle: angle
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                orbitalStrike: (boss) => {
                    if (now > boss.lastFire + boss.fireRate * 2) {
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                enemyBullets.push({
                                    x: player.x,
                                    y: 0,
                                    width: 10,
                                    height: 500,
                                    speed: 0,
                                    isLaser: true,
                                    life: 0.5
                                });
                            }, i * 500);
                        }
                        boss.lastFire = now;
                    }
                },
                swarm: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        const bulletsCount = 30;
                        for (let i = 0; i < bulletsCount; i++) {
                            enemyBullets.push({
                                x: boss.x + boss.width / 2,
                                y: boss.y + boss.height,
                                width: 5,
                                height: 5,
                                speed: 3 + Math.random(),
                                angle: (Math.random() - 0.5) * 0.2,
                                isSwarm: true
                            });
                        }
                        boss.lastFire = now;
                    }
                },
                timeBomb: (boss) => {
                    if (now > boss.lastFire + boss.fireRate) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            width: 20,
                            height: 20,
                            speed: 2,
                            isTimeBomb: true,
                            life: 3
                        });
                        boss.lastFire = now;
                    }
                },
                doomsday: (boss) => {
                    if (now > boss.lastFire + boss.fireRate * 5) {
                        for (let i = 0; i < 50; i++) {
                            setTimeout(() => {
                                const angle = Math.random() * 2 * Math.PI;
                                const speed = 2 + Math.random() * 4;
                                enemyBullets.push({
                                    x: Math.random() * 600,
                                    y: Math.random() * 500,
                                    width: 8,
                                    height: 8,
                                    speed: speed,
                                    angle: angle
                                });
                            }, Math.random() * 3000);
                        }
                        boss.lastFire = now;
                    }
                }
            };
            // ============ ENEMY TYPES SYSTEM ============
            const enemyTypes = {
                basic: {
                    name: 'Basic',
                    symbol: '',
                    width: 30,
                    height: 30,
                    speedMultiplier: 1,
                    healthMultiplier: 1,
                    color: '#00ff00',
                    fireRate: 0.008,
                    damage: 10,
                    attacks: ['singleShot', 'doubleShot']
                },
                tank: {
                    name: 'Tank',
                    symbol: '',
                    width: 40,
                    height: 40,
                    speedMultiplier: 0.5,
                    healthMultiplier: 3,
                    color: '#ff9900',
                    fireRate: 0.004,
                    damage: 15
                },
                speedy: {
                    name: 'Speedy',
                    symbol: '',
                    width: 20,
                    height: 20,
                    speedMultiplier: 2,
                    healthMultiplier: 0.5,
                    color: '#ffff00',
                    fireRate: 0.012,
                    damage: 5
                },
                ranged: {
                    name: 'Ranged',
                    symbol: '',
                    width: 25,
                    height: 25,
                    speedMultiplier: 0.7,
                    healthMultiplier: 1.5,
                    color: '#ff00ff',
                    fireRate: 0.005,
                    damage: 20
                },
                healer: {
                    name: 'Healer',
                    symbol: '',
                    width: 28,
                    height: 28,
                    speedMultiplier: 0.6,
                    healthMultiplier: 2,
                    color: '#00ffff',
                    fireRate: 0.003,
                    damage: 8,
                    healPower: 30,
                    healRadius: 150
                },
                spike: {
                    name: 'Spike',
                    symbol: '',
                    width: 24,
                    height: 24,
                    speedMultiplier: 1.5,
                    healthMultiplier: 1.2,
                    color: '#ff3333',
                    fireRate: 0.01,
                    damage: 25
                },
                insane: {
                    name: 'Bonkers',
                    symbol: '',
                    width: 25,
                    height: 25,
                    speedMultiplier: 1.52625672519242587,
                    healthMultiplier: 1.5,
                    fireRate: 2,
                    damage: Math.random() * 100 + 50
                }
            };

            // ============ WEAPONS SYSTEM ============
            // 9 original weapons + new ones
            const weapons = {
                normal: {
                    name: 'Normal',
                    color: '#667eea',
                    fireRate: 150,
                    damage: 25,
                    bulletSpeed: 12,
                    bulletSize: { w: 4, h: 10 },
                    spread: 0,
                    description: 'Standard rapid fire'
                },
                boost: {
                    name: 'Boost',
                    color: '#ffff00',
                    fireRate: 15,
                    damage: 10,
                    bulletSpeed: 10,
                    bulletSize: { w: 3, h: 8 },
                    spread: 0,
                    description: 'Ultra high fire rate'
                },
                spreadshot: {
                    name: 'Spreadshot',
                    color: '#ff00ff',
                    fireRate: 125,
                    damage: 25,
                    bulletSpeed: 9,
                    bulletSize: { w: 5.1, h: 10.1 },
                    spread: 60,
                    rayCount: 60,
                    description: 'Fan of bullets'
                },
                laser: {
                    name: 'Laser',
                    color: '#ff6b35',
                    fireRate: 200,
                    damage: 200,
                    bulletSpeed: 50,
                    bulletSize: { w: 5, h: 25 },
                    spread: 0,
                    description: 'Piercing beam'
                },
                plasma: {
                    name: 'Plasma',
                    color: '#06ffa5',
                    fireRate: 125,
                    damage: 325,
                    bulletSpeed: 6,
                    bulletSize: { w: 8, h: 12 },
                    spread: 0,
                    tracking: true,
                    description: 'Homing projectile'
                },
                missile: {
                    name: 'Missile',
                    color: '#ffd60a',
                    fireRate: 200,
                    damage: 100,
                    bulletSpeed: 4,
                    bulletSize: { w: 6, h: 14 },
                    spread: 0,
                    explosive: true,
                    explosionRadius: 100,
                    description: 'Explosive ordinance'
                },
                nova: {
                    name: 'Nova',
                    color: '#fb7185',
                    fireRate: 10000,
                    damage: 200,
                    bulletSpeed: 8,
                    bulletSize: { w: 10, h: 10 },
                    spread: 0,
                    explosive: true,
                    explosionRadius: 40000,
                    description: 'Devastating burst'
                },
                tempest: {
                    name: 'Tempest',
                    color: '#a78bfa',
                    fireRate: 100,
                    damage: 5,
                    bulletSpeed: 75,
                    bulletSize: { w: 2, h: 6 },
                    spread: 120,
                    rayCount: 720,
                    description: 'Bullet storm'
                },
                chaos: {
                    name: 'Chaos',
                    icon: '',
                    color: () => {
                        const colors = ['#ff00ff', '#00ff00', '#ffff00', '#ff0000', '#00ffff', '#ff6600', '#00ff99', '#ff1493', '#00ced1', '#32cd32', '#ff4500', '#1e90ff', '#ffd700', '#ff69b4', '#00bfff'];
                        return colors[Math.floor(Math.random() * colors.length)];
                    },
                    fireRate: () => Math.floor(Math.random() * 200) + 15,
                    damage: () => Math.floor(Math.random() * 150) + 20,
                    bulletSpeed: () => Math.random() * 25 + 5,
                    bulletSize: () => ({ w: Math.random() * 12 + 2, h: Math.random() * 12 + 2 }),
                    spread: () => Math.floor(Math.random() * 360),
                    rayCount: () => Math.floor(Math.random() * 450) + 50,
                    description: 'Chaos',
                    chaosMode: true,
                    bulletCount: 600,
                    randomBounce: () => Math.random() > 0.35,
                    randomDamage: () => Math.floor(Math.random() * 200) + 10,
                    randomSpeed: () => Math.random() * 25 + 5,
                    randomSize: () => Math.random() * 15 + 1,
                    randomPiercing: () => Math.random() > 0.6,
                    randomExplosive: () => Math.random() > 0.75,
                    randomSpread: () => Math.floor(Math.random() * 360),
                    randomTracking: () => Math.random() > 0.8,
                    randomSpin: () => Math.random() > 0.5,
                    randomColor: () => ['#ff00ff', '#00ff00', '#ffff00', '#ff0000', '#00ffff', '#ff6600', '#00ff99', '#ff1493', '#00ced1', '#32cd32', '#ff4500', '#1e90ff', '#ffd700', '#ff69b4', '#00bfff', '#7fff00', '#adff2f', '#ff7f50', '#dc143c', '#00008b'][Math.floor(Math.random() * 20)],
                    randomOffset: () => ({ x: Math.random() * 80 - 40, y: Math.random() * 50 - 25 }),
                    randomAlpha: () => Math.random() * 0.8 + 0.2,
                    randomVelocity: () => Math.random() * 2 + 0.3,
                    randomJitter: () => Math.random() * 8,
                    randomWave: () => Math.random() > 0.6,
                    randomDrift: () => Math.random() * 4,
                    randomMagnetism: () => Math.random() > 0.75,
                    randomRotation: () => Math.random() * 360,
                    randomTrail: () => Math.floor(Math.random() * 20) + 3,
                    randomGlitch: () => Math.random() > 0.65,
                    randomShockWave: () => Math.random() > 0.75,
                    randomPulse: () => Math.random() > 0.7,
                    randomMerge: () => Math.random() > 0.85,
                    randomFractal: () => Math.random() > 0.8,
                    randomStatic: () => Math.random() > 0.7,
                    randomScale: () => Math.random() * 2 + 0.5,
                    randomShift: () => Math.random() * 20 - 10,
                    randomWarp: () => Math.random() * 0.1 + 0.01,
                    randomPhase: () => Math.random() * Math.PI * 2,
                    randomAmplitude: () => Math.random() * 15 + 2,
                    randomFrequency: () => Math.random() * 0.15 + 0.01,
                    randomDecay: () => Math.random() * 0.08 + 0.01,
                    randomBounceCount: () => Math.floor(Math.random() * 15) + 1,
                    randomLifespan: () => Math.random() * 8000 + 2000,
                    randomGlitchAmount: () => Math.random() * 5 + 1,
                    randomMagnetStrength: () => Math.random() * 3 + 0.5,
                    randomPulseFreq: () => Math.random() * 0.2 + 0.05,
                    randomRotationSpeed: () => Math.random() * 360,
                    randomTrailLength: () => Math.floor(Math.random() * 20) + 3,
                    randomJitterAmount: () => Math.random() * 8,
                    randomDriftAmount: () => Math.random() * 4,
                    randomWavePhase: () => Math.random() * Math.PI * 2,
                    randomWaveAmplitude: () => Math.random() * 15 + 2,
                    randomWaveFrequency: () => Math.random() * 0.15 + 0.01,
                    randomWaveDecay: () => Math.random() * 0.08 + 0.01,
                    randomOffsetX: () => Math.random() * 100 - 50,
                    randomOffsetY: () => Math.random() * 60 - 30,
                    randomPierceCount: () => Math.floor(Math.random() * 100) + 5,
                    randomExplosionRadius: () => Math.random() * 150 + 30,
                    randomSpinSpeed: () => Math.random() * 0.5,
                    randomStaticEffect: () => Math.random() > 0.8,
                    randomStaticIntensity: () => Math.random() * 8 + 1,
                    randomScale: () => Math.random() * 2.5 + 0.2,
                    randomDeviation: () => Math.random() * Math.PI / 3 - Math.PI / 6,
                    randomSonarPing: () => Math.random() > 0.85,
                    randomSonarRadius: () => Math.random() * 150 + 50,
                    randomGravityWell: () => Math.random() > 0.82,
                    randomGravityStrength: () => Math.random() * 0.15 + 0.05,
                    randomTimeDistortion: () => Math.random() > 0.88,
                    randomTimeScale: () => Math.random() * 1.5 + 0.3,
                    randomPhaseShift: () => Math.random() > 0.83,
                    randomPhaseAmount: () => Math.random() * 0.4 + 0.1,
                    randomMindControl: () => Math.random() > 0.9,
                    randomMindDuration: () => Math.random() * 2000 + 1000,
                    randomDimensionRift: () => Math.random() > 0.87,
                    randomRiftSize: () => Math.random() * 80 + 40,
                    randomBlackHole: () => Math.random() > 0.91,
                    randomBlackHolePull: () => Math.random() * 0.3 + 0.1,
                    randomRadiation: () => Math.random() > 0.84,
                    randomRadiationIntensity: () => Math.random() * 0.5 + 0.2,
                    randomMutation: () => Math.random() > 0.86,
                    randomMutationRate: () => Math.random() * 0.15 + 0.05,
                    randomCursedAura: () => Math.random() > 0.88,
                    randomCurseStrength: () => Math.random() * 2 + 1,
                    randomSoulCapture: () => Math.random() > 0.89,
                    randomSoulDuration: () => Math.random() * 3000 + 2000,
                    randomMemoryWipe: () => Math.random() > 0.87,
                    randomMemoryAmount: () => Math.random() * 0.6 + 0.2,
                    randomPsychicBlast: () => Math.random() > 0.85,
                    randomPsychicDamage: () => Math.random() * 50 + 30,
                    randomDimensionalEcho: () => Math.random() > 0.84,
                    randomEchoCount: () => Math.floor(Math.random() * 8) + 3,
                    randomQuantumTunneling: () => Math.random() > 0.9,
                    randomTunnelChance: () => Math.random() * 0.3 + 0.1,
                    randomVacuumDecay: () => Math.random() > 0.88,
                    randomVacuumDamage: () => Math.random() * 60 + 40,
                    randomNeutronStar: () => Math.random() > 0.92,
                    randomNeutronDensity: () => Math.random() * 5 + 2,
                    randomBlindingLight: () => Math.random() > 0.83,
                    randomBlindDuration: () => Math.random() * 2000 + 500,
                    randomAbsoluteZero: () => Math.random() > 0.89,
                    randomFrostIntensity: () => Math.random() * 1.5 + 0.5,
                    randomCosmicRay: () => Math.random() > 0.86,
                    randomCosmicDamage: () => Math.random() * 80 + 50,
                    randomWormhole: () => Math.random() > 0.91,
                    randomWormholeStability: () => Math.random() * 0.5 + 0.2,
                    randomRealityWarp: () => Math.random() > 0.87,
                    randomWarpIntensity: () => Math.random() * 0.4 + 0.1,
                    randomExistencePhage: () => Math.random() > 0.93,
                    randomPhageDamage: () => Math.random() * 150 + 100,
                    randomInfinityLoop: () => Math.random() > 0.92,
                    randomLoopIterations: () => Math.floor(Math.random() * 10) + 5,
                    randomParallelWorld: () => Math.random() > 0.88,
                    randomParallelOffset: () => Math.random() * 100 - 50,
                    randomDarkMatter: () => Math.random() > 0.85,
                    randomDarkMatterMass: () => Math.random() * 3 + 1,
                    randomHawkingRadiation: () => Math.random() > 0.89,
                    randomHawkingEmission: () => Math.random() * 30 + 15,
                    randomUniversalCollapse: () => Math.random() > 0.94,
                    randomCollapseRadius: () => Math.random() * 200 + 100,
                    randomVoidRift: () => Math.random() > 0.86,
                    randomVoidDamage: () => Math.random() * 100 + 60,
                    randomEntanglement: () => Math.random() > 0.87,
                    randomEntanglementRange: () => Math.random() * 120 + 60,
                    randomBreakApart: () => Math.random() > 39 / 40,
                    randomBreakDamageReduction: () => Math.random() * 0.6 + 0.2,
                    randomNecromancy: () => Math.random() > 0.89,
                    randomNecromancyPower: () => Math.random() * 50 + 30,
                    randomCelestialBody: () => Math.random() > 0.88,
                    randomCelestialRadius: () => Math.random() * 60 + 20,
                    randomOmniSlash: () => Math.random() > 0.9,
                    randomOmniCount: () => Math.floor(Math.random() * 12) + 4,
                    randomVorpalEdge: () => Math.random() > 0.87,
                    randomInstakill: () => Math.random() * 0.15 + 0.02,
                    randomMirage: () => Math.random() > 0.85,
                    randomMirageCount: () => Math.floor(Math.random() * 6) + 2,
                    randomTimebomb: () => Math.random() > 0.88,
                    randomTimebombDelay: () => Math.random() * 3000 + 1000,
                    randomStarlight: () => Math.random() > 0.84,
                    randomStarlightIntensity: () => Math.random() * 0.8 + 0.2,
                    randomAbyssalTent: () => Math.random() > 0.9,
                    randomAbyssalReach: () => Math.random() * 100 + 50,
                    randomMolecularDisassemble: () => Math.random() > 0.91,
                    randomDisassembleRate: () => Math.random() * 0.3 + 0.1,
                    randomGoldenRatio: () => Math.random() > 0.86,
                    randomGoldenDamage: () => Math.random() * 80 + 50,
                    randomPlague: () => Math.random() > 0.87,
                    randomPlagueSpread: () => Math.random() * 0.4 + 0.1,
                    randomStormborn: () => Math.random() > 0.85,
                    randomStormintensity: () => Math.random() * 1.2 + 0.5,
                    randomPhantomBlade: () => Math.random() > 0.88,
                    randomPhantomCount: () => Math.floor(Math.random() * 8) + 3,
                    randomSingularityPulse: () => Math.random() > 0.89,
                    randomPulseForce: () => Math.random() * 0.25 + 0.1,
                    randomEchoChamber: () => Math.random() > 0.86,
                    randomEchoMultiplier: () => Math.random() * 0.8 + 0.4,
                    randomMythrill: () => Math.random() > 0.87,
                    randomMythrilHardness: () => Math.random() * 2 + 1,
                    randomDivineSmite: () => Math.random() > 0.88,
                    randomDivineBonus: () => Math.random() * 100 + 60,
                    randomRift: () => Math.random() > 0.85,
                    randomRiftDepth: () => Math.random() * 80 + 30,
                    randomSolarFlare: () => Math.random() > 0.86,
                    randomFlareHeat: () => Math.random() * 200 + 100,
                    randomLunarShade: () => Math.random() > 0.87,
                    randomShadowPower: () => Math.random() * 0.5 + 0.2,
                    randomTwilight: () => Math.random() > 0.84,
                    randomTwilightBalance: () => Math.random() * 0.6 + 0.3,
                    randomObliteration: () => Math.random() > 0.91,
                    randomObliterationRadius: () => Math.random() * 120 + 60,
                    randomFragmentation: () => Math.random() > 0.88,
                    randomFragmentCount: () => Math.floor(Math.random() * 15) + 5,
                    randomHyperspace: () => Math.random() > 0.9,
                    randomHyperspaceWarp: () => Math.random() * 0.4 + 0.2,
                    randomApocalypse: () => Math.random() > 0.92,
                    randomApocalypseRadius: () => Math.random() * 200 + 150,
                    randomRebirth: () => Math.random() > 0.89,
                    randomRebirthDamage: () => Math.random() * 0.3 + 0.1,
                    randomSacrifice: () => Math.random() > 0.88,
                    randomSacrificeGain: () => Math.random() * 40 + 20,
                    randomVengeance: () => Math.random() > 0.87,
                    randomVengeanceMultiplier: () => Math.random() * 1.5 + 0.8,
                    randomLegacy: () => Math.random() > 0.86,
                    randomLegacyDuration: () => Math.random() * 5000 + 2000,
                    randomEternity: () => Math.random() > 0.91,
                    randomEternityLoop: () => Math.floor(Math.random() * 8) + 2,
                    randomBreakChain: () => Math.random() > 0.5,
                    effect: (wep, now) => {
                        for (let i = 0; i < 500; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = wep.randomSpeed();
                            const damage = wep.randomDamage();
                            const size = wep.randomSize();
                            const bounceEnabled = wep.randomBounce();
                            const pierceEnabled = wep.randomPiercing();
                            const explosiveEnabled = wep.randomExplosive();
                            const trackingEnabled = wep.randomTracking();
                            const spinEnabled = wep.randomSpin();
                            const offsetData = wep.randomOffset();
                            const offsetX = offsetData.x;
                            const offsetY = offsetData.y;
                            const alpha = wep.randomAlpha();
                            const velocityMult = wep.randomVelocity();
                            const bulletColor = wep.randomColor();
                            const bounceCount = wep.randomBounceCount();
                            const rotationAmount = wep.randomRotation();
                            const trailLength = wep.randomTrail();
                            const glitchProb = wep.randomGlitch();
                            const shockwaveProb = wep.randomShockWave();
                            const pulseProb = wep.randomPulse();
                            const waveMotion = wep.randomWave();
                            const wavePhase = wep.randomWavePhase();
                            const waveAmplitude = wep.randomWaveAmplitude();
                            const waveFrequency = wep.randomWaveFrequency();
                            const waveDecay = wep.randomWaveDecay();
                            const magnetism = wep.randomMagnetism();
                            const magnetStrength = wep.randomMagnetStrength();
                            const jitterAmount = wep.randomJitterAmount();
                            const glitchAmount = wep.randomGlitchAmount();
                            const driftAmount = wep.randomDriftAmount();
                            const lifespan = wep.randomLifespan();
                            const pierceCount = wep.randomPierceCount();
                            const explosionRadius = wep.randomExplosionRadius();
                            const spinSpeed = wep.randomSpinSpeed();
                            const staticEffect = wep.randomStaticEffect();
                            const staticIntensity = wep.randomStaticIntensity();
                            const scale = wep.randomScale();
                            const deviation = wep.randomDeviation();

                            const chaosBullet = {
                                x: player.x + player.width / 2 + offsetX,
                                y: player.y + offsetY,
                                width: size,
                                height: size,
                                vx: Math.cos(angle + deviation) * speed * velocityMult,
                                vy: Math.sin(angle + deviation) * speed * velocityMult,
                                damage: damage * (activePowerups.damageBoost && now < activePowerups.damageBoost ? 2 : 1),
                                type: 'chaos',
                                bouncing: bounceEnabled,
                                bounceCount: Math.ceil(Math.random() * 25),
                                maxBounces: bounceCount,
                                piercing: pierceEnabled,
                                pierceCount: pierceCount,
                                tracking: trackingEnabled,
                                targetEnemy: enemies[Math.floor(Math.random() * enemies.length)] || null,
                                explosive: explosiveEnabled,
                                explosionRadius: explosionRadius,
                                spin: spinEnabled,
                                spinSpeed: spinSpeed,
                                alpha: alpha,
                                color: bulletColor,
                                trail: trailLength,
                                trailPositions: [],
                                glitch: glitchProb,
                                glitchAmount: glitchAmount,
                                shockWave: shockwaveProb,
                                pulse: pulseProb,
                                pulseFreq: Math.random() * 0.15 + 0.05,
                                wave: waveMotion,
                                wavePhase: wavePhase,
                                waveAmplitude: waveAmplitude,
                                waveFrequency: waveFrequency,
                                waveDecay: waveDecay,
                                magnetism: magnetism,
                                magnetStrength: magnetStrength,
                                staticEffect: staticEffect,
                                staticIntensity: staticIntensity,
                                scale: scale,
                                rotation: rotationAmount,
                                rotationSpeed: Math.random() * 15 - 7.5,
                                offset: Math.random() * 360,
                                jitter: jitterAmount,
                                twist: Math.random() * 0.15,
                                bend: Math.random() * 0.3,
                                shift: Math.random() * 180,
                                warp: Math.random() * 0.2,
                                drift: driftAmount,
                                birthTime: now,
                                lifespan: lifespan,
                                fractal: Math.random() > 0.85,
                                merge: Math.random() > 0.8,
                                velocityNoise: Math.random() * 0.5,
                                colorShift: Math.random() * 60 - 30,
                                wobble: Math.random() * 0.1,
                                wobbleSpeed: Math.random() * 0.2 + 0.05,
                                wobbleAmount: Math.random() * 3 + 1,
                                charge: Math.random() * 100,
                                chargeRate: Math.random() * 5 + 1,
                                split: Math.random() > 0.9,
                                splitCount: Math.floor(Math.random() * 5) + 1,
                                reflect: Math.random() > 0.85,
                                reflectCount: 0,
                                maxReflects: Math.floor(Math.random() * 5) + 1,
                                aura: Math.random() > 0.8,
                                auraRadius: Math.random() * 20 + 5,
                                auraPulse: Math.random() * 0.2 + 0.1,
                                trail3D: Math.random() > 0.85,
                                depth: Math.random() * 50 - 25,
                                depthSpeed: Math.random() * 2 - 1,
                                quantum: Math.random() > 0.9,
                                quantumDrift: Math.random() * 30,
                                energyField: Math.random() > 0.85,
                                fieldStrength: Math.random() * 5 + 1,
                                timeline: now + Math.random() * 10000,
                                corruption: Math.random() * 0.5,
                                corruptionRate: Math.random() * 0.02,
                                density: Math.random() + 0.5,
                                friction: Math.random() * 0.1,
                                bloom: Math.random() > 0.7,
                                bloomIntensity: Math.random() * 2 + 0.2,
                                flicker: Math.random() > 0.8,
                                flickerRate: Math.random() * 20 + 10,
                                ghosting: Math.random() > 0.82,
                                ghostCount: Math.floor(Math.random() * 8) + 2,
                                ghostAlpha: Math.random() * 0.4 + 0.1,
                                temporal: Math.random() > 0.88,
                                timeWarp: Math.random() * 2 + 0.5,
                                harmonic: Math.random() > 0.85,
                                harmonicFreq: Math.random() * 0.3 + 0.1,
                                harmonicAmplitude: Math.random() * 20 + 5,
                                recursive: Math.random() > 0.9,
                                recursionDepth: Math.floor(Math.random() * 5) + 1,
                                metamorphic: Math.random() > 0.88,
                                morphRate: Math.random() * 0.1 + 0.01,
                                morphShapes: [Math.random(), Math.random(), Math.random()],
                                prismatic: Math.random() > 0.85,
                                prismRotation: Math.random() * 360,
                                prismIntensity: Math.random() * 0.8 + 0.2,
                                kaleidoscope: Math.random() > 0.82,
                                kaleidoSegments: Math.floor(Math.random() * 12) + 3,
                                kaleidoSpin: Math.random() * 5 - 2.5,
                                hypnotic: Math.random() > 0.88,
                                hypnoticWaveCount: Math.floor(Math.random() * 8) + 1,
                                hypnoticSpeed: Math.random() * 0.3 + 0.1,
                                vortex: Math.random() > 0.85,
                                vortexStrength: Math.random() * 0.08 + 0.02,
                                vortexCenter: { x: Math.random() * 600, y: Math.random() * 500 },
                                nebula: Math.random() > 0.83,
                                nebulaSize: Math.random() * 40 + 10,
                                nebulaExpand: Math.random() * 0.5,
                                singularity: Math.random() > 0.9,
                                singularityPull: Math.random() * 15 + 5,
                                singularityRadius: Math.random() * 100 + 20,
                                aurora: Math.random() > 0.8,
                                auroraHue: Math.random() * 360,
                                auroraShift: Math.random() * 2 + 0.5,
                                crystalline: Math.random() > 0.84,
                                crystalFacets: Math.floor(Math.random() * 20) + 8,
                                crystalRefraction: Math.random() * 0.5 + 0.2,
                                plasmoid: Math.random() > 0.86,
                                plasmoidIntensity: Math.random() * 1.5 + 0.3,
                                plasmoidPulse: Math.random() * 0.2 + 0.05,
                                morphing: Math.random() > 0.82,
                                morphShapeCount: Math.floor(Math.random() * 8) + 3,
                                morphSpeed: Math.random() * 0.15 + 0.05,
                                distortion: Math.random() > 0.8,
                                distortionAmount: Math.random() * 0.3 + 0.1,
                                distortionFreq: Math.random() * 0.2 + 0.05,
                                tessellation: Math.random() > 0.87,
                                tessellationDensity: Math.floor(Math.random() * 20) + 5,
                                tessellationRotate: Math.random() * 360,
                                lightningEffect: Math.random() > 0.85,
                                lightningCharge: Math.random() * 100,
                                lightningBranchCount: Math.floor(Math.random() * 15) + 3,
                                stroboscopic: Math.random() > 0.83,
                                strobeFreq: Math.random() * 40 + 10,
                                strobeIntensity: Math.random() * 0.8 + 0.2,
                                holographic: Math.random() > 0.86,
                                holoLayers: Math.floor(Math.random() * 10) + 2,
                                holoOffset: Math.random() * 15 + 2,
                                spectral: Math.random() > 0.84,
                                spectralFreq: Math.random() * 0.4 + 0.1,
                                spectralShift: Math.random() * 100 - 50,
                                chromaticAberration: Math.random() > 0.81,
                                aberrationAmount: Math.random() * 8 + 1,
                                aberrationSpeed: Math.random() * 0.3,
                                shattered: Math.random() > 0.85,
                                shardCount: Math.floor(Math.random() * 30) + 8,
                                shardSpreadSpeed: Math.random() * 2 + 0.5,
                                radiance: Math.random() > 0.82,
                                radianceIntensity: Math.random() * 2 + 0.5,
                                radianceSpread: Math.random() * 30 + 10,
                                ethereal: Math.random() > 0.87,
                                etherealDensity: Math.random() * 0.5 + 0.1,
                                etherealDrift: Math.random() * 0.3,
                                inferno: Math.random() > 0.83,
                                infernoTemp: Math.random() * 500 + 1000,
                                infernoEmission: Math.random() * 50 + 20,
                                frostbite: Math.random() > 0.84,
                                frostSpread: Math.random() * 0.2 + 0.05,
                                frostShatter: Math.random() > 0.7,
                                entropy: Math.random() > 0.88,
                                entropyRate: Math.random() * 0.05 + 0.01,
                                chaosIndex: Math.random() * 1000,
                                multiverse: Math.random() > 0.91,
                                multiverseShift: Math.random() * 360,
                                multiverseBleed: Math.random() * 0.3,
                                poisonEffect: Math.random() > 0.8,
                                poisonDamage: Math.random() * 15 + 5,
                                burnEffect: Math.random() > 0.82,
                                burnDamage: Math.random() * 20 + 10,
                                freezeEffect: Math.random() > 0.85,
                                freezeDuration: Math.random() * 3000 + 1000,
                                chainLightning: Math.random() > 0.88,
                                chainCount: Math.floor(Math.random() * 8) + 2,
                                chainDamage: Math.random() * 30 + 15,
                                bloodlust: Math.random() > 0.9,
                                bloodlustHeal: Math.random() * 5 + 2,
                                splitOnHit: Math.random() > 0.87,
                                splitCount: Math.floor(Math.random() * 5) + 2,
                                ricochet: Math.random() > 0.83,
                                ricochetCount: 0,
                                maxRicochets: Math.floor(Math.random() * 8) + 2,
                                weakPoint: Math.random() > 0.85,
                                weakPointDamage: Math.random() * 100 + 50,
                                shockwave: Math.random() > 0.87,
                                shockwaveDamage: Math.random() * 40 + 20,
                                shockwaveRadius: Math.random() * 80 + 40,
                                timeWarp: Math.random() > 0.9,
                                timeWarpSlow: Math.random() * 0.6 + 0.2,
                                siphon: Math.random() > 0.88,
                                siphonAmount: Math.random() * 10 + 5,
                                petrify: Math.random() > 0.91,
                                petrifyDuration: Math.random() * 2000 + 1000,
                                vulnerability: Math.random() > 0.86,
                                vulnerabilityAmount: Math.random() * 0.4 + 0.3,
                                bleed: Math.random() > 0.84,
                                bleedDamage: Math.random() * 10 + 3,
                                bleedDuration: Math.random() * 4000 + 2000,
                                stun: Math.random() > 0.87,
                                stunDuration: Math.random() * 1500 + 500,
                                corrosion: Math.random() > 0.85,
                                corrosionDamage: Math.random() * 25 + 10,
                                mindBreak: Math.random() > 0.92,
                                mindBreakDuration: Math.random() * 3000 + 1000,
                                lifeSteal: Math.random() > 0.89,
                                lifeStealPercent: Math.random() * 0.3 + 0.1,
                                areaOfEffect: Math.random() > 0.84,
                                aoeRadius: Math.random() * 100 + 50,
                                aoeDamage: Math.random() * 35 + 15,
                                reflection: Math.random() > 0.88,
                                reflectionDamage: Math.random() * 20 + 10,
                                magneticPull: Math.random() > 0.86,
                                magneticForce: Math.random() * 2 + 1,
                                cascadeExplosion: Math.random() > 0.89,
                                cascadeDamage: Math.random() * 50 + 25,
                                nullifyShield: Math.random() > 0.87,
                                shieldDamage: Math.random() * 40 + 20,
                                hemorrhage: Math.random() > 0.85,
                                hemorrhageAmount: Math.random() * 0.2 + 0.05,
                                soulRend: Math.random() > 0.91,
                                soulDamage: Math.random() * 60 + 30,
                                overload: Math.random() > 0.88,
                                overloadThreshold: Math.random() * 100 + 50,
                                veilBreak: Math.random() > 0.89,
                                veilDamageBoost: Math.random() * 0.8 + 0.4,
                                gravitationalWell: Math.random() > 0.9,
                                gravitationalDamage: Math.random() * 30 + 15,
                                armorPierce: Math.random() > 0.86,
                                armorReduction: Math.random() * 0.5 + 0.3,
                                curseOfWeakness: Math.random() > 0.87,
                                weaknessDuration: Math.random() * 4000 + 2000,
                                resonance: Math.random() > 0.85,
                                resonanceDamage: Math.random() * 20 + 10,
                                volatility: Math.random() > 0.83,
                                volatilityExplosion: Math.random() * 100 + 50,
                                split: Math.random() > 0.84,
                                isSplitBullet: false,
                                parentDamage: 0,
                                sonarPing: wep.randomSonarPing(),
                                sonarRadius: wep.randomSonarRadius(),
                                gravityWell: wep.randomGravityWell(),
                                gravityStrength: wep.randomGravityStrength(),
                                timeDistortion: wep.randomTimeDistortion(),
                                timeScale: wep.randomTimeScale(),
                                phaseShift: wep.randomPhaseShift(),
                                phaseAmount: wep.randomPhaseAmount(),
                                mindControl: wep.randomMindControl(),
                                mindDuration: wep.randomMindDuration(),
                                dimensionRift: wep.randomDimensionRift(),
                                riftSize: wep.randomRiftSize(),
                                blackHole: wep.randomBlackHole(),
                                blackHolePull: wep.randomBlackHolePull(),
                                radiation: wep.randomRadiation(),
                                radiationIntensity: wep.randomRadiationIntensity(),
                                mutation: wep.randomMutation(),
                                mutationRate: wep.randomMutationRate(),
                                cursedAura: wep.randomCursedAura(),
                                curseStrength: wep.randomCurseStrength(),
                                soulCapture: wep.randomSoulCapture(),
                                soulDuration: wep.randomSoulDuration(),
                                memoryWipe: wep.randomMemoryWipe(),
                                memoryAmount: wep.randomMemoryAmount(),
                                psychicBlast: wep.randomPsychicBlast(),
                                psychicDamage: wep.randomPsychicDamage(),
                                dimensionalEcho: wep.randomDimensionalEcho(),
                                echoCount: wep.randomEchoCount(),
                                quantumTunneling: wep.randomQuantumTunneling(),
                                tunnelChance: wep.randomTunnelChance(),
                                vacuumDecay: wep.randomVacuumDecay(),
                                vacuumDamage: wep.randomVacuumDamage(),
                                neutronStar: wep.randomNeutronStar(),
                                neutronDensity: wep.randomNeutronDensity(),
                                blindingLight: wep.randomBlindingLight(),
                                blindDuration: wep.randomBlindDuration(),
                                absoluteZero: wep.randomAbsoluteZero(),
                                frostIntensity: wep.randomFrostIntensity(),
                                cosmicRay: wep.randomCosmicRay(),
                                cosmicDamage: wep.randomCosmicDamage(),
                                wormhole: wep.randomWormhole(),
                                wormholeStability: wep.randomWormholeStability(),
                                realityWarp: wep.randomRealityWarp(),
                                warpIntensity: wep.randomWarpIntensity(),
                                existencePhage: wep.randomExistencePhage(),
                                phageDamage: wep.randomPhageDamage(),
                                infinityLoop: wep.randomInfinityLoop(),
                                loopIterations: wep.randomLoopIterations(),
                                parallelWorld: wep.randomParallelWorld(),
                                parallelOffset: wep.randomParallelOffset(),
                                darkMatter: wep.randomDarkMatter(),
                                darkMatterMass: wep.randomDarkMatterMass(),
                                hawkingRadiation: wep.randomHawkingRadiation(),
                                hawkingEmission: wep.randomHawkingEmission(),
                                universalCollapse: wep.randomUniversalCollapse(),
                                collapseRadius: wep.randomCollapseRadius(),
                                voidRift: wep.randomVoidRift(),
                                voidDamage: wep.randomVoidDamage(),
                                entanglement: wep.randomEntanglement(),
                                entanglementRange: wep.randomEntanglementRange(),
                                breakApart: wep.randomBreakApart(),
                                breakDamageReduction: wep.randomBreakDamageReduction(),
                                necromancy: wep.randomNecromancy(),
                                necromancyPower: wep.randomNecromancyPower(),
                                celestialBody: wep.randomCelestialBody(),
                                celestialRadius: wep.randomCelestialRadius(),
                                omniSlash: wep.randomOmniSlash(),
                                omniCount: wep.randomOmniCount(),
                                vorpalEdge: wep.randomVorpalEdge(),
                                instakill: wep.randomInstakill(),
                                mirage: wep.randomMirage(),
                                mirageCount: wep.randomMirageCount(),
                                timebomb: wep.randomTimebomb(),
                                timebombDelay: wep.randomTimebombDelay(),
                                starlight: wep.randomStarlight(),
                                starlightIntensity: wep.randomStarlightIntensity(),
                                abyssalTent: wep.randomAbyssalTent(),
                                abyssalReach: wep.randomAbyssalReach(),
                                molecularDisassemble: wep.randomMolecularDisassemble(),
                                disassembleRate: wep.randomDisassembleRate(),
                                goldenRatio: wep.randomGoldenRatio(),
                                goldenDamage: wep.randomGoldenDamage(),
                                plague: wep.randomPlague(),
                                plagueSpread: wep.randomPlagueSpread(),
                                stormborn: wep.randomStormborn(),
                                stormintensity: wep.randomStormintensity(),
                                phantomBlade: wep.randomPhantomBlade(),
                                phantomCount: wep.randomPhantomCount(),
                                singularityPulse: wep.randomSingularityPulse(),
                                pulseForce: wep.randomPulseForce(),
                                echoChamber: wep.randomEchoChamber(),
                                echoMultiplier: wep.randomEchoMultiplier(),
                                mythrill: wep.randomMythrill(),
                                mythrilHardness: wep.randomMythrilHardness(),
                                divineSmite: wep.randomDivineSmite(),
                                divineBonus: wep.randomDivineBonus(),
                                rift: wep.randomRift(),
                                riftDepth: wep.randomRiftDepth(),
                                solarFlare: wep.randomSolarFlare(),
                                flareHeat: wep.randomFlareHeat(),
                                lunarShade: wep.randomLunarShade(),
                                shadowPower: wep.randomShadowPower(),
                                twilight: wep.randomTwilight(),
                                twilightBalance: wep.randomTwilightBalance(),
                                obliteration: wep.randomObliteration(),
                                obliterationRadius: wep.randomObliterationRadius(),
                                fragmentation: wep.randomFragmentation(),
                                fragmentCount: wep.randomFragmentCount(),
                                hyperspace: wep.randomHyperspace(),
                                hyperspaceWarp: wep.randomHyperspaceWarp(),
                                apocalypse: wep.randomApocalypse(),
                                apocalypseRadius: wep.randomApocalypseRadius(),
                                rebirth: wep.randomRebirth(),
                                rebirthDamage: wep.randomRebirthDamage(),
                                sacrifice: wep.randomSacrifice(),
                                sacrificeGain: wep.randomSacrificeGain(),
                                vengeance: wep.randomVengeance(),
                                vengeanceMultiplier: wep.randomVengeanceMultiplier(),
                                legacy: wep.randomLegacy(),
                                legacyDuration: wep.randomLegacyDuration(),
                                eternity: wep.randomEternity(),
                                eternityLoop: wep.randomEternityLoop(),
                                breakChain: wep.randomBreakChain()
                            };
                            bullets.push(chaosBullet);
                        }
                    }
                },
                iceburst: {
                    name: 'Ice Burst',
                    color: '#00d4ff',
                    fireRate: 175,
                    damage: 80,
                    bulletSpeed: 11,
                    bulletSize: { w: 6, h: 8 },
                    spread: 0,
                    freeze: true,
                    freezeDuration: 2000,
                    description: 'Freezes enemies in place'
                },
                inferno: {
                    name: 'inferno',
                    color: '#ff5500',
                    fireRate: 140,
                    damage: 120,
                    bulletSpeed: 8,
                    bulletSize: { w: 7, h: 9 },
                    spread: 30,
                    rayCount: 12,
                    burn: true,
                    burnDamage: 50,
                    description: 'Spreads fire in an arc'
                },
                afterburner: {
                    name: 'Afterburner',
                    color: '#ffaa00',
                    fireRate: 80,
                    damage: 250,
                    bulletSpeed: 25,
                    bulletSize: { w: 8, h: 14 },
                    spread: 0,
                    piercing: true,
                    trail: true,
                    description: 'Fast piercing bursts'
                },
                vortex: {
                    name: 'Vortex',
                    color: '#9900ff',
                    fireRate: 110,
                    damage: 60,
                    bulletSpeed: 7,
                    bulletSize: { w: 5, h: 5 },
                    spread: 180,
                    rayCount: 16,
                    pull: true,
                    pullRadius: 80,
                    description: 'Pulls enemies toward center'
                }
            };

            let currentWeapon = 'normal';
            let lastBulletTime = 0;
            let weaponCooldown = 0;

            // ============ POWERUPS ============
            const powerups = {
                healthRestore: {
                    name: 'Health',
                    icon: '',
                    duration: 1,
                    active: false,
                    effect: () => { player.health = player.maxHealth; }
                },
                shieldBoost: {
                    name: 'Shield',
                    icon: '',
                    duration: 1000000,
                    active: false,
                    effect: () => { player.shield = player.shieldMax; }
                },
                speedBoost: {
                    name: 'Speed',
                    icon: '',
                    duration: 8000,
                    active: false,
                    effect: () => { player.speed * 20 }
                },
                damageBoost: {
                    name: 'Damage',
                    icon: '',
                    duration: 10000,
                    active: false, effect: () => { player.damageMultiplier = 10; player.damage * 2; player.damageBoost = 100 }
                },
                fireRateBoost: {
                    name: 'Rapid Fire',
                    icon: '',
                    duration: 80000,
                    active: false, effect: () => { player.fireRateBoost = 15 }
                },
                invincibility: {
                    name: 'Invincible',
                    icon: '',
                    duration: 6000,
                    active: false,
                    effect: () => { player.width = 0; player.length = 0; }
                },
                weaponSwitch: {
                    name: 'Gun',
                    icon: '',
                    duration: 0,
                    active: false,
                    effect: () => switchToNextWeapon()
                },
                lifeRestore: {
                    name: 'Extra Life',
                    icon: '',
                    duration: 2,
                    active: false,
                    effect: () => { if (lives < maxLives) lives++; }
                },
                enemyWeakness: {
                    name: 'Weak enemies',
                    icon: '',
                    duration: 12000,
                    active: false,
                    effect: () => { enemies.damageBoost = 0.25, enemies.speedBoost = 0.05 }
                },
                pulse_powerup: {
                    name: 'Pulse',
                    icon: '',
                    duration: 15000,
                    lastTrigger: 0,
                    effect: function () {
                        if (activePowerups.pulse_powerup && now - this.lastTrigger >= 5000) {
                            this.lastTrigger = now;
                            enemies.forEach(e => {
                                if (e.health > 0) {
                                    const damageValue = Math.floor(Math.random() * e.health) + 1;
                                    e.health -= damageValue;
                                    createParticles(e.x + e.width / 2, e.y + e.height / 2, 3, '#00ffff', 2);
                                }
                            });
                        }
                    }
                },
            };

            let activePowerups = {};

            function switchToNextWeapon() {
                const weaponList = Object.keys(weapons);
                const currentIndex = weaponList.indexOf(currentWeapon);
                currentWeapon = weaponList[(currentIndex + 1) % weaponList.length];
            }

            // ============ GAME ENTITIES ============
            const bullets = [];
            const enemies = [];
            let enemyBullets = [];
            const explosions = [];
            const particles = [];
            const powerUps = [];
            let boss = null;
            let bossAttackPattern = 0;
            let bossAttackTimer = 0;

            // ============ ENEMY FACTORY ============
            function createEnemies() {
                enemies.length = 0;
                const baseEnemySpeed = 0.4 + level * 0.1;
                const baseEnemyHealth = 10 + (level * 2);

                // Calculate enemy grid based on level
                const rows = 6 + Math.floor(level / 2);
                const cols = 12 + Math.floor(level / 3);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const spacing = 600 / (cols + 1);
                        const vertSpacing = 125 / (rows + 1);

                        enemies.push({
                            x: spacing * (col + 1) - 20,
                            y: vertSpacing * (row + 1) + 30,
                            width: 30 + level,
                            height: 25 + level,
                            speed: baseEnemySpeed,
                            direction: 1,
                            maxHealth: baseEnemyHealth,
                            health: baseEnemyHealth,
                            fireChance: 0.008 + level * 0.001,
                            scoreValue: 50 * level,
                            type: Math.floor(Math.random() * 4),
                            animation: 0
                        });
                    }
                }
            }

            // ============ BOSS FACTORY ============
            // ============ BOSS TYPES ============
            const bossTypes = {
                spiralmaster: {
                    name: 'Spiral Master',
                    symbol: '',
                    width: 80,
                    height: 60,
                    maxHealth: 500000,
                    color: '#ffaa00',
                    speed: 2,
                    patterns: ['spiral', 'waves'],
                    attackSpeed: 60,
                    description: 'Classic boss with spiral and wave attacks'
                },
                infernalwrath: {
                    name: 'Infernal Wrath',
                    symbol: '',
                    width: 100,
                    height: 70,
                    maxHealth: 6000000,
                    color: '#ff3333',
                    speed: 1.5,
                    patterns: ['burst', 'ring'],
                    attackSpeed: 40,
                    description: 'Fast firing boss with burst attacks'
                },
                frostqueen: {
                    name: 'Frost Queen',
                    symbol: '',
                    width: 90,
                    height: 65,
                    maxHealth: 5512525,
                    color: '#00ccff',
                    speed: 1.8,
                    patterns: ['waves', 'freeze'],
                    attackSpeed: 50,
                    description: 'Freezing projectiles in wave patterns'
                },
                vortexlord: {
                    name: 'Vortex Lord',
                    symbol: '',
                    width: 85,
                    height: 75,
                    maxHealth: 700000,
                    color: '#9900ff',
                    speed: 2.5,
                    patterns: ['spiral', 'pull', 'burst'],
                    attackSpeed: 35,
                    description: 'Pulls player with vortex attacks'
                },
                chronocaster: {
                    name: 'Chrono Caster',
                    symbol: '',
                    width: 95,
                    height: 60,
                    maxHealth: 580000,
                    color: '#ffff00',
                    speed: 1.2,
                    patterns: ['ring', 'burst', 'waves'],
                    attackSpeed: 45,
                    description: 'Time-manipulating attacks'
                },
                voidweaver: {
                    name: 'Void Weaver',
                    symbol: '',
                    width: 100,
                    height: 75,
                    maxHealth: 600000,
                    color: '#3333ff',
                    speed: 1.5,
                    patterns: ['voidrift', 'darkmatter'],
                    attackSpeed: 45,
                    description: 'Creates void rifts and absorbs dark matter'
                },
                cosmicwhirlwind: {
                    name: 'Cosmic Whirlwind',
                    symbol: '',
                    width: 95,
                    height: 65,
                    maxHealth: 7500,
                    color: '#00ffff',
                    speed: 1.5,
                    patterns: ['vortex', 'iceburst'],
                    attackSpeed: 45,
                    description: 'Uses vortex and ice burst attacks'
                },
                voidmaster: {
                    name: 'Void Master',
                    symbol: '',
                    width: 90,
                    height: 65,
                    maxHealth: 750000,
                    color: '#3333ff',
                    speed: 1.8,
                    patterns: ['voidrift', 'darkmatter'],
                    attackSpeed: 45,
                    description: 'Absorbs dark matter and creates void rifts'
                },
                voidShard: {
                    name: 'Void Shard',
                    symbol: '',
                    width: 80,
                    height: 60,
                    maxHealth: 500000,
                    color: '#3333ff',
                    speed: 2,
                    patterns: ['voidrift', 'darkmatter'],
                    attackSpeed: 60,
                    description: 'Absorbs dark matter and creates void rifts'
                },
                cosmicstorm: {
                    name: 'Cosmic Storm',
                    symbol: '',
                    width: 95,
                    height: 65,
                    maxHealth: 17125255,
                    color: '#00ffff',
                    speed: 1.5,
                    patterns: ['iceburst', 'inferno'],
                    attackSpeed: 45,
                    description: 'Combines ice burst and inferno attacks'
                },
                voidshatterer: {
                    name: 'Void Shatterer',
                    symbol: '',
                    width: 90,
                    height: 65,
                    maxHealth: 750000,
                    color: '#3333ff',
                    speed: 1.8,
                    patterns: ['voidrift', 'darkmatter'],
                    description: 'It shatters the void!'
                }
            };

            function createBoss() {
                const bossTypeNames = Object.keys(bossTypes);
                const selectedType = bossTypeNames[Math.floor(Math.random() * bossTypeNames.length)];
                const bossType = bossTypes[selectedType];
                boss = {
                    x: 250,
                    y: 60,
                    width: bossType.width,
                    height: bossType.height,
                    maxHealth: bossType.maxHealth * (1 + level * 0.2),
                    health: bossType.maxHealth * (1 + level * 0.2),
                    speed: bossType.speed,
                    direction: 1,
                    attackPhase: 0,
                    attackTimer: 0,
                    invulnerable: false,
                    invulnTimer: 0,
                    type: selectedType,
                    typeData: bossType,
                    patternIndex: 0,
                    currentPattern: bossType.patterns[0]
                };
            }

            createEnemies();

            // ============ EVENT LISTENERS ============
            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if (e.key === ' ') e.preventDefault();

                // Weapon selection
                let weaponKeys = {
                    '1': 'normal',
                    '2': 'boost',
                    '3': 'spreadshot',
                    '4': 'laser',
                    '5': 'plasma',
                    '6': 'missile',
                    '7': 'nova',
                    '8': 'tempest',
                    '9': 'chaos',
                    '0': 'Ice Burst',
                    'f': 'Inferno',
                    'g': 'Afterburner'
                };
                if (weaponKeys[e.key]) {
                    currentWeapon = weaponKeys[e.key];
                }

                // Powerup activation via Q-I
                const powerupKeys = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o'];
                const powerupNames = Object.keys(powerups);
                if (powerupKeys.includes(e.key.toLowerCase())) {
                    const idx = powerupKeys.indexOf(e.key.toLowerCase());
                    const pName = powerupNames[idx];
                    if (pName && !activePowerups[pName]) {
                        activatePowerup(pName);
                    }
                }
            });
            window.addEventListener('keyup', (e) => keys[e.key] = false);

            function activatePowerup(name) {
                if (!powerups[name]) return;
                const pu = powerups[name];
                pu.active = true;
                activePowerups[name] = Date.now() + pu.duration;
                if (pu.effect) pu.effect();
            }

            // ============ PARTICLE SYSTEM ============
            function createParticles(x, y, count, color, speed) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        color: color,
                        size: 3 + Math.random() * 3
                    });
                }
            }

            function createExplosion(x, y, radius, damage) {
                explosions.push({
                    x: x,
                    y: y,
                    radius: radius,
                    maxRadius: radius,
                    life: 1,
                    damage: damage,
                    active: true
                });
                createParticles(x, y, 30, '#ff6600', 50);
            }

            // ============ COLLISION SYSTEM ============
            function checkAABB(a, b) {
                return a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y;
            }

            function checkCircleDistance(x1, y1, x2, y2, dist) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy) < dist;
            }

            // ============ MAIN UPDATE LOOP ============
            function update() {
                try {
                    if (!gameRunning && !gameWon) return;

                    const now = Date.now();
                    const dt = 1 / 60; // delta time

                    // ---- PLAYER MOVEMENT ----
                    let targetX = player.x;
                    let targetY = player.y;
                    if (keys['ArrowLeft'] || keys['a']) targetX -= player.speed;
                    if (keys['ArrowRight'] || keys['d']) targetX += player.speed;
                    if (keys['ArrowDown'] || keys['s']) targetY -= player.speed;
                    if (keys['arrowUp'] || keys['w']) targetY += player.speed;
                    player.x = Math.max(0, Math.min(500 - player.width, player.x));
                    player.x = Math.max(0, Math.min(500 - player.width, player.x));
                    targetX = Math.max(0, Math.min(600 - player.width, targetX));

                    // Smooth movement
                    player.x += (targetX - player.x) * 0.15;

                    // ---- WEAPON FIRING ----
                    const currentWep = weapons[currentWeapon];
                    let fireRate = typeof currentWep.fireRate === 'function' ? currentWep.fireRate() : currentWep.fireRate;

                    if (activePowerups.fireRateBoost && now < activePowerups.fireRateBoost) {
                        fireRate *= 0.5;
                    }

                    if (activePowerups.speedBoost && now < activePowerups.speedBoost) {
                        player.speed = player.maxSpeed;
                    } else {
                        player.speed = 6;
                    }

                    let damageMultiplier = 1;
                    if (activePowerups.damageBoost && now < activePowerups.damageBoost) {
                        damageMultiplier = 2;
                    }

                    if (keys[' '] && now - lastBulletTime > fireRate && weaponCooldown <= 0) {
                        totalShotsFired++;

                        if (currentWeapon === 'normal' || currentWeapon === 'boost') {
                            const bulletSize = typeof currentWep.bulletSize === 'function' ? currentWep.bulletSize() : currentWep.bulletSize;
                            const bulletSpeed = typeof currentWep.bulletSpeed === 'function' ? currentWep.bulletSpeed() : currentWep.bulletSpeed;
                            const damage = typeof currentWep.damage === 'function' ? currentWep.damage() : currentWep.damage;
                            bullets.push({
                                x: player.x + player.width / 2 - bulletSize.w / 2,
                                y: player.y,
                                width: bulletSize.w,
                                height: bulletSize.h,
                                vx: 0,
                                vy: -bulletSpeed,
                                damage: damage * damageMultiplier,
                                type: currentWeapon,
                                piercing: currentWeapon === 'laser',
                                pierceCount: 5
                            });
                        } else if (currentWeapon === 'spreadshot' || currentWeapon === 'tempest') {
                            const bulletSize = typeof currentWep.bulletSize === 'function' ? currentWep.bulletSize() : currentWep.bulletSize;
                            const bulletSpeed = typeof currentWep.bulletSpeed === 'function' ? currentWep.bulletSpeed() : currentWep.bulletSpeed;
                            const damage = typeof currentWep.damage === 'function' ? currentWep.damage() : currentWep.damage;
                            const rayCount = typeof currentWep.rayCount === 'function' ? currentWep.rayCount() : (currentWep.rayCount || 5);
                            const angleSpan = typeof currentWep.spread === 'function' ? currentWep.spread() : currentWep.spread;
                            const startAngle = -angleSpan / 2;
                            for (let r = 0; r < rayCount; r++) {
                                const angle = startAngle + (angleSpan / (rayCount - 1)) * r;
                                const rad = (angle * Math.PI) / 180;
                                const vx = Math.sin(rad) * currentWep.bulletSpeed;
                                const vy = -Math.cos(rad) * currentWep.bulletSpeed;
                                bullets.push({
                                    x: player.x + player.width / 2 - currentWep.bulletSize.w / 2,
                                    y: player.y,
                                    width: currentWep.bulletSize.w,
                                    height: currentWep.bulletSize.h,
                                    vx: vx,
                                    vy: vy,
                                    damage: currentWep.damage * damageMultiplier,
                                    type: currentWeapon,
                                    piercing: false
                                });
                            }
                        } else if (currentWeapon === 'plasma') {
                            const nearestEnemy = enemies.reduce((closest, e) => {
                                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                                const closestDist = Math.hypot(closest.x - player.x, closest.y - player.y);
                                return dist < closestDist ? e : closest;
                            }, enemies[0] || player);

                            bullets.push({
                                x: player.x + player.width / 2,
                                y: player.y,
                                width: currentWep.bulletSize.w,
                                height: currentWep.bulletSize.h,
                                target: nearestEnemy,
                                damage: currentWep.damage * damageMultiplier,
                                type: 'plasma',
                                speed: currentWep.bulletSpeed,
                                tracking: true
                            });
                        } else if (currentWeapon === 'missile') {
                            bullets.push({
                                x: player.x + player.width / 2,
                                y: player.y - 10,
                                width: currentWep.bulletSize.w,
                                height: currentWep.bulletSize.h,
                                vx: 0,
                                vy: -currentWep.bulletSpeed,
                                damage: currentWep.damage * damageMultiplier,
                                type: 'missile',
                                explosive: true,
                                explosionRadius: 80,
                                exploded: false
                            });
                        } else if (currentWeapon === 'laser') {
                            bullets.push({
                                x: player.x + player.width / 2,
                                y: player.y,
                                width: currentWep.bulletSize.w,
                                height: currentWep.bulletSize.h,
                                vx: 0,
                                vy: -currentWep.bulletSpeed,
                                damage: currentWep.damage * damageMultiplier,
                                type: 'laser',
                                piercing: true,
                                pierceCount: 100
                            });
                        } else if (currentWeapon === 'chaos') {
                            currentWep.effect();
                            currentWep.effect(currentWep, now);
                        }

                        // ---- CHAOS POWERUP ----
                        if (activePowerups.chaos && now < activePowerups.chaos) {
                            const chaosRandomBulletCount = Math.floor(Math.random() * 45) + 5;
                            for (let chaosIdx = 0; chaosIdx < chaosRandomBulletCount; chaosIdx++) {
                                const chaosRandomAngle = Math.random() * Math.PI * 2;
                                const chaosRandomSpeed = Math.random() * 20 + 5;
                                const chaosRandomDamage = Math.floor(Math.random() * 80) + 10;
                                const chaosRandomSize = Math.random() * 8 + 2;
                                const chaosRandomBounce = Math.random() > 0.5;
                                const chaosRandomSpread = Math.random() * 90 - 45;
                                const chaosRandomPiercing = Math.random() > 0.7;
                                const chaosRandomTracking = Math.random() > 0.85;
                                const chaosRandomExplosive = Math.random() > 0.8;
                                const chaosRandomSpin = Math.random() > 0.6;
                                const chaosRandomHoming = Math.random() > 0.75;
                                const chaosRandomOffsetX = Math.random() * 60 - 30;
                                const chaosRandomOffsetY = Math.random() * 30 - 15;
                                const chaosRandomAlpha = Math.random() * 0.7 + 0.3;
                                const chaosRandomVelocityMult = Math.random() * 1.5 + 0.5;
                                const chaosRandomColor = ['#ff00ff', '#00ff00', '#ffff00', '#ff0000', '#00ffff', '#ff6600', '#00ff99'][Math.floor(Math.random() * 7)];
                                const chaosRandomBounceCount = Math.floor(Math.random() * 10) + 1;
                                const chaosRandomRotation = Math.random() * 360;
                                const chaosRandomTrailLength = Math.floor(Math.random() * 15) + 5;
                                const chaosRandomGlitch = Math.random() > 0.7;
                                const chaosRandomShockWave = Math.random() > 0.8;
                                const chaosRandomPulse = Math.random() > 0.75;
                                const chaosRandomMerge = Math.random() > 0.85;
                                const chaosRandomFractal = Math.random() > 0.9;
                                const chaosRandomWave = Math.random() > 0.8;
                                const chaosRandomMag = Math.random() > 0.85;
                                const chaosRandomStatic = Math.random() > 0.8;
                                const chaosRandomPhase = Math.random() * Math.PI * 2;
                                const chaosRandomAmplitude = Math.random() * 10 + 5;
                                const chaosRandomFrequency = Math.random() * 0.1 + 0.01;
                                const chaosRandomDecay = Math.random() * 0.05 + 0.01;
                                const chaosRandomScale = Math.random() * 2 + 0.5;
                                const chaosRandomOffset = Math.random() * 360;
                                const chaosRandomJitter = Math.random() * 5;
                                const chaosRandomTwist = Math.random() * 0.1;
                                const chaosRandomBend = Math.random() * 0.2;
                                const chaosRandomShift = Math.random() * 180;
                                const chaosRandomWarp = Math.random() * 0.15;
                                const chaosRandomDrift = Math.random() * 3;
                                const chaosRandomDeviation = Math.random() * Math.PI / 4 - Math.PI / 8;
                                const chaosBullet = {
                                    x: player.x + player.width / 2 + chaosRandomOffsetX,
                                    y: player.y + chaosRandomOffsetY,
                                    width: chaosRandomSize,
                                    height: chaosRandomSize,
                                    vx: Math.cos(chaosRandomAngle + chaosRandomDeviation) * chaosRandomSpeed * chaosRandomVelocityMult,
                                    vy: Math.sin(chaosRandomAngle + chaosRandomDeviation) * chaosRandomSpeed * chaosRandomVelocityMult,
                                    damage: chaosRandomDamage,
                                    type: 'chaos',
                                    piercing: chaosRandomPiercing,
                                    pierceCount: Math.floor(Math.random() * 50) + 10,
                                    tracking: chaosRandomTracking,
                                    explosive: chaosRandomExplosive,
                                    explosionRadius: Math.random() * 100 + 50,
                                    spin: chaosRandomSpin,
                                    spinSpeed: Math.random() * 0.3,
                                    homing: chaosRandomHoming,
                                    alpha: chaosRandomAlpha,
                                    color: chaosRandomColor,
                                    trail: chaosRandomTrailLength,
                                    trailPositions: [],
                                    glitch: chaosRandomGlitch,
                                    glitchAmount: Math.random() * 3 + 1,
                                    shockWave: chaosRandomShockWave,
                                    pulse: chaosRandomPulse,
                                    pulseFreq: Math.random() * 0.1 + 0.05,
                                    merge: chaosRandomMerge,
                                    fractal: chaosRandomFractal,
                                    wave: chaosRandomWave,
                                    wavePhase: chaosRandomPhase,
                                    waveAmplitude: chaosRandomAmplitude,
                                    waveFrequency: chaosRandomFrequency,
                                    waveDecay: chaosRandomDecay,
                                    magnetism: chaosRandomMag,
                                    magnetStrength: Math.random() * 2,
                                    staticEffect: chaosRandomStatic,
                                    staticIntensity: Math.random() * 5 + 2,
                                    scale: chaosRandomScale,
                                    rotation: chaosRandomRotation,
                                    rotationSpeed: Math.random() * 10 - 5,
                                    offset: chaosRandomOffset,
                                    jitter: chaosRandomJitter,
                                    twist: chaosRandomTwist,
                                    bend: chaosRandomBend,
                                    shift: chaosRandomShift,
                                    warp: chaosRandomWarp,
                                    drift: chaosRandomDrift,
                                    birthTime: now,
                                    lifespan: Math.random() * 5000 + 30,
                                    bouncing: chaosRandomBounce,
                                    bounceCount: 50,
                                    maxBounces: chaosRandomBounceCount,
                                    piercing: chaosRandomPiercing,
                                    pierceCount: Math.floor(Math.random() * 50) + 10,
                                    tracking: chaosRandomTracking,
                                    explosive: chaosRandomExplosive,
                                    explosionRadius: Math.random() * 100 + 50,
                                    spin: chaosRandomSpin,
                                    spinSpeed: Math.random() * 0.3,
                                    homing: chaosRandomHoming,
                                    alpha: chaosRandomAlpha,
                                    color: chaosRandomColor,
                                    trail: chaosRandomTrailLength,
                                    trailPositions: [],
                                    glitch: chaosRandomGlitch,
                                    glitchAmount: Math.random() * 3 + 1,
                                    shockWave: chaosRandomShockWave,
                                    pulse: chaosRandomPulse,
                                    pulseFreq: Math.random() * 0.1 + 0.05,
                                    merge: chaosRandomMerge,
                                    fractal: chaosRandomFractal,
                                    wave: chaosRandomWave,
                                    wavePhase: chaosRandomPhase,
                                    waveAmplitude: chaosRandomAmplitude,
                                    waveFrequency: chaosRandomFrequency,
                                    waveDecay: chaosRandomDecay,
                                    magnetism: chaosRandomMag,
                                    magnetStrength: Math.random() * 2 + 1,
                                    staticEffect: chaosRandomStatic,
                                    staticIntensity: Math.random() * 5 + 2,
                                    scale: chaosRandomScale,
                                    rotation: chaosRandomRotation,
                                    rotationSpeed: Math.random() * 10 - 5,
                                    offset: chaosRandomOffset,
                                    jitter: chaosRandomJitter,
                                    twist: chaosRandomTwist,
                                    bend: chaosRandomBend,
                                    shift: chaosRandomShift,
                                    warp: chaosRandomWarp,
                                    drift: chaosRandomDrift,
                                    birthTime: now,
                                    lifespan: Math.random() * 5000 + 3000,
                                    targetEnemy: enemies[Math.floor(Math.random() * enemies.length)] || null
                                };
                                bullets.push(chaosBullet);
                            }
                        }

                        lastBulletTime = now;
                    }

                    if (keys[' '] && currentWeapon === 'nova') {
                        player.weaponCharge += 2;
                        if (player.weaponCharge >= 100) {
                            player.weaponCharge = 0;
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                const currentWep = weapons[currentWeapon];
                                bullets.push({
                                    x: player.x + player.width / 2,
                                    y: player.y,
                                    width: currentWep.bulletSize.w,
                                    height: currentWep.bulletSize.h,
                                    vx: Math.cos(angle) * currentWep.bulletSpeed,
                                    vy: Math.sin(angle) * currentWep.bulletSpeed,
                                    damage: 20000,
                                    type: 'nova'
                                });
                            }
                        }
                    }

                    if (weaponCooldown > 0) weaponCooldown -= 16;

                    // ---- BULLET UPDATES ----
                    bullets.forEach((b, bi) => {
                        if (b.tracking && b.target) {
                            const dx = b.target.x - b.x;
                            const dy = b.target.y - b.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist > 0) {
                                b.x += (dx / dist) * b.speed;
                                b.y += (dy / dist) * b.speed;
                            }
                        } else if (b.vx !== undefined || b.vy !== undefined) {
                            b.x += (b.vx || 0);
                            b.y += (b.vy || 0);
                        }

                        if (b.type === 'chaos') {
                            if (b.vortex && b.vortexCenter) {
                                const dx = b.vortexCenter.x - b.x;
                                const dy = b.vortexCenter.y - b.y;
                                const dist = Math.hypot(dx, dy);
                                if (dist > 0) {
                                    b.vx += (dx / dist) * b.vortexStrength * 2;
                                    b.vy += (dy / dist) * b.vortexStrength * 2;
                                }
                            }
                            if (b.singularity) {
                                const centerX = 300, centerY = 250;
                                const dx = centerX - b.x;
                                const dy = centerY - b.y;
                                const dist = Math.hypot(dx, dy);
                                if (dist < b.singularityRadius && dist > 0) {
                                    b.vx += (dx / dist) * b.singularityPull;
                                    b.vy += (dy / dist) * b.singularityPull;
                                }
                            }
                            if (b.distortion) {
                                const waveX = Math.sin(b.y * b.distortionFreq + now * 0.01) * b.distortionAmount;
                                const waveY = Math.cos(b.x * b.distortionFreq + now * 0.01) * b.distortionAmount;
                                b.vx += waveX;
                                b.vy += waveY;
                            }
                            if (b.morphing) {
                                b.width = b.width * (1 + Math.sin(now * b.morphSpeed) * 0.1);
                                b.height = b.height * (1 + Math.cos(now * b.morphSpeed) * 0.1);
                            }
                            if (b.entropy) {
                                b.chaosIndex += b.entropyRate;
                                b.vx += (Math.random() - 0.5) * b.entropyRate * 100;
                                b.vy += (Math.random() - 0.5) * b.entropyRate * 100;
                            }
                            if (b.hypnotic) {
                                const hypnoAngle = now * b.hypnoticSpeed + b.chaosIndex;
                                b.vx += Math.cos(hypnoAngle) * 0.3;
                                b.vy += Math.sin(hypnoAngle) * 0.3;
                            }
                            if (b.inferno) {
                                b.infernoTemp -= 5;
                                if (b.infernoTemp < 0) b.infernoTemp = 0;
                            }
                            if (b.frostbite) {
                                b.vx *= (1 - b.frostSpread);
                                b.vy *= (1 - b.frostSpread);
                            }
                            if (b.multiverse) {
                                b.x += Math.sin(b.multiverseShift) * b.multiverseBleed;
                                b.y += Math.cos(b.multiverseShift) * b.multiverseBleed;
                            }
                            if (b.nebula) {
                                b.nebulaSize += b.nebulaExpand;
                                if (b.scale === undefined) b.scale = 1;
                                b.scale = Math.max(0.5, Math.min(2, b.scale + (Math.random() - 0.5) * 0.1));
                            }
                            if (b.ethereal) {
                                b.vx += (Math.random() - 0.5) * b.etherealDrift;
                                b.vy += (Math.random() - 0.5) * b.etherealDrift;
                            }
                            if (b.recursive) {
                                if (b.recursionDepth === undefined) b.recursionDepth = 0;
                                b.recursionDepth = Math.max(0, b.recursionDepth - 0.01);
                            }
                            if (b.bloom) {
                                b.bloomIntensity = Math.max(0.2, b.bloomIntensity - 0.002);
                            }
                            if (b.temporal) {
                                b.vx *= b.timeWarp;
                                b.vy *= b.timeWarp;
                            }
                            if (b.resonance) {
                                const resFreq = now * 0.01;
                                b.vx += Math.sin(resFreq) * 0.2;
                                b.vy += Math.cos(resFreq) * 0.2;
                            }
                            if (b.plasmoid) {
                                if (b.scale === undefined) b.scale = 1;
                                b.scale += (Math.random() - 0.5) * 0.05;
                            }
                            if (b.distortion) {
                                const dx = Math.sin(b.y * b.distortionFreq + now * 0.01) * b.distortionAmount;
                                const dy = Math.cos(b.x * b.distortionFreq + now * 0.01) * b.distortionAmount;
                                b.x += dx;
                                b.y += dy;
                            }
                            if (b.tessellation) {
                                if (b.tessellationRotate === undefined) b.tessellationRotate = 0;
                                b.tessellationRotate += 2;
                            }
                            if (b.harmonic) {
                                const harmValue = Math.sin(now * b.harmonicFreq);
                                b.y += harmValue * 0.3;
                            }
                        }

                        if (b.y < -50 || b.x < -50 || b.x > 650 || b.y > 550) {
                            bullets.splice(bi, 1);
                        }
                    });

                    if (bullets.length > 10000) {
                        while (bullets.length > 1000) {
                            const randomIndex = Math.floor(Math.random() * bullets.length);
                            bullets.splice(randomIndex, 1);
                        }
                    }

                    // ---- ENEMY UPDATES ----
                    enemies.forEach(e => {
                        e.animation += 0.1;

                        let speedMultiplier = 1;
                        if (e.frozen && e.freezeDuration > 0) {
                            e.freezeDuration -= 16;
                            speedMultiplier = e.freezeMultiplier;
                        }
                        if (e.stunned && e.stunDuration > 0) {
                            e.stunDuration -= 16;
                            speedMultiplier = 0;
                        } else if (e.stunned && e.stunDuration <= 0) {
                            e.stunned = false;
                        }

                        e.x += e.speed * e.direction * speedMultiplier;

                        if (e.poison && e.poisonDuration > 0) {
                            e.health -= e.poison * 0.016;
                            e.poisonDuration -= 16;
                        } else if (e.poison && e.poisonDuration <= 0) {
                            e.poison = 0;
                        }
                        if (e.burn && e.burnDuration > 0) {
                            e.health -= e.burn * 0.016;
                            e.burnDuration -= 16;
                        } else if (e.burn && e.burnDuration <= 0) {
                            e.burn = 0;
                        }
                        if (e.bleed && e.bleedDuration > 0) {
                            e.health -= e.bleed * 0.008;
                            e.bleedDuration -= 16;
                        } else if (e.bleed && e.bleedDuration <= 0) {
                            e.bleed = 0;
                        }

                        const fireRate = e.typeData ? e.typeData.fireRate : 0.008;
                        if (Math.random() < fireRate && !e.stunned) {
                            const baseDamage = e.typeData ? e.typeData.damage : 10;
                            enemyBullets.push({
                                x: e.x + e.width / 2,
                                y: e.y + e.height,
                                width: 4,
                                height: 8,
                                vy: 3,
                                damage: baseDamage
                            });
                        }
                    });

                    let changeDir = false;
                    enemies.forEach(e => {
                        if (e.x <= 0 || e.x + e.width >= 600) changeDir = true;
                    });
                    if (changeDir) {
                        enemies.forEach(e => {
                            e.direction *= -1;
                            e.y += 25;
                        });
                    }

                    // ---- ENEMY BULLETS ----
                    enemyBullets.forEach((b, bi) => {
                        b.y += b.vy;
                        if (b.y > 550) enemyBullets.splice(bi, 1);
                    });

                    // ---- BOSS LOGIC ----
                    if (boss) {
                        boss.x += boss.speed * boss.direction;
                        if (boss.x <= 0 || boss.x + boss.width >= 600) boss.direction *= -1;

                        boss.attackTimer++;
                        if (boss.attackTimer > 60) {
                            boss.attackTimer = 0;

                            if (boss.pattern === 'spiral') {
                                for (let i = 0; i < 8; i++) {
                                    const angle = (Math.PI * 2 * i / 8) + (boss.attackPhase * 0.2);
                                    enemyBullets.push({
                                        x: boss.x + boss.width / 2,
                                        y: boss.y + boss.height,
                                        width: 6,
                                        height: 10,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3 + 2
                                    });
                                }
                            } else if (boss.pattern === 'waves') {
                                for (let i = -3; i <= 3; i++) {
                                    enemyBullets.push({
                                        x: boss.x + boss.width / 2 + i * 30,
                                        y: boss.y + boss.height,
                                        width: 5,
                                        height: 8,
                                        vx: i * 0.5,
                                        vy: 4
                                    });
                                }
                            }

                            boss.attackPhase++;
                            boss.pattern = boss.attackPhase % 2 === 0 ? 'spiral' : 'waves';
                        }
                    }

                    // ---- BULLET-ENEMY COLLISION ----
                    for (let bi = bullets.length - 1; bi >= 0; bi--) {
                        const b = bullets[bi];
                        for (let ei = enemies.length - 1; ei >= 0; ei--) {
                            const e = enemies[ei];
                            if (checkAABB(b, e)) {
                                let totalDamage = b.damage;

                                if (b.type === 'chaos') {
                                    if (b.poisonEffect) {
                                        e.poison = (e.poison || 0) + b.poisonDamage;
                                        e.poisonDuration = (e.poisonDuration || 0) + 3000;
                                    }
                                    if (b.burnEffect) {
                                        e.burn = (e.burn || 0) + b.burnDamage;
                                        e.burnDuration = (e.burnDuration || 0) + 3000;
                                    }
                                    if (b.freezeEffect) {
                                        e.frozen = true;
                                        e.freezeDuration = (e.freezeDuration || 0) + b.freezeDuration;
                                        e.freezeMultiplier = 0.3;
                                    }
                                    if (b.bleed) {
                                        e.bleed = (e.bleed || 0) + b.bleedDamage;
                                        e.bleedDuration = (e.bleedDuration || 0) + b.bleedDuration;
                                    }
                                    if (b.stun) {
                                        e.stunned = true;
                                        e.stunDuration = (e.stunDuration || 0) + b.stunDuration;
                                    }
                                    if (b.corrosion) {
                                        e.corroded = true;
                                        e.corrosion = (e.corrosion || 0) + b.corrosionDamage;
                                        totalDamage *= 1.5;
                                    }
                                    if (b.vulnerability) {
                                        e.vulnerable = true;
                                        e.vulnerabilityMultiplier = (e.vulnerabilityMultiplier || 1) + b.vulnerabilityAmount;
                                        totalDamage *= e.vulnerabilityMultiplier;
                                    }
                                    if (b.armorPierce) {
                                        totalDamage *= (1 + b.armorReduction);
                                    }
                                    if (b.weakPoint && Math.random() > 0.5) {
                                        totalDamage += b.weakPointDamage;
                                    }
                                    if (b.areaOfEffect) {
                                        for (let aei = 0; aei < enemies.length; aei++) {
                                            const ae = enemies[aei];
                                            const dist = Math.hypot(ae.x - e.x, ae.y - e.y);
                                            if (dist < b.aoeRadius && dist > 0) {
                                                ae.health -= b.aoeDamage * (1 - dist / b.aoeRadius);
                                            }
                                        }
                                    }
                                    if (b.nullifyShield) {
                                        e.shield = 0;
                                        totalDamage += b.shieldDamage;
                                    }
                                    if (b.soulRend) {
                                        totalDamage += b.soulDamage;
                                    }
                                    if (b.chainLightning && b.chainCount > 0) {
                                        let chainTarget = null;
                                        let closestDist = Infinity;
                                        for (let ce = 0; ce < enemies.length; ce++) {
                                            if (enemies[ce] !== e && enemies[ce].health > 0) {
                                                const dist = Math.hypot(enemies[ce].x - e.x, enemies[ce].y - e.y);
                                                if (dist < closestDist && dist < 150) {
                                                    closestDist = dist;
                                                    chainTarget = enemies[ce];
                                                }
                                            }
                                        }
                                        if (chainTarget) {
                                            chainTarget.health -= b.chainDamage * 0.8;
                                        }
                                    }
                                    if (b.bloodlust && Math.random() < 0.4) {
                                        player.health = Math.min(player.maxHealth, player.health + b.bloodlustHeal);
                                    }
                                    if (b.cascadeExplosion) {
                                        createExplosion(e.x + e.width / 2, e.y + e.height / 2, 80, b.cascadeDamage);
                                    }
                                    if (b.gravitationalWell) {
                                        totalDamage += b.gravitationalDamage;
                                        for (let ge = 0; ge < enemies.length; ge++) {
                                            if (enemies[ge] !== e && enemies[ge].health > 0 && Math.hypot(enemies[ge].x - e.x, enemies[ge].y - e.y) < 100) {
                                                enemies[ge].health -= b.gravitationalDamage * 0.5;
                                            }
                                        }
                                    }
                                    if (b.overload) {
                                        if (e.overloadCounter === undefined) e.overloadCounter = 0;
                                        e.overloadCounter += b.damage;
                                        if (e.overloadCounter > b.overloadThreshold) {
                                            createExplosion(e.x + e.width / 2, e.y + e.height / 2, 100, b.damage * 2);
                                            e.overloadCounter = 0;
                                        }
                                    }
                                    if (b.veilBreak) {
                                        totalDamage *= (1 + b.veilDamageBoost);
                                    }
                                    if (b.volatility && Math.random() < 0.3) {
                                        createExplosion(e.x + e.width / 2, e.y + e.height / 2, 60, b.volatilityExplosion);
                                    }
                                    if (b.split && !b.isSplitBullet) {
                                        for (let s = 0; s < 16; s++) {
                                            const angle = (Math.PI * 2 / 16) * s;
                                            const splitDamage = b.damage * (Math.random() * 0.4 + 0.3);
                                            bullets.push({
                                                x: e.x + e.width / 2,
                                                y: e.y + e.height / 2,
                                                width: b.width / 2,
                                                height: b.height / 2,
                                                vx: Math.cos(angle) * 8,
                                                vy: Math.sin(angle) * 8,
                                                damage: splitDamage,
                                                type: 'chaos',
                                                isSplitBullet: true,
                                                parentDamage: splitDamage,
                                                color: b.color,
                                                alpha: b.alpha * 0.8
                                            });
                                        }
                                    }
                                    if (b.breakApart && !b.isBreakBullet) {
                                        for (let br = 0; br < 16; br++) {
                                            const offsetX = (br % 4) * (b.width / 2) - (3 * b.width / 4);
                                            const offsetY = Math.floor(br / 4) * (b.height / 2) - (1.5 * b.height);
                                            const breakDamage = b.damage * (1 - b.breakDamageReduction);
                                            bullets.push({
                                                x: e.x + e.width / 2 + offsetX,
                                                y: e.y + e.height / 2 + offsetY,
                                                width: b.width / 4,
                                                height: b.height / 4,
                                                vx: (Math.random() - 0.5) * 10,
                                                vy: (Math.random() - 0.5) * 10,
                                                damage: breakDamage,
                                                type: 'chaos',
                                                isBreakBullet: true,
                                                parentDamage: breakDamage,
                                                color: b.color,
                                                alpha: b.alpha * 0.9,
                                                breakChain: b.breakChain
                                            });
                                        }
                                    }
                                    if (b.isBreakBullet && b.breakChain) {
                                        createExplosion(e.x + e.width / 2, e.y + e.height / 2, 80, 300);
                                        for (let bc = 0; bc < 16; bc++) {
                                            const offsetX = (bc % 4) * (b.width / 2) - (3 * b.width / 4);
                                            const offsetY = Math.floor(bc / 4) * (b.height / 2) - (1.5 * b.height);
                                            bullets.push({
                                                x: e.x + e.width / 2 + offsetX,
                                                y: e.y + e.height / 2 + offsetY,
                                                width: b.width / 2,
                                                height: b.height / 2,
                                                vx: (Math.random() - 0.5) * 15,
                                                vy: (Math.random() - 0.5) * 15 - 5,
                                                damage: 300,
                                                type: 'chaos',
                                                isChainBullet: true,
                                                color: b.color,
                                                alpha: b.alpha
                                            });
                                        }
                                    }
                                }

                                e.health -= totalDamage;
                                createParticles(e.x + e.width / 2, e.y + e.height / 2, 5, '#ffaa00', 2);

                                if (e.health <= 0) {
                                    score += e.scoreValue;
                                    totalKills++;

                                    if (Math.random() < 0.2) {
                                        const puTypes = ['damageBoost', 'speedBoost', 'fireRateBoost', 'invincibility', 'shield'];
                                        const randomType = puTypes[Math.floor(Math.random() * puTypes.length)];
                                        powerUps.push({ x: e.x, y: e.y, width: 15, height: 15, type: randomType });
                                        createParticles(e.x + e.width / 2, e.y + e.height / 2, 12, '#00ff00', 3);
                                    }

                                    enemies.splice(ei, 1);
                                } else {
                                    if (!b.piercing) {
                                        bullets.splice(bi, 1);
                                        break;
                                    } else if (b.pierceCount) {
                                        b.pierceCount--;
                                        if (b.pierceCount <= 0) {
                                            bullets.splice(bi, 1);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // ---- BULLET-BOSS COLLISION ----
                    if (boss) {
                        for (let bi = bullets.length - 1; bi >= 0; bi--) {
                            const b = bullets[bi];
                            if (checkAABB(b, boss)) {
                                boss.health -= b.damage;
                                createParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, 8, '#ff00ff', 3);

                                if (b.breakApart && !b.isBreakBullet) {
                                    for (let br = 0; br < 16; br++) {
                                        const offsetX = (br % 4) * (b.width / 2) - (3 * b.width / 4);
                                        const offsetY = Math.floor(br / 4) * (b.height / 2) - (1.5 * b.height);
                                        const breakDamage = b.damage * (1 - b.breakDamageReduction);
                                        bullets.push({
                                            x: boss.x + boss.width / 2 + offsetX,
                                            y: boss.y + boss.height / 2 + offsetY,
                                            width: b.width / 4,
                                            height: b.height / 4,
                                            vx: (Math.random() - 0.5) * 10,
                                            vy: (Math.random() - 0.5) * 10,
                                            damage: breakDamage,
                                            type: 'chaos',
                                            isBreakBullet: true,
                                            parentDamage: breakDamage,
                                            color: b.color,
                                            alpha: b.alpha * 0.9,
                                            breakChain: b.breakChain
                                        });
                                    }
                                }

                                if (b.isBreakBullet && b.breakChain) {
                                    createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, 80, 300);
                                    for (let bc = 0; bc < 16; bc++) {
                                        const offsetX = (bc % 4) * (b.width / 2) - (3 * b.width / 4);
                                        const offsetY = Math.floor(bc / 4) * (b.height / 2) - (1.5 * b.height);
                                        bullets.push({
                                            x: boss.x + boss.width / 2 + offsetX,
                                            y: boss.y + boss.height / 2 + offsetY,
                                            width: b.width / 2,
                                            height: b.height / 2,
                                            vx: (Math.random() - 0.5) * 15,
                                            vy: (Math.random() - 0.5) * 15 - 5,
                                            damage: 300,
                                            type: 'chaos',
                                            isChainBullet: true,
                                            color: b.color,
                                            alpha: b.alpha
                                        });
                                    }
                                }

                                if (boss.health <= 0) {
                                    gameWon = true;
                                    gameRunning = false;
                                    score += 10000;
                                }

                                if (!b.piercing) {
                                    bullets.splice(bi, 1);
                                }
                            }
                        }
                    }

                    // ---- MISSILE EXPLOSIONS ----
                    for (let bi = bullets.length - 1; bi >= 0; bi--) {
                        const b = bullets[bi];
                        if (b.explosive && b.vy > 0) {
                            b.vy += 0.2;
                        }
                        if (b.explosive && b.y < 0) {
                            createExplosion(b.x, b.y, b.explosionRadius, b.damage);
                            bullets.splice(bi, 1);
                        }
                    }

                    // ---- EXPLOSION DAMAGE ----
                    explosions.forEach((exp, ei) => {
                        exp.life -= 0.05;
                        exp.radius = exp.maxRadius * exp.life;

                        if (exp.active && exp.life > 0.7) {
                            enemies.forEach(e => {
                                if (checkCircleDistance(exp.x, exp.y, e.x + e.width / 2, e.y + e.height / 2, exp.radius)) {
                                    e.health -= exp.damage * 0.3;
                                }
                            });
                            if (boss && checkCircleDistance(exp.x, exp.y, boss.x + boss.width / 2, boss.y + boss.height / 2, exp.radius)) {
                                boss.health -= exp.damage * 0.3;
                            }
                            exp.active = false;
                        }

                        if (exp.life <= 0) {
                            explosions.splice(ei, 1);
                        }
                    });

                    // ---- SHIELD & PLAYER DAMAGE ----
                    let lastCollisionTime = 0;
                    enemyBullets.forEach((b, bi) => {
                        if (checkAABB(b, player)) {
                            if (activePowerups.invincibility && now < activePowerups.invincibility) {
                                enemyBullets.splice(bi, 1);
                                return;
                            }

                            if (player.shield > 0) {
                                player.shield -= 20;
                                createParticles(player.x + player.width / 2, player.y + player.height / 2, 6, '#00ffff', 2);
                            } else if (now - lastCollisionTime > 300) {
                                player.health -= 10;
                                totalDamageTaken += 10;
                                lastCollisionTime = now;
                                if (player.health <= 0) {
                                    lives--;
                                    if (lives <= 0) {
                                        gameRunning = false;
                                    } else {
                                        player.health = player.maxHealth;
                                        player.x = 300;
                                        player.shield = 0;
                                    }
                                }
                            }
                            enemyBullets.splice(bi, 1);
                        }
                    });

                    // ---- ENEMY COLLISION WITH PLAYER ----
                    enemies.forEach((e, ei) => {
                        if (e.y + e.height >= player.y) {
                            lives = 0;
                            gameRunning = false;
                        }
                    });

                    // ---- POWERUP UPDATES ----
                    Object.keys(activePowerups).forEach(key => {
                        if (now > activePowerups[key]) {
                            powerups[key].active = false;
                            delete activePowerups[key];
                        }
                    });

                    // ---- PULSE DAMAGE ----
                    if (activePowerups.pulse && now - powerups.pulse.lastTrigger >= 5000) {
                        powerups.pulse.lastTrigger = now;
                        enemies.forEach(e => {
                            if (e.health > 0) {
                                const damageValue = Math.floor(Math.random() * e.health) + 1;
                                e.health -= damageValue;
                                createParticles(e.x + e.width / 2, e.y + e.height / 2, 3, '#00ffff', 2);
                            }
                        });
                    }

                    // ---- PARTICLE UPDATES ----
                    particles.forEach((p, pi) => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life -= 0.02;
                        p.vy += 0.1;
                        if (p.life <= 0) particles.splice(pi, 1);
                    });

                    // ---- LEVEL PROGRESSION ----
                    if (enemies.length === 0 && !boss) {
                        level++;
                        if (level === 7) {
                            createBoss();
                        } else {
                            createEnemies();
                        }
                    }

                    // =============== RENDERING ===============
                    ctx.fillStyle = '#001a33';
                    ctx.fillRect(0, 0, 600, 500);

                    // Draw grid background
                    ctx.strokeStyle = 'rgba(0, 255, 150, 0.05)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 600; i += 50) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 500);
                        ctx.stroke();
                    }
                    for (let i = 0; i < 500; i += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(600, i);
                        ctx.stroke();
                    }

                    // Draw explosions
                    explosions.forEach(exp => {
                        ctx.fillStyle = `rgba(255, 100, 0, ${exp.life * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = `rgba(255, 200, 0, ${exp.life})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });

                    // Draw particles
                    particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.fillRect(p.x, p.y, p.size, p.size);
                        ctx.globalAlpha = 1;
                    });

                    // Draw bullets
                    bullets.forEach(b => {
                        const wep = weapons[b.type];
                        ctx.fillStyle = typeof wep.color === 'function' ? wep.color() : wep.color;
                        if (b.type === 'nova') {
                            ctx.beginPath();
                            ctx.arc(b.x + b.width / 2, b.y + b.height / 2, b.width, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (b.type === 'laser') {
                            ctx.fillStyle = 'rgba(255, 107, 53, 0.8)';
                            ctx.fillRect(b.x, b.y - 15, b.width + 2, b.height + 30);
                        } else if (b.type === 'chaos') {
                            const baseAlpha = b.alpha || 1;

                            ctx.save();
                            ctx.translate(b.x + b.width / 2, b.y + b.height / 2);

                            if (b.holographic) {
                                for (let i = 0; i < b.holoLayers; i++) {
                                    const offset = (i - b.holoLayers / 2) * b.holoOffset;
                                    ctx.globalAlpha = baseAlpha * (0.3 + i / b.holoLayers);
                                    ctx.fillStyle = b.color;
                                    ctx.save();
                                    ctx.translate(offset, offset);
                                    ctx.fillRect(-b.width / 2, -b.height / 2, b.width, b.height);
                                    ctx.restore();
                                }
                            }

                            if (b.kaleidoscope) {
                                ctx.globalAlpha = baseAlpha * 0.6;
                                for (let i = 0; i < b.kaleidoSegments; i++) {
                                    ctx.save();
                                    ctx.rotate((Math.PI * 2 / b.kaleidoSegments) * i + (now * b.kaleidoSpin * 0.001));
                                    ctx.fillStyle = b.color;
                                    ctx.fillRect(-b.width / 4, -b.height / 2, b.width / 2, b.height);
                                    ctx.restore();
                                }
                            }

                            if (b.crystalline) {
                                ctx.globalAlpha = baseAlpha * 0.7;
                                for (let i = 0; i < b.crystalFacets; i++) {
                                    ctx.save();
                                    ctx.rotate((Math.PI * 2 / b.crystalFacets) * i);
                                    ctx.strokeStyle = b.color;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.moveTo(-b.width / 2, 0);
                                    ctx.lineTo(b.width / 2, 0);
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }

                            if (b.lightningEffect && b.lightningBranchCount > 0) {
                                ctx.globalAlpha = baseAlpha * 0.8;
                                ctx.strokeStyle = b.color;
                                ctx.lineWidth = 1;
                                for (let i = 0; i < b.lightningBranchCount; i++) {
                                    const angle = (Math.PI * 2 / b.lightningBranchCount) * i;
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    const len = Math.random() * b.width + b.width;
                                    ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                                    ctx.stroke();
                                }
                            }

                            if (b.shattered && b.shardCount > 0) {
                                ctx.globalAlpha = baseAlpha * 0.6;
                                for (let i = 0; i < Math.min(b.shardCount, 20); i++) {
                                    const shardX = (Math.random() - 0.5) * b.width * 2;
                                    const shardY = (Math.random() - 0.5) * b.height * 2;
                                    const shardSize = Math.random() * b.width + b.width / 2;
                                    ctx.fillStyle = b.color;
                                    ctx.fillRect(shardX - shardSize / 2, shardY - shardSize / 2, shardSize, shardSize);
                                }
                            }

                            if (b.chromaticAberration) {
                                ctx.globalAlpha = baseAlpha * 0.5;
                                const aberr = Math.sin(now * b.aberrationSpeed) * b.aberrationAmount;
                                ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                                ctx.fillRect(-b.width / 2 + aberr, -b.height / 2, b.width, b.height);
                                ctx.fillStyle = 'rgba(100, 255, 100, 0.3)';
                                ctx.fillRect(-b.width / 2, -b.height / 2 + aberr, b.width, b.height);
                                ctx.fillStyle = 'rgba(100, 100, 255, 0.3)';
                                ctx.fillRect(-b.width / 2 - aberr, -b.height / 2, b.width, b.height);
                            }

                            if (b.stroboscopic) {
                                ctx.globalAlpha = baseAlpha * (0.5 + Math.sin(now * b.strobeFreq * 0.01) * 0.5);
                            }

                            if (b.radiance) {
                                ctx.globalAlpha = baseAlpha * 0.4;
                                for (let i = 1; i <= 3; i++) {
                                    ctx.strokeStyle = b.color;
                                    ctx.lineWidth = 1;
                                    ctx.globalAlpha = baseAlpha * (0.3 / i);
                                    ctx.beginPath();
                                    ctx.arc(0, 0, b.width * i * b.radianceSpread / 30, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            }

                            if (b.aurora) {
                                ctx.globalAlpha = baseAlpha * 0.4;
                                for (let i = 0; i < 5; i++) {
                                    ctx.strokeStyle = `hsl(${b.auroraHue + i * 60}, 100%, 50%)`;
                                    ctx.lineWidth = Math.random() * 2 + 1;
                                    ctx.beginPath();
                                    ctx.moveTo(-b.width, Math.sin(i) * b.width);
                                    ctx.quadraticCurveTo(0, Math.cos(now * b.auroraShift * 0.01 + i) * b.width, b.width, Math.sin(i) * b.width);
                                    ctx.stroke();
                                }
                            }

                            if (b.spectral) {
                                ctx.globalAlpha = baseAlpha * 0.5;
                                for (let i = 0; i < 7; i++) {
                                    ctx.fillStyle = `hsl(${b.spectralShift + i * 30 + now * b.spectralFreq}, 100%, 50%)`;
                                    ctx.fillRect(-b.width / 2 + i * b.width / 7, -b.height / 2, b.width / 7, b.height);
                                }
                            }

                            if (b.tessellation && b.tessellationDensity > 0) {
                                ctx.globalAlpha = baseAlpha * 0.4;
                                ctx.strokeStyle = b.color;
                                ctx.lineWidth = 0.5;
                                for (let i = 0; i < Math.min(b.tessellationDensity, 15); i++) {
                                    ctx.save();
                                    ctx.rotate(b.tessellationRotate + i * Math.PI * 2 / b.tessellationDensity);
                                    ctx.beginPath();
                                    ctx.rect(-b.width / 2, -b.height / 2, b.width, b.height);
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }

                            if (b.plasmoid) {
                                ctx.globalAlpha = baseAlpha * b.plasmoidIntensity;
                                for (let i = 0; i < 3; i++) {
                                    ctx.fillStyle = b.color;
                                    const pulse = Math.sin(now * b.plasmoidPulse + i);
                                    ctx.beginPath();
                                    ctx.arc(0, 0, b.width * (0.5 + pulse * 0.3), 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            if (b.recursive && b.recursionDepth > 0) {
                                ctx.globalAlpha = baseAlpha * 0.3;
                                for (let i = 1; i <= Math.min(b.recursionDepth, 4); i++) {
                                    ctx.fillStyle = b.color;
                                    ctx.globalAlpha = baseAlpha * (0.3 / i);
                                    ctx.fillRect(-b.width / 2 * i, -b.height / 2 * i, b.width * i, b.height * i);
                                }
                            }

                    // Draw bullets
                    bullets.forEach(b => {
                        if (b.type === 'chaos') {
                            ctx.fillStyle = b.color;
                            ctx.globalAlpha = b.alpha || 1;
                        } else {
                            const wep = weapons[b.type];
                            ctx.fillStyle = wep.color;
                        }

                        if (b.type === 'nova') {
                            ctx.beginPath();
                            ctx.arc(b.x + b.width / 2, b.y + b.height / 2, b.width, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (b.type === 'laser') {
                            ctx.fillStyle = 'rgba(255, 107, 53, 0.8)';
                            ctx.fillRect(b.x, b.y - 15, b.width + 2, b.height + 30);
                            if (b.bloom) {
                                ctx.globalAlpha = baseAlpha * b.bloomIntensity * 0.3;
                                for (let i = 2; i <= 4; i++) {
                                    ctx.fillStyle = b.color;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, b.width * i, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            if (b.flicker) {
                                ctx.globalAlpha = baseAlpha * (0.5 + Math.sin(now * b.flickerRate * 0.01) * 0.5);
                            }

                            if (b.ghosting && b.ghostCount > 0) {
                                for (let i = 1; i < Math.min(b.ghostCount, 5); i++) {
                                    ctx.globalAlpha = baseAlpha * b.ghostAlpha * (1 - i / b.ghostCount);
                                    ctx.fillStyle = b.color;
                                    ctx.fillRect(-b.width / 2 - i * 2, -b.height / 2 - i * 2, b.width, b.height);
                                }
                            }

                            if (b.harmonic) {
                                ctx.globalAlpha = baseAlpha * 0.4;
                                const harmWave = Math.sin(now * b.harmonicFreq) * b.harmonicAmplitude;
                                ctx.strokeStyle = b.color;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(-b.width, harmWave);
                                for (let x = -b.width; x <= b.width; x += b.width / 5) {
                                    ctx.lineTo(x, Math.sin(x * b.harmonicFreq) * b.harmonicAmplitude);
                                }
                                ctx.stroke();
                            }

                            ctx.globalAlpha = baseAlpha;
                            ctx.fillStyle = b.color;
                            ctx.rotate((b.rotation || 0) * Math.PI / 180);
                            ctx.scale(b.scale || 1, b.scale || 1);
                            ctx.fillRect(-b.width / 2, -b.height / 2, b.width, b.height);

                            ctx.restore();
                            ctx.globalAlpha = 1;
                        } else {
                            ctx.fillRect(b.x, b.y, b.width, b.height);
                        }
                        ctx.globalAlpha = 1; // Reset alpha
                    });

                    // Draw enemies
                    enemies.forEach(e => {
                        ctx.fillStyle = e.typeData ? e.typeData.color : '#00ff00';
                        ctx.fillRect(e.x, e.y, e.width, e.height);

                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(e.typeData ? e.typeData.symbol : '', e.x + e.width / 2, e.y + e.height / 2 + 4);

                        const ratio = e.health / e.maxHealth;
                        ctx.fillStyle = '#333';
                        ctx.fillRect(e.x, e.y - 8, e.width, 5);
                        ctx.fillStyle = ratio > 0.5 ? '#00ff00' : ratio > 0.25 ? '#ffff00' : '#ff0000';
                        ctx.fillRect(e.x, e.y - 8, e.width * ratio, 5);
                    });

                    // Draw boss
                    if (boss) {
                        ctx.fillStyle = boss.typeData ? boss.typeData.color : '#ff6600';
                        ctx.fillRect(boss.x, boss.y, boss.width, boss.height);

                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(boss.typeData ? boss.typeData.symbol : '', boss.x + boss.width / 2, boss.y + boss.height / 2 + 6);

                        const ratio = boss.health / boss.maxHealth;
                        ctx.fillStyle = '#333';
                        ctx.fillRect(100, 480, 400, 15);
                        ctx.fillStyle = ratio > 0.5 ? '#00ff00' : ratio > 0.25 ? '#ffff00' : '#ff0000';
                        ctx.fillRect(100, 480, 400 * ratio, 15);

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'left';
                        const bossName = boss.typeData ? boss.typeData.name : 'Boss';
                        ctx.fillText(`${bossName} HP: ${Math.max(0, Math.ceil(boss.health))}/${Math.ceil(boss.maxHealth)}`, 110, 492);
                    }

                    // Draw enemy bullets
                    ctx.fillStyle = '#ff00ff';
                    enemyBullets.forEach(b => {
                        ctx.fillRect(b.x - 2, b.y, 4, b.height);
                    });

                    // Draw player with shield
                    if (activePowerups.invincibility && now < activePowerups.invincibility) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.fillRect(player.x - 10, player.y - 10, player.width + 20, player.height + 20);
                    }

                    if (player.shield > 0) {
                        ctx.strokeStyle = '#06ffa5';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 45, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.fillText('', player.x + player.width / 2 - 4, player.y + 16);

                    // =============== HUD ===============
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`Score: ${score}`, 10, 25);
                    ctx.fillText(`Level: ${level}`, 10, 45);
                    ctx.fillText(`Lives: ${lives}/${maxLives}`, 10, 65);

                    ctx.font = '11px Arial';
                    ctx.fillText(`Weapon: ${weapons[currentWeapon].name}`, 10, 85);
                    ctx.fillText(`Kills: ${totalKills} | Shots: ${totalShotsFired}`, 10, 100);

                    // Weapon indicator
                    ctx.fillStyle = weapons[currentWeapon].color;
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`[${currentWeapon.toUpperCase()}]`, 520, 25);

                    // Player health
                    ctx.fillStyle = '#333';
                    ctx.fillRect(450, 480, 140, 10);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(450, 480, 140 * (player.health / player.maxHealth), 10);
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.fillText(`HP: ${Math.max(0, player.health)}/${player.maxHealth}`, 455, 492);

                    // Active powerups display
                    let puY = 120;
                    Object.keys(activePowerups).forEach(key => {
                        const remaining = Math.ceil((activePowerups[key] - now) / 1000);
                        if (remaining > 0) {
                            ctx.fillStyle = '#06ffa5';
                            ctx.fillText(`${powerups[key].icon} ${powerups[key].name}: ${remaining}s`, 10, puY);
                            puY += 16;
                        }
                    });

                    // =============== END GAME SCREENS ===============
                    if (!gameRunning && !gameWon) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                        ctx.fillRect(0, 0, 600, 500);
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 40px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', 300, 150);
                        ctx.fillStyle = '#fff';
                        ctx.font = '18px Arial';
                        ctx.fillText(`Final Score: ${score}`, 300, 200);
                        ctx.fillText(`Level Reached: ${level}`, 300, 230);
                        ctx.fillText(`Enemies Defeated: ${totalKills}`, 300, 260);
                        ctx.fillText(`Accuracy: ${Math.round((totalKills / Math.max(1, totalShotsFired)) * 100)}%`, 300, 290);
                    }

                    if (gameWon) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                        ctx.fillRect(0, 0, 600, 500);
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(' YOU WON! ', 300, 140);
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText('Boss Defeated!', 300, 200);
                        ctx.fillStyle = '#fff';
                        ctx.font = '16px Arial';
                        ctx.fillText(`Final Score: ${score}`, 300, 250);
                        ctx.fillText(`Total Kills: ${totalKills}`, 300, 280);
                        ctx.fillText(`Damage Taken: ${totalDamageTaken}`, 300, 310);
                    }

                    ctx.textAlign = 'left';
                    requestAnimationFrame(update);

                } catch (err) {
                    console.error('Mega Game Error:', err);
                    try {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, 600, 500);
                        ctx.fillStyle = '#ff4444';
                        ctx.font = '12px Arial';
                        ctx.fillText('Error: ' + err.message, 10, 20);
                    } catch (e2) {
                        alert('Mega Game Error: ' + err.message);
                    }
                    gameRunning = false;
                }
            }

            update();
        }

        // Mega Game event listeners
        document.getElementById('megaLives3')?.addEventListener('click', () => {
            document.getElementById('megagameMenu').style.display = 'none';
            document.getElementById('megagamePlay').style.display = 'block';
            initMegaGame(3);
        });
        document.getElementById('megaLives5')?.addEventListener('click', () => {
            document.getElementById('megagameMenu').style.display = 'none';
            document.getElementById('megagamePlay').style.display = 'block';
            initMegaGame(5);
        });
        document.getElementById('megaLives10')?.addEventListener('click', () => {
            document.getElementById('megagameMenu').style.display = 'none';
            document.getElementById('megagamePlay').style.display = 'block';
            initMegaGame(10);
        });

        // ========== PAC-MAN ==========
        function initPacMan() {
            const canvas = document.getElementById('pacmanCanvas');
            const ctx = canvas.getContext('2d');
            const GRID_SIZE = 20;
            const COLS = 25;
            const ROWS = 25;

            let score = 0;
            let lives = 3;
            let gameRunning = true;
            let pelletsLeft = COLS * ROWS - 10;

            const pacman = { x: 12, y: 12, direction: 0, nextDirection: 0 };
            const ghosts = [
                { x: 5, y: 5, color: '#ff0000', dirIndex: 0 },
                { x: 20, y: 5, color: '#ffb6c1', dirIndex: 1 },
                { x: 5, y: 20, color: '#00ffff', dirIndex: 2 },
                { x: 20, y: 20, color: '#ffb347', dirIndex: 3 }
            ];

            const maze = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
            const pellets = Array(ROWS).fill(null).map(() => Array(COLS).fill(1));

            for (let i = 0; i < COLS; i++) {
                maze[0][i] = 1;
                maze[ROWS - 1][i] = 1;
            }
            for (let i = 0; i < ROWS; i++) {
                maze[i][0] = 1;
                maze[i][COLS - 1] = 1;
            }

            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') pacman.nextDirection = 0;
                if (e.key === 'ArrowRight') pacman.nextDirection = 1;
                if (e.key === 'ArrowDown') pacman.nextDirection = 2;
                if (e.key === 'ArrowLeft') pacman.nextDirection = 3;
            });

            function isWall(x, y) {
                return x < 0 || x >= COLS || y < 0 || y >= ROWS || maze[y][x] === 1;
            }

            function update() {
                if (!gameRunning) return;

                const nextX = pacman.x + directions[pacman.nextDirection][0];
                const nextY = pacman.y + directions[pacman.nextDirection][1];
                if (!isWall(nextX, nextY)) pacman.direction = pacman.nextDirection;

                const moveX = pacman.x + directions[pacman.direction][0];
                const moveY = pacman.y + directions[pacman.direction][1];
                if (!isWall(moveX, moveY)) {
                    pacman.x = moveX;
                    pacman.y = moveY;
                }

                if (pellets[pacman.y][pacman.x] === 1) {
                    pellets[pacman.y][pacman.x] = 0;
                    score += 10;
                    pelletsLeft--;
                    if (pelletsLeft === 0) gameRunning = false;
                }

                ghosts.forEach(g => {
                    g.dirIndex = (g.dirIndex + Math.floor(Math.random() * 2)) % 4;
                    let gx = g.x + directions[g.dirIndex][0];
                    let gy = g.y + directions[g.dirIndex][1];
                    if (!isWall(gx, gy)) {
                        g.x = gx;
                        g.y = gy;
                    }
                    if (g.x === pacman.x && g.y === pacman.y) {
                        lives--;
                        if (lives <= 0) gameRunning = false;
                        else {
                            pacman.x = 12;
                            pacman.y = 12;
                        }
                    }
                });

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (maze[i][j] === 1) {
                            ctx.fillStyle = '#0000ff';
                            ctx.fillRect(j * GRID_SIZE, i * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        }
                    }
                }

                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (pellets[i][j] === 1) {
                            ctx.fillStyle = '#ffb897';
                            ctx.beginPath();
                            ctx.arc(j * GRID_SIZE + GRID_SIZE / 2, i * GRID_SIZE + GRID_SIZE / 2, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(pacman.x * GRID_SIZE + GRID_SIZE / 2, pacman.y * GRID_SIZE + GRID_SIZE / 2, GRID_SIZE / 2 - 2, 0, Math.PI * 2);
                ctx.fill();

                ghosts.forEach(g => {
                    ctx.fillStyle = g.color;
                    ctx.fillRect(g.x * GRID_SIZE + 2, g.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                });

                if (!gameRunning) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, 500, 500);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    if (pelletsLeft === 0) {
                        ctx.fillText('YOU WIN!', 250, 240);
                    } else {
                        ctx.fillText('GAME OVER', 250, 240);
                    }
                    ctx.fillText(`Score: ${score}`, 250, 280);
                }

                document.getElementById('pacmanScore').textContent = score;
                document.getElementById('pacmanLives').textContent = lives;
                requestAnimationFrame(update);
            }
            update();
        }

        // ========== JUMPING SHAPE ==========
        function initJumpingShape() {
            const canvas = document.getElementById('jumpingShapeCanvas');
            const ctx = canvas.getContext('2d');
            let score = 0;
            let best = parseInt(localStorage.getItem('jumpingShapeBest')) || 0;
            let gameRunning = true;

            const player = { x: 250, y: 400, width: 30, height: 30, velocityY: 0, isJumping: false };
            const obstacles = [];
            const gravity = 0.6;
            const jumpPower = 15;

            let obstacleSpeed = 5;
            let spawnRate = 0.02;

            function spawnObstacle() {
                if (Math.random() < spawnRate) {
                    const size = 20 + Math.random() * 20;
                    obstacles.push({
                        x: 500,
                        y: 400 + Math.random() * 50,
                        width: size,
                        height: size
                    });
                }
            }

            window.addEventListener('keydown', (e) => {
                if ((e.key === ' ' || e.key === 'ArrowUp') && !player.isJumping && gameRunning) {
                    player.velocityY = -jumpPower;
                    player.isJumping = true;
                    e.preventDefault();
                }
            });

            canvas.addEventListener('click', () => {
                if (!player.isJumping && gameRunning) {
                    player.velocityY = -jumpPower;
                    player.isJumping = true;
                }
            });

            function update() {
                if (!gameRunning) return;

                player.velocityY += gravity;
                player.y += player.velocityY;

                if (player.y >= 400) {
                    player.y = 400;
                    player.isJumping = false;
                    player.velocityY = 0;
                }

                spawnObstacle();

                obstacles.forEach((o, i) => {
                    o.x -= obstacleSpeed;
                    if (o.x + o.width < 0) {
                        obstacles.splice(i, 1);
                        score++;
                        if (score % 5 === 0) {
                            obstacleSpeed += 0.5;
                            spawnRate += 0.002;
                        }
                    }

                    if (player.x < o.x + o.width &&
                        player.x + player.width > o.x &&
                        player.y < o.y + o.height &&
                        player.y + player.height > o.y) {
                        gameRunning = false;
                    }
                });

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                ctx.fillStyle = '#ff0000';
                obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.width, o.height));

                ctx.fillStyle = '#888';
                ctx.fillRect(0, 430, 500, 70);

                if (!gameRunning) {
                    if (score > best) {
                        best = score;
                        localStorage.setItem('jumpingShapeBest', best);
                    }
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, 500, 500);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 250, 220);
                    ctx.fillText(`Score: ${score}`, 250, 260);
                    ctx.fillText(`Best: ${best}`, 250, 300);
                }

                document.getElementById('jumpingShapeScore').textContent = score;
                document.getElementById('jumpingShapeBest').textContent = best;
                requestAnimationFrame(update);
            }
            update();
        }

        // ========== MEMORY FLIP ==========
        function initMemoryFlip() {
            const board = document.getElementById('memoryFlipBoard');
            board.innerHTML = '';
            const movesDisplay = document.getElementById('memoryFlipMoves');
            const matchedDisplay = document.getElementById('memoryFlipMatched');

            let moves = 0;
            let matched = 0;
            let firstCard = null;
            let secondCard = null;
            let canFlip = true;

            const cards = Array.from({ length: 16 }, (_, i) => (i % 8) + 1);
            cards.sort(() => Math.random() - 0.5);

            const cardElements = [];

            cards.forEach((num, idx) => {
                const card = document.createElement('div');
                card.style.cssText = 'width:80px;height:80px;background:linear-gradient(135deg,#667eea,#764ba2);border:3px solid #9099ff;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:32px;font-weight:bold;color:transparent;transition:all 0.3s;user-select:none';
                card.dataset.value = num;
                card.dataset.index = idx;
                card.flipped = false;
                card.matched = false;

                card.addEventListener('click', () => {
                    if (!canFlip || card.matched || card.flipped) return;
                    card.style.color = '#ffffff';
                    card.textContent = num;
                    card.flipped = true;

                    if (!firstCard) {
                        firstCard = card;
                    } else if (!secondCard) {
                        secondCard = card;
                        canFlip = false;
                        moves++;
                        movesDisplay.textContent = moves;

                        if (firstCard.dataset.value === secondCard.dataset.value) {
                            firstCard.matched = true;
                            secondCard.matched = true;
                            firstCard.style.opacity = '0.5';
                            secondCard.style.opacity = '0.5';
                            matched++;
                            matchedDisplay.textContent = matched + '/8';
                            firstCard = null;
                            secondCard = null;
                            canFlip = true;

                            if (matched === 8) {
                                setTimeout(() => {
                                    alert(` You won in ${moves} moves!`);
                                }, 300);
                            }
                        } else {
                            setTimeout(() => {
                                firstCard.style.color = 'transparent';
                                firstCard.textContent = '?';
                                firstCard.flipped = false;
                                secondCard.style.color = 'transparent';
                                secondCard.textContent = '?';
                                secondCard.flipped = false;
                                firstCard = null;
                                secondCard = null;
                                canFlip = true;
                            }, 1000);
                        }
                    }
                });

                board.appendChild(card);
                cardElements.push(card);
            });
        }

        // ========== BALL PUSHER ==========
        function initBallPusher() {
            const canvas = document.getElementById('ballPusherCanvas');
            const ctx = canvas.getContext('2d');
            let score = 0;
            let level = 1;
            let gameRunning = true;

            const player = { x: 250, y: 400, width: 40, height: 40, speed: 4 };
            const balls = [];
            const goals = [];
            let enemyBullets = [];
            function createLevel() {
                const lasers = [];
                const explosions = [];
                balls.length = 0;
                goals.length = 0;
                for (let i = 0; i < level + 2; i++) {
                    balls.push({
                        x: 50 + Math.random() * 300,
                        y: 50 + Math.random() * 300,
                        radius: 10,
                        vx: 0,
                        vy: 0
                    });
                }
                for (let i = 0; i < 2; i++) {
                    goals.push({
                        x: i * 400 + 50,
                        y: 100,
                        width: 60,
                        height: 60,
                        ballsIn: 0
                    });
                }
            }

            createLevel();

            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            function update() {
                if (!gameRunning) return;

                if (keys['ArrowLeft']) player.x -= player.speed;
                if (keys['ArrowRight']) player.x += player.speed;
                if (keys['ArrowUp']) player.y -= player.speed;
                if (keys['ArrowDown']) player.y += player.speed;

                player.x = Math.max(0, Math.min(460, player.x));
                player.y = Math.max(0, Math.min(460, player.y));

                balls.forEach(b => {
                    b.vx *= 0.98;
                    b.vy *= 0.98;
                    b.x += b.vx;
                    b.y += b.vy;

                    if (b.x - b.radius < 0 || b.x + b.radius > 500) b.vx *= -0.8;
                    if (b.y - b.radius < 0 || b.y + b.radius > 500) b.vy *= -0.8;

                    b.x = Math.max(b.radius, Math.min(500 - b.radius, b.x));
                    b.y = Math.max(b.radius, Math.min(500 - b.radius, b.y));

                    const dx = player.x + player.width / 2 - b.x;
                    const dy = player.y + player.height / 2 - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < b.radius + 20) {
                        const angle = Math.atan2(dy, dx);
                        b.vx = Math.cos(angle) * 8;
                        b.vy = Math.sin(angle) * 8;
                    }
                });

                for (let i = balls.length - 1; i >= 0; i--) {
                    for (let j = 0; j < goals.length; j++) {
                        if (balls[i].x > goals[j].x && balls[i].x < goals[j].x + goals[j].width &&
                            balls[i].y > goals[j].y && balls[i].y < goals[j].y + goals[j].height) {
                            goals[j].ballsIn++;
                            score += 50;
                            balls.splice(i, 1);
                            break;
                        }
                    }
                }

                if (balls.length === 0) {
                    level++;
                    createLevel();
                }

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                ctx.fillStyle = '#ffff00';
                balls.forEach(b => {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                goals.forEach(g => {
                    ctx.fillStyle = '#0000ff';
                    ctx.fillRect(g.x, g.y, g.width, g.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(g.ballsIn, g.x + g.width / 2, g.y + g.height / 2 + 5);
                });

                document.getElementById('ballPusherScore').textContent = score;
                document.getElementById('ballPusherLevel').textContent = level;
                requestAnimationFrame(update);
            }
            update();
        }

        // ========== NUMBER CHAIN ==========
        function initNumberChain() {
            const board = document.getElementById('numberChainBoard');
            board.innerHTML = '';
            const scoreDisplay = document.getElementById('numberChainScore');
            const chainsDisplay = document.getElementById('numberChainChains');

            let score = 0;
            let chains = 0;
            let selectedTiles = [];

            const numbers = Array.from({ length: 25 }, (_, i) => (i % 5) + 1);
            numbers.sort(() => Math.random() - 0.5);

            numbers.forEach((num, idx) => {
                const tile = document.createElement('div');
                tile.style.cssText = 'padding:15px;background:linear-gradient(135deg,#667eea,#764ba2);color:white;text-align:center;border-radius:8px;cursor:pointer;font-weight:bold;font-size:18px;transition:all 0.2s;user-select:none;border:3px solid #9099ff';
                tile.textContent = num;
                tile.dataset.value = num;
                tile.dataset.index = idx;
                tile.selected = false;

                tile.addEventListener('mouseenter', () => {
                    if (!tile.selected) {
                        tile.style.transform = 'scale(1.05)';
                    }
                });

                tile.addEventListener('mouseleave', () => {
                    if (!tile.selected) {
                        tile.style.transform = 'scale(1)';
                    }
                });

                tile.addEventListener('click', () => {
                    if (tile.selected) {
                        selectedTiles = selectedTiles.filter(t => t !== tile);
                        tile.selected = false;
                        tile.style.background = 'linear-gradient(135deg,#667eea,#764ba2)';
                        tile.style.transform = 'scale(1)';
                        return;
                    }

                    if (selectedTiles.length === 0) {
                        tile.selected = true;
                        selectedTiles.push(tile);
                        tile.style.background = 'linear-gradient(135deg,#ffaa00,#ff6666)';
                        tile.style.transform = 'scale(1.1)';
                    } else if (selectedTiles[selectedTiles.length - 1].dataset.value == tile.dataset.value) {
                        tile.selected = true;
                        selectedTiles.push(tile);
                        tile.style.background = 'linear-gradient(135deg,#ffaa00,#ff6666)';
                        score += 10 * selectedTiles.length;
                        scoreDisplay.textContent = score;

                        if (selectedTiles.length >= 3) {
                            chains++;
                            chainsDisplay.textContent = chains;
                            setTimeout(() => {
                                selectedTiles.forEach(t => {
                                    t.style.opacity = '0';
                                    setTimeout(() => t.remove(), 200);
                                });
                                selectedTiles = [];
                            }, 300);
                        }
                    } else {
                        selectedTiles = [];
                        tile.selected = true;
                        selectedTiles.push(tile);
                        tile.style.background = 'linear-gradient(135deg,#ffaa00,#ff6666)';
                        tile.style.transform = 'scale(1.1)';
                    }
                });

                board.appendChild(tile);
            });
        }

        // ========== ASTEROID FIGHTER ==========
        function initAsteroidFighter() {
            const canvas = document.getElementById('asteroidFighterCanvas');
            const ctx = canvas.getContext('2d');
            let score = 0;
            let wave = 1;
            let gameRunning = true;

            const player = { x: 250, y: 450, angle: 0, r: 15 };
            const bullets = [];
            const enemies = [];
            let enemyCount = 3 + wave * 2;
            let enemiesDefeated = 0;

            function spawnEnemies() {
                for (let i = 0; i < enemyCount; i++) {
                    enemies.push({
                        x: Math.random() * 500,
                        y: Math.random() * 200,
                        vx: (Math.random() - 0.5) * 3,
                        vy: (Math.random() - 0.5) * 3 + 1,
                        radius: 15,
                        health: 1
                    });
                }
            }

            spawnEnemies();

            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if (e.key === ' ') {
                    bullets.push({
                        x: player.x + Math.cos(player.angle) * player.r,
                        y: player.y + Math.sin(player.angle) * player.r,
                        vx: Math.cos(player.angle) * 6,
                        vy: Math.sin(player.angle) * 6
                    });
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', (e) => keys[e.key] = false);

            function update() {
                if (!gameRunning) return;

                if (keys['ArrowLeft']) player.angle -= 0.1;
                if (keys['ArrowRight']) player.angle += 0.1;

                bullets.forEach((b, i) => {
                    b.x += b.vx;
                    b.y += b.vy;
                    if (b.x < 0 || b.x > 500 || b.y < 0 || b.y > 500) {
                        bullets.splice(i, 1);
                    }
                });

                enemies.forEach(e => {
                    e.x += e.vx;
                    e.y += e.vy;

                    if (e.x < 0 || e.x > 500) e.vx *= -1;
                    if (e.y < 0 || e.y > 500) e.vy *= -1;

                    const dx = player.x - e.x;
                    const dy = player.y - e.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < player.r + e.radius) {
                        gameRunning = false;
                    }
                });

                for (let i = bullets.length - 1; i >= 0; i--) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const dx = bullets[i].x - enemies[j].x;
                        const dy = bullets[i].y - enemies[j].y;
                        if (Math.sqrt(dx * dx + dy * dy) < enemies[j].radius + 2) {
                            score += 100;
                            enemiesDefeated++;
                            if (Math.random() < 0.2) {
                                const puTypes = ['damageBoost', 'speedBoost', 'fireRateBoost', 'invincibility', 'shield'];
                                const randomType = puTypes[Math.floor(Math.random() * puTypes.length)];
                                powerUps.push({ x: enemies[j].x, y: enemies[j].y, width: 15, height: 15, type: randomType });
                            }
                            bullets.splice(i, 1);
                            enemies.splice(j, 1);
                            break;
                        }
                    }
                }

                if (enemies.length === 0) {
                    wave++;
                    enemyCount = 3 + wave * 2;
                    enemiesDefeated = 0;
                    spawnEnemies();
                }

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.angle);
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, -10);
                ctx.lineTo(-5, 0);
                ctx.lineTo(-10, 10);
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                ctx.fillStyle = '#ffff00';
                bullets.forEach(b => {
                    ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
                });

                ctx.fillStyle = '#ff0000';
                enemies.forEach(e => {
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                document.getElementById('asteroidFighterScore').textContent = score;
                document.getElementById('asteroidFighterWave').textContent = wave;
                requestAnimationFrame(update);
            }
            update();
        }

        // ========== FAST CLICKER ==========
        function initFastClicker() {
            let clicks = 0;
            let timeLeft = 30;
            const countDisplay = document.getElementById('fastClickerCount');
            const timeDisplay = document.getElementById('fastClickerTime');
            const button = document.getElementById('fastClickerBtn');
            const message = document.getElementById('fastClickerMessage');

            button.addEventListener('click', () => {
                if (timeLeft > 0) {
                    clicks++;
                    countDisplay.textContent = clicks;
                    button.style.transform = 'scale(0.95)';
                    setTimeout(() => { button.style.transform = 'scale(1)'; }, 100);
                }
            });

            const timer = setInterval(() => {
                timeLeft--;
                timeDisplay.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    message.textContent = `Game Over! You clicked ${clicks} times!`;
                }
            }, 1000);

            console.log('Fast Clicker initialized');
        }

        // ========== NEW GAMES ==========
        // Generic game initializer for simple games
        function initSimpleGame(gameName, difficulty = 'easy') {
            let score = 0;
            let lives = 3;
            let gameActive = true;
            let gameLevel = 1;

            const scoreDisplay = document.getElementById(`${gameName}Score`);
            const livesDisplay = document.getElementById(`${gameName}Lives`);
            const levelDisplay = document.getElementById(`${gameName}Level`);
            const gameArea = document.getElementById(`${gameName}GameArea`);
            const pauseBtn = document.getElementById(`${gameName}Pause`);
            const soundToggle = document.getElementById(`${gameName}Sound`);

            let soundEnabled = true;
            let isPaused = false;

            if (soundToggle) {
                soundToggle.addEventListener('click', () => {
                    soundEnabled = !soundEnabled;
                    soundToggle.textContent = soundEnabled ? '' : '';
                });
            }

            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    isPaused = !isPaused;
                    pauseBtn.textContent = isPaused ? ' Resume' : ' Pause';
                });
            }

            function updateDisplay() {
                if (scoreDisplay) scoreDisplay.textContent = score;
                if (livesDisplay) livesDisplay.textContent = lives;
                if (levelDisplay) levelDisplay.textContent = gameLevel;
            }

            function addScore(points) {
                score += points;
                updateDisplay();
            }

            function loseLife() {
                lives--;
                updateDisplay();
                if (lives <= 0) {
                    gameActive = false;
                }
            }

            updateDisplay();
            return { addScore, loseLife, updateDisplay, isPaused: () => isPaused };
        }
        //=============== Initalizer for Mid games ===============//
        function initMediumGame(nameOfTheGame, diffucility2 = 'medium', lives28) {
            let score = 0;
            lives28 = 81;
            let gameActive2 = true;
            var gameLevel2 = 1;

            const scoreDisplay2 = document.getElementById(`${gameName}Score`);
            const livesDisplay2 = document.getElementById(`${gameName}Lives`);
            const levelDisplay2 = document.getElementById(`${gameName}Level`);
            const gameArea2 = document.getElementById(`${gameName}GameArea`);
            const pauseBtn2 = document.getElementById(`${gameName}Pause`);
            const soundToggle2 = document.getElementById(`${gameName}Sound`);

            if (soundToggle) {
                soundToggle.addEventListener('click', () => {
                    soundEnabled = !soundEnabled;
                    soundToggle.textContent = soundEnabled ? '' : '';
                });
            }
            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    isPaused = !isPaused;
                    pauseBtn.textContent = isPaused ? ' Resume' : ' Pause';
                });
            }

            function updateDisplay() {
                if (scoreDisplay) scoreDisplay.textContent = score;
                if (livesDisplay) livesDisplay.textContent = lives;
                if (levelDisplay) levelDisplay.textContent = gameLevel;
            }

            function addScore(points) {
                score += points;
                updateDisplay();
            }

            function loseLife() {
                lives28--;
                updateDisplay();
                if (lives <= 0) {
                    gameActive = false;
                }
            }

            updateDisplay();
            return { addScore, loseLife, updateDisplay, isPaused: () => isPaused };
        }

        let soundEnabled = true;
        let isPaused = false;
        class isNotPaused {
            constructor(game) {
                this.game = game;
            }
            check() {
                return !this.game.isNotPaused();
            }
        }

        // Zombie Runner
        function initZombieRunner() {
            const game = initSimpleGame('zombierunner');
            const canvas = document.getElementById('zombierunnerCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const player = { x: 250, y: 450, width: 30, height: 30, speed: 6 };
            const zombies = [];
            let obstacleCount = 0;

            function spawnZombie() {
                zombies.push({ x: Math.random() * 500, y: -30, width: 25, height: 25, speed: 2 });
            }

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') player.x -= player.speed;
                if (e.key === 'ArrowRight') player.x += player.speed;
                player.x = Math.max(0, Math.min(500 - player.width, player.x));
            });

            function animate() {
                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                if (Math.random() < 0.02) spawnZombie();

                zombies.forEach((z, i) => {
                    z.y += z.speed;
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(z.x, z.y, z.width, z.height);

                    if (z.x < player.x + player.width && z.x + z.width > player.x &&
                        z.y < player.y + player.height && z.y + z.height > player.y) {
                        game.loseLife();
                        zombies.splice(i, 1);
                    }
                    if (z.y > 500) {
                        game.addScore(10);
                        zombies.splice(i, 1);
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        // Memory Match
        function initMemoryMatch() {
            const game = initSimpleGame('memorymatch');
            const gameArea = document.getElementById('memorymatchGameArea');
            if (!gameArea) return;

            const pairs = 8;
            const cards = [];
            let firstCard = null;
            let matched = 0;

            const symbols = ['', '', '', '', '', '', '', ''];
            const deck = [...symbols, ...symbols].sort(() => Math.random() - 0.5);

            gameArea.innerHTML = '';
            gameArea.style.display = 'grid';
            gameArea.style.gridTemplateColumns = 'repeat(4, 1fr)';
            gameArea.style.gap = '10px';
            gameArea.style.padding = '20px';

            deck.forEach((symbol, i) => {
                const card = document.createElement('div');
                card.textContent = '?';
                card.style.cssText = 'width:70px;height:70px;display:flex;align-items:center;justify-content:center;font-size:30px;background:#667eea;cursor:pointer;border-radius:8px;user-select:none';
                card.dataset.symbol = symbol;
                card.dataset.index = i;
                card.addEventListener('click', () => flipCard(card));
                gameArea.appendChild(card);
                cards.push(card);
            });

            function flipCard(card) {
                if (card.classList.contains('flipped') || !firstCard || firstCard === card) return;

                card.textContent = card.dataset.symbol;
                card.style.background = '#667eea';
                card.classList.add('flipped');

                if (!firstCard) {
                    firstCard = card;
                } else {
                    if (firstCard.dataset.symbol === card.dataset.symbol) {
                        firstCard.style.opacity = '0.5';
                        card.style.opacity = '0.5';
                        game.addScore(10);
                        matched++;
                        firstCard = null;
                        if (matched === pairs) alert(`You won with score ${game.score}!`);
                    } else {
                        setTimeout(() => {
                            firstCard.textContent = '?';
                            card.textContent = '?';
                            firstCard.classList.remove('flipped');
                            card.classList.remove('flipped');
                            firstCard.style.background = '#667eea';
                            card.style.background = '#667eea';
                            firstCard = null;
                        }, 800);
                    }
                }
            }
        }

        // Dino Jump
        function initDinoJump() {
            const game = initSimpleGame('dinojump');
            const canvas = document.getElementById('dinojumpCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const dino = { x: 50, y: 380, width: 30, height: 40, velocityY: 0, jumping: false };
            const obstacles = [];
            let isJumping = false;

            window.addEventListener('keydown', (e) => {
                if ((e.key === ' ' || e.key === 'ArrowUp') && !isJumping) {
                    dino.velocityY = -15;
                    isJumping = true;
                }
            });

            function animate() {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#654321';
                ctx.fillRect(dino.x, dino.y, dino.width, dino.height);

                dino.velocityY += 0.5;
                dino.y += dino.velocityY;

                if (dino.y > 420) {
                    dino.y = 420;
                    isJumping = false;
                }

                if (Math.random() < 0.01) {
                    obstacles.push({ x: 500, y: 420, width: 20, height: 20 });
                }

                obstacles.forEach((obs, i) => {
                    obs.x -= 8;
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (obs.x + obs.width > dino.x && obs.x < dino.x + dino.width &&
                        obs.y + obs.height > dino.y && obs.y < dino.y + dino.height) {
                        game.loseLife();
                        obstacles.splice(i, 1);
                    }
                    if (obs.x < -20) {
                        game.addScore(5);
                        obstacles.splice(i, 1);
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        // Block Blast
        function initBlockBlast() {
            const game = initSimpleGame('blockblast');
            const canvas = document.getElementById('blockblastCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const cols = 6;
            const rows = 12;
            const cellSize = 50;
            const grid = Array(rows).fill(null).map(() => Array(cols).fill(0));
            let fallingBlock = null;

            function createBlock() {
                return { x: 2, y: 0, shape: 'I' };
            }

            function drawGrid() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, cols * cellSize, rows * cellSize);

                grid.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            ctx.fillStyle = '#667eea';
                            ctx.fillRect(c * cellSize, r * cellSize, cellSize - 2, cellSize - 2);
                        }
                        ctx.strokeStyle = '#333';
                        ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
                    });
                });
            }

            function animate() {
                drawGrid();
                requestAnimationFrame(animate);
            }

            animate();
        }

        // Bubble Shooter
        function initBubbleShooter() {
            const game = initSimpleGame('bubbleshooter');
            const canvas = document.getElementById('bubbleshooterCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const bubbles = [];
            const player = { x: 250, y: 480, angle: 0 };

            function drawBubbles() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                bubbles.forEach(b => {
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function animate() {
                drawBubbles();
                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== SPACE SHOOTER ==========
        function initSpaceShooter() {
            const game = initSimpleGame('spaceshooter');
            const canvas = document.getElementById('spaceshooterCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const player = { x: 225, y: 450, width: 25, height: 35, speed: 5 };
            const bullets = [];
            const enemies = [];
            let enemySpawnRate = 0.02;
            let gameRunning = true;

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') player.x -= player.speed;
                if (e.key === 'ArrowRight') player.x += player.speed;
                if (e.key === ' ') bullets.push({ x: player.x + 12, y: player.y, vx: 0, vy: -8 });
                player.x = Math.max(0, Math.min(500 - player.width, player.x));
            });

            function animate() {
                ctx.fillStyle = 'rgba(10, 14, 39, 0.3)';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                if (Math.random() < enemySpawnRate) {
                    enemies.push({ x: Math.random() * 475, y: -20, width: 20, height: 20, vy: 2 });
                }

                bullets.forEach((b, bi) => {
                    b.y += b.vy;
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(b.x, b.y, 4, 8);
                    if (b.y < -10) bullets.splice(bi, 1);
                });

                enemies.forEach((e, ei) => {
                    e.y += e.vy;
                    ctx.fillStyle = '#ff3333';
                    ctx.fillRect(e.x, e.y, e.width, e.height);

                    bullets.forEach((b, bi) => {
                        if (b.x < e.x + e.width && b.x + 4 > e.x && b.y < e.y + e.height && b.y + 8 > e.y) {
                            game.addScore(10);
                            if (Math.random() < 0.2) {
                                const puTypes = ['damageBoost', 'speedBoost', 'fireRateBoost', 'invincibility', 'shield'];
                                const randomType = puTypes[Math.floor(Math.random() * puTypes.length)];
                                powerUps.push({ x: e.x, y: e.y, width: 15, height: 15, type: randomType });
                            }
                            bullets.splice(bi, 1);
                            enemies.splice(ei, 1);
                        }
                    });

                    if (e.x < player.x + player.width && e.x + e.width > player.x &&
                        e.y < player.y + player.height && e.y + e.height > player.y) {
                        game.loseLife();
                        enemies.splice(ei, 1);
                    }
                    if (e.y > 500) enemies.splice(ei, 1);
                });

                if (gameRunning) requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== WHACK RATS ==========
        function initWhackRats() {
            const game = initSimpleGame('whackrats');
            const gameArea = document.getElementById('whackratsGameArea');
            if (!gameArea) return;

            gameArea.innerHTML = '';
            gameArea.style.display = 'grid';
            gameArea.style.gridTemplateColumns = 'repeat(3, 1fr)';
            gameArea.style.gap = '10px';
            gameArea.style.padding = '20px';

            let timeLeft = 30;
            let ratCount = 9;
            const holes = [];

            for (let i = 0; i < ratCount; i++) {
                const hole = document.createElement('div');
                hole.style.cssText = 'width:80px;height:80px;background:#8B4513;border-radius:50%;position:relative;cursor:pointer;overflow:hidden;border:3px solid #654321';
                hole.dataset.hasRat = 'false';

                const rat = document.createElement('div');
                rat.style.cssText = 'width:60px;height:60px;background:#996633;border-radius:50%;position:absolute;top:-60px;left:10px;transition:top 0.1s';
                rat.innerHTML = '';
                rat.style.fontSize = '40px';
                hole.appendChild(rat);

                hole.addEventListener('click', () => {
                    if (hole.dataset.hasRat === 'true') {
                        rat.style.top = '-60px';
                        hole.dataset.hasRat = 'false';
                        game.addScore(5);
                    }
                });

                gameArea.appendChild(hole);
                holes.push({ hole, rat });
            }

            const timer = setInterval(() => {
                holes.forEach(h => {
                    if (Math.random() < 0.3) {
                        h.hole.dataset.hasRat = 'true';
                        h.rat.style.top = '10px';
                        setTimeout(() => { h.rat.style.top = '-60px'; h.hole.dataset.hasRat = 'false'; }, 1000);
                    }
                });

                timeLeft--;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    alert(`Time's up! Final score: ${game.score}`);
                }
            }, 800);
        }

        // ========== CATCH FALLING ==========
        function initCatchFalling() {
            const game = initSimpleGame('catchfalling');
            const canvas = document.getElementById('catchfallingCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const basket = { x: 200, y: 450, width: 60, height: 30 };
            const items = [];

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') basket.x -= 10;
                if (e.key === 'ArrowRight') basket.x += 10;
                basket.x = Math.max(0, Math.min(500 - basket.width, basket.x));
            });

            function animate() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00aa00';
                ctx.fillRect(basket.x, basket.y, basket.width, basket.height);

                if (Math.random() < 0.03) {
                    items.push({ x: Math.random() * 480, y: 0, vy: 3, radius: 8 });
                }

                items.forEach((item, i) => {
                    item.y += item.vy;
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                    ctx.fill();

                    if (item.x > basket.x && item.x < basket.x + basket.width &&
                        item.y > basket.y && item.y < basket.y + basket.height) {
                        game.addScore(10);
                        items.splice(i, 1);
                    }
                    if (item.y > 500) {
                        game.loseLife();
                        items.splice(i, 1);
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== BRICK BREAKER ==========
        function initBrickBreaker() {
            const game = initSimpleGame('brickbreaker');
            const canvas = document.getElementById('brickbreakerCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const paddle = { x: 200, y: 480, width: 80, height: 12 };
            const ball = { x: 250, y: 400, vx: 3, vy: -3, radius: 5 };
            const bricks = [];

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 8; col++) {
                    bricks.push({ x: col * 60 + 2, y: row * 20 + 10, width: 58, height: 18, active: true });
                }
            }

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') paddle.x -= 15;
                if (e.key === 'ArrowRight') paddle.x += 15;
                paddle.x = Math.max(0, Math.min(500 - paddle.width, paddle.x));
            });

            function animate() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, 500, 500);

                ball.x += ball.vx;
                ball.y += ball.vy;

                if (ball.x - ball.radius < 0 || ball.x + ball.radius > 500) ball.vx *= -1;
                if (ball.y - ball.radius < 0) ball.vy *= -1;

                if (ball.y > 500) {
                    game.loseLife();
                    ball.x = 250; ball.y = 400;
                }

                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width &&
                    ball.y + ball.radius > paddle.y && ball.y < paddle.y + paddle.height) {
                    ball.vy *= -1;
                }

                bricks.forEach(b => {
                    if (b.active && ball.x > b.x && ball.x < b.x + b.width &&
                        ball.y > b.y && ball.y < b.y + b.height) {
                        b.active = false;
                        ball.vy *= -1;
                        game.addScore(10);
                    }
                });

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();

                bricks.forEach(b => {
                    if (b.active) {
                        ctx.fillStyle = '#667eea';
                        ctx.fillRect(b.x, b.y, b.width, b.height);
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== DEFEND CASTLE ==========
        function initDefendCastle() {
            const game = initSimpleGame('defendcastle');
            const canvas = document.getElementById('defendcastleCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const castle = { x: 225, y: 400, width: 50, height: 50, health: 100 };
            const enemies = [];
            const towers = [];
            let gameRunning = true;

            window.addEventListener('click', (e) => {
                if (canvas && e.target === canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    if (game.score >= 50) {
                        towers.push({ x, y, radius: 25, cooldown: 0 });
                        game.score -= 50;
                    }
                }
            });

            function animate() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#0099ff';
                ctx.fillRect(castle.x, castle.y, castle.width, castle.height);

                if (Math.random() < 0.02) {
                    enemies.push({ x: Math.random() * 500, y: 0, vy: 1.5, radius: 10 });
                }

                enemies.forEach((e, ei) => {
                    e.y += e.vy;
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                    ctx.fill();

                    if (Math.hypot(e.x - castle.x, e.y - castle.y) < 50) {
                        castle.health -= 10;
                        if (Math.random() < 0.2) {
                            const puTypes = ['damageBoost', 'speedBoost', 'fireRateBoost', 'invincibility', 'shield'];
                            const randomType = puTypes[Math.floor(Math.random() * puTypes.length)];
                            powerUps.push({ x: e.x, y: e.y, width: 15, height: 15, type: randomType });
                        }
                        enemies.splice(ei, 1);
                    }

                    towers.forEach(t => {
                        if (Math.hypot(e.x - t.x, e.y - t.y) < t.radius) {
                            game.addScore(5);
                            if (Math.random() < 0.2) {
                                const puTypes = ['damageBoost', 'speedBoost', 'fireRateBoost', 'invincibility', 'shield'];
                                const randomType = puTypes[Math.floor(Math.random() * puTypes.length)];
                                powerUps.push({ x: e.x, y: e.y, width: 15, height: 15, type: randomType });
                            }
                            enemies.splice(ei, 1);
                        }
                    });
                });

                towers.forEach(t => {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                    ctx.stroke();
                });

                if (castle.health <= 0) {
                    alert(`Castle destroyed! Score: ${game.score}`);
                    gameRunning = false;
                }

                if (gameRunning) requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== PIPE PUZZLE ==========
        function initPipePuzzle() {
            const game = initSimpleGame('pipepuzzle');
            const gameArea = document.getElementById('pipepuzzleGameArea');
            if (!gameArea) return;

            gameArea.innerHTML = '';
            gameArea.style.display = 'grid';
            gameArea.style.gridTemplateColumns = 'repeat(4, 1fr)';
            gameArea.style.gap = '5px';
            gameArea.style.padding = '20px';

            const pipeTypes = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '[', ']', '{', '}', '<', '>', ')', '('];
            const grid = Array(16).fill(null).map(() => pipeTypes[Math.floor(Math.random() * pipeTypes.length)]);

            grid.forEach((pipe, i) => {
                const cell = document.createElement('div');
                cell.style.cssText = 'width:60px;height:60px;background:#667eea;display:flex;align-items:center;justify-content:center;font-size:30px;cursor:pointer;border-radius:8px;user-select:none;color:white';
                cell.textContent = pipe;
                cell.dataset.rotation = 0;

                cell.addEventListener('click', () => {
                    const rotations = ['', '', '', ''];
                    const idx = rotations.indexOf(cell.textContent) + 1;
                    cell.textContent = rotations[idx % 4];
                    cell.dataset.rotation = idx % 4;
                    game.addScore(Math.ceil(Math.random() * 400));
                    if (game.score >= 1000000) {
                        alert('Congratulations! You solved the Pipe Puzzle and reached 1,000,000 points!');
                    }
                });

                gameArea.appendChild(cell);
            });
        }

        // ========== MATCH THREE ==========
        function initMatchThree() {
            const game = initSimpleGame('matchthree');
            const canvas = document.getElementById('matchthreeCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const cols = 5;
            const rows = 7;
            const cellSize = 60;
            const gems = ['', '', '', '', '',];
            let grid = Array(rows).fill(null).map(() => Array(cols).fill(null).map(() => gems[Math.floor(Math.random() * gems.length)]));

            function drawGrid() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, cols * cellSize, rows * cellSize);

                grid.forEach((row, r) => {
                    row.forEach((gem, c) => {
                        ctx.fillStyle = '#667eea';
                        ctx.fillRect(c * cellSize, r * cellSize, cellSize - 2, cellSize - 2);
                        ctx.font = 'bold 40px Arial';
                        ctx.fillText(gem, c * cellSize + 10, r * cellSize + 45);
                    });
                });
            }

            function animate() {
                drawGrid();
                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== PLATFORMER ==========
        function initPlatformer() {
            const game = initSimpleGame('platformer');
            const canvas = document.getElementById('platformerCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const player = { x: 50, y: 380, width: 25, height: 30, vy: 0, jumping: false };
            const platforms = [
                { x: 0, y: 450, width: 500, height: 20 },
                { x: 350, y: 380, width: 100, height: 15 },
                { x: 50, y: 310, width: 100, height: 15 },
                { x: 250, y: 240, width: 120, height: 15 }
            ];
            const coins = [];

            for (let i = 0; i < 5; i++) {
                coins.push({ x: Math.random() * 450, y: Math.random() * 200 + 50, radius: 8 });
            }

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') player.x -= 8;
                if (e.key === 'ArrowRight') player.x += 8;
                if ((e.key === ' ' || e.key === 'ArrowUp') && !player.jumping) {
                    player.vy = -12;
                    player.jumping = true;
                }
                player.x = Math.max(0, Math.min(475, player.x));
            });

            function animate() {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, 500, 500);

                player.vy += 0.5;
                player.y += player.vy;

                let onPlatform = false;
                platforms.forEach(p => {
                    if (player.y + player.height >= p.y && player.y + player.height <= p.y + 10 &&
                        player.x + player.width > p.x && player.x < p.x + p.width &&
                        player.vy >= 0) {
                        player.vy = 0;
                        player.y = p.y - player.height;
                        player.jumping = false;
                        onPlatform = true;
                    }
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(p.x, p.y, p.width, p.height);
                });

                coins.forEach((c, i) => {
                    if (Math.hypot(player.x - c.x, player.y - c.y) < 20) {
                        game.addScore(5);
                        coins.splice(i, 1);
                        coins.push({ x: Math.random() * 450, y: Math.random() * 200 + 50, radius: 8 });
                    }
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                if (player.y > 500) {
                    game.loseLife();
                    player.y = 380;
                }

                ctx.fillStyle = '#FF6347';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== BALL MAZE ==========
        function initBallMaze() {
            const game = initSimpleGame('ballmaze');
            const canvas = document.getElementById('ballmazeCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const ball = { x: 250, y: 250, radius: 10, vx: 0, vy: 0 };
            const goal = { x: 450, y: 450, radius: 20 };
            const walls = [
                { x: 100, y: 100, width: 150, height: 20 },
                { x: 250, y: 200, width: 20, height: 150 },
                { x: 300, y: 100, width: 100, height: 20 }
            ];

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') ball.vx = -4;
                if (e.key === 'ArrowRight') ball.vx = 4;
                if (e.key === 'ArrowUp') ball.vy = -4;
                if (e.key === 'ArrowDown') ball.vy = 4;
            });

            function animate() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.vx *= 0.95;
                ball.vy *= 0.95;

                ball.x = Math.max(ball.radius, Math.min(500 - ball.radius, ball.x));
                ball.y = Math.max(ball.radius, Math.min(500 - ball.radius, ball.y));

                walls.forEach(w => {
                    if (ball.x > w.x && ball.x < w.x + w.width &&
                        ball.y > w.y && ball.y < w.y + w.height) {
                        if (ball.vx > 0) ball.x = w.x - ball.radius;
                        if (ball.vx < 0) ball.x = w.x + w.width + ball.radius;
                        if (ball.vy > 0) ball.y = w.y - ball.radius;
                        if (ball.vy < 0) ball.y = w.y + w.height + ball.radius;
                        ball.vx *= -0.5;
                        ball.vy *= -0.5;
                    }
                    ctx.fillStyle = '#ff6600';
                    ctx.fillRect(w.x, w.y, w.width, w.height);
                });

                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(goal.x, goal.y, goal.radius, 0, Math.PI * 2);
                ctx.fill();

                if (Math.hypot(ball.x - goal.x, ball.y - goal.y) < 30) {
                    game.addScore(50);
                    ball.x = 250; ball.y = 250;
                    ball.vx = 0; ball.vy = 0;
                }

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== LIGHTS OUT ==========
        function initLightsOut() {
            const game = initSimpleGame('lightsout');
            const gameArea = document.getElementById('lightsoutGameArea');
            if (!gameArea) return;

            gameArea.innerHTML = '';
            gameArea.style.display = 'grid';
            gameArea.style.gridTemplateColumns = 'repeat(5, 1fr)';
            gameArea.style.gap = '5px';
            gameArea.style.padding = '20px';

            const lights = [];
            for (let i = 0; i < 25; i++) {
                const light = document.createElement('div');
                light.style.cssText = 'width:50px;height:50px;background:#ffff00;border-radius:50%;cursor:pointer;transition:background 0.2s;box-shadow:0 0 10px #ff8800';
                light.dataset.on = 'true';

                light.addEventListener('click', () => {
                    lights.forEach(l => {
                        l.dataset.on = l.dataset.on === 'true' ? 'false' : 'true';
                        l.style.background = l.dataset.on === 'true' ? '#ffff00' : '#333333';
                        l.style.boxShadow = l.dataset.on === 'true' ? '0 0 10px #ff8800' : 'none';
                    });
                    game.addScore(5);

                    const allOff = lights.every(l => l.dataset.on === 'false');
                    if (allOff) alert(`Level complete! Score: ${game.score}`);
                });

                gameArea.appendChild(light);
                lights.push(light);
            }

            lights.forEach(l => {
                l.style.background = Math.random() > 0.7 ? '#333333' : '#ffff00';
                l.dataset.on = l.style.background === '#ffff00' ? 'true' : 'false';
            });
        }

        // ========== SOKOBAN ==========
        function initSokoban() {
            const game = initSimpleGame('sokoban');
            const canvas = document.getElementById('sokobanCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const cellSize = 50;
            const player = { x: 1, y: 1 };
            const box = { x: 3, y: 3 };
            const goal = { x: 7, y: 7 };
            const walls = [{ x: 4, y: 2 }, { x: 4, y: 4 }, { x: 6, y: 3 }];

            window.addEventListener('keydown', (e) => {
                let nx = player.x, ny = player.y;
                if (e.key === 'ArrowLeft') nx--;
                if (e.key === 'ArrowRight') nx++;
                if (e.key === 'ArrowUp') ny--;
                if (e.key === 'ArrowDown') ny++;

                if (!walls.some(w => w.x === nx && w.y === ny)) {
                    if (box.x === nx && box.y === ny) {
                        const bx = nx + (nx - player.x);
                        const by = ny + (ny - player.y);
                        if (!walls.some(w => w.x === bx && w.y === by)) {
                            box.x = bx; box.y = by;
                            player.x = nx; player.y = ny;
                            if (box.x === goal.x && box.y === goal.y) {
                                game.addScore(100);
                                alert('Level complete!');
                            }
                        }
                    } else {
                        player.x = nx; player.y = ny;
                    }
                }
            });

            function animate() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, 500, 500);

                walls.forEach(w => {
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(w.x * cellSize, w.y * cellSize, cellSize - 2, cellSize - 2);
                });

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(goal.x * cellSize + cellSize / 2, goal.y * cellSize + cellSize / 2, 15, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ff6633';
                ctx.fillRect(box.x * cellSize, box.y * cellSize, cellSize - 2, cellSize - 2);

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(player.x * cellSize, player.y * cellSize, cellSize - 2, cellSize - 2);

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== DOT CHASE ==========
        function initDotChase() {
            const game = initSimpleGame('dotchase');
            const canvas = document.getElementById('dotchaseCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const player = { x: 250, y: 250, radius: 8 };
            let dot = { x: Math.random() * 480 + 10, y: Math.random() * 480 + 10, radius: 5 };

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                player.x = e.clientX - rect.left;
                player.y = e.clientY - rect.top;
            });

            function animate() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
                ctx.fill();

                if (Math.hypot(player.x - dot.x, player.y - dot.y) < 15) {
                    game.addScore(10);
                    dot = { x: Math.random() * 480 + 10, y: Math.random() * 480 + 10, radius: 5 };
                }

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== WORD SCRAMBLE ==========
        function initWordScramble() {
            const game = initSimpleGame('wordscramble');
            const gameArea = document.getElementById('wordscrambleGameArea');
            if (!gameArea) return;

            const words = ['JAVASCRIPT', 'GAMING', 'PUZZLE', 'ADVENTURE', 'CHALLENGE', 'PLAYER'];
            const word = words[Math.floor(Math.random() * words.length)];
            const scrambled = word.split('').sort(() => Math.random() - 0.5).join('');

            gameArea.innerHTML = `
                <div style="padding:20px;text-align:center">
                    <h3 style="margin:10px 0">Unscramble the word:</h3>
                    <div style="font-size:24px;font-weight:bold;margin:20px 0;letter-spacing:5px">${scrambled}</div>
                    <input id="wordGuess" type="text" style="padding:10px;font-size:16px;width:200px" placeholder="Your answer">
                    <button onclick="checkWord()" style="padding:10px 20px;margin:10px;cursor:pointer">Check</button>
                </div>
            `;

            window.checkWord = function () {
                const guess = document.getElementById('wordGuess').value.toUpperCase();
                if (guess === word) {
                    game.addScore(20);
                    alert('Correct!');
                    initWordScramble();
                } else {
                    alert('Try again!');
                }
            };
        }

        // ========== BOUNCE MANIA ==========
        function initBounceMania() {
            const game = initSimpleGame('bouncemania');
            const canvas = document.getElementById('bouncemaniaCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const balls = [];
            const targets = [];

            for (let i = 0; i < 5; i++) {
                targets.push({ x: Math.random() * 450, y: Math.random() * 300 + 50, radius: 15, active: true });
            }

            window.addEventListener('click', (e) => {
                if (canvas && e.target === canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    balls.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, radius: 6 });
                }
            });

            function animate() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);

                balls.forEach((b, bi) => {
                    b.x += b.vx;
                    b.y += b.vy;

                    if (b.x - b.radius < 0 || b.x + b.radius > 500) b.vx *= -1;
                    if (b.y - b.radius < 0 || b.y + b.radius > 500) b.vy *= -1;

                    b.x = Math.max(b.radius, Math.min(500 - b.radius, b.x));
                    b.y = Math.max(b.radius, Math.min(500 - b.radius, b.y));

                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                targets.forEach(t => {
                    if (t.active) {
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                        ctx.fill();

                        balls.forEach((b, bi) => {
                            if (Math.hypot(b.x - t.x, b.y - t.y) < t.radius + b.radius) {
                                t.active = false;
                                game.addScore(15);
                            }
                        });
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== MINE SLIDE ==========
        function initMineSlide() {
            const game = initSimpleGame('mineslide');
            const canvas = document.getElementById('mineslideCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const player = { x: 250, y: 50, vy: 0 };
            const mines = [];

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') player.x -= 10;
                if (e.key === 'ArrowRight') player.x += 10;
                player.x = Math.max(0, Math.min(500, player.x));
            });

            function animate() {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, 500, 500);

                if (Math.random() < 0.02) {
                    mines.push({ x: Math.random() * 480 + 10, y: -20, vy: 3 });
                }

                mines.forEach((m, i) => {
                    m.y += m.vy;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(m.x - 8, m.y - 8, 16, 16);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(m.x - 4, m.y - 4, 8, 8);

                    if (Math.abs(m.x - player.x) < 20 && Math.abs(m.y - player.y) < 20) {
                        game.loseLife();
                        mines.splice(i, 1);
                    }
                    if (m.y > 500) mines.splice(i, 1);
                });

                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(player.x, player.y, 12, 0, Math.PI * 2);
                ctx.fill();

                requestAnimationFrame(animate);
            }

            animate();
        }

        // ========== GENERAL GAME STUBS - All Remaining Games ==========
        function initColorBlind() {
            const game = initSimpleGame('colorblind');
            const gameArea = document.getElementById('colorblindGameArea');
            if (!gameArea) return;
            gameArea.innerHTML = '<div style="padding:20px;text-align:center"><h3>Find the different color!</h3><div id="colorGrid" style="display:grid;grid-template-columns:repeat(4,80px);gap:10px;padding:20px"></div></div>';

            const colors = ['#ff0000', '#ff0000', '#ff0000', '#00ff00'];
            colors.sort(() => Math.random() - 0.5);

            const grid = document.getElementById('colorGrid');
            colors.forEach(color => {
                const box = document.createElement('div');
                box.style.cssText = `width:80px;height:80px;background:${color};cursor:pointer;border-radius:8px`;
                box.addEventListener('click', () => {
                    if (color === '#00ff00') {
                        game.addScore(20);
                        initColorBlind();
                    }
                });
                grid.appendChild(box);
            });
        }

        function initNumberJump() {
            const game = initSimpleGame('numberjump');
            const gameArea = document.getElementById('numberjumpGameArea');
            if (!gameArea) return;

            gameArea.innerHTML = '';
            const numbers = Array.from({ length: 20 }, (_, i) => i + 1).sort(() => Math.random() - 0.5);

            gameArea.style.display = 'grid';
            gameArea.style.gridTemplateColumns = 'repeat(5, 1fr)';
            gameArea.style.gap = '10px';
            gameArea.style.padding = '20px';

            let nextNum = 1;
            numbers.forEach(num => {
                const btn = document.createElement('button');
                btn.textContent = num;
                btn.style.cssText = 'padding:15px;font-size:16px;cursor:pointer;border-radius:8px;background:#667eea;color:white;border:none';
                btn.addEventListener('click', () => {
                    if (num === nextNum) {
                        btn.disabled = true;
                        game.addScore(5);
                        nextNum++;
                        if (nextNum > 20) alert(`Complete! Score: ${game.score}`);
                    }
                });
                gameArea.appendChild(btn);
            });
        }

        function initDragonSlayer() {
            const game = initSimpleGame('dragonslayer');
            const canvas = document.getElementById('dragonslayerCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const player = { x: 50, y: 400, width: 30, height: 40 };
            const dragon = { x: 400, y: 200, width: 60, height: 60, health: 100 };
            const fireballs = [];

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' && player.y > 50) player.y -= 10;
                if (e.key === 'ArrowDown' && player.y < 450) player.y += 10;
                if (e.key === ' ') fireballs.push({ x: player.x + 30, y: player.y + 20, vx: 5 });
            });

            function animate() {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, 500, 500);

                ctx.fillStyle = '#00ff00';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                ctx.fillStyle = '#ff0000';
                ctx.fillRect(dragon.x, dragon.y, dragon.width, dragon.height);
                ctx.fillText(`Health: ${dragon.health}`, dragon.x, dragon.y - 10);

                fireballs.forEach((f, i) => {
                    f.x += f.vx;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, 5, 0, Math.PI * 2);
                    ctx.fill();

                    if (f.x > dragon.x && f.x < dragon.x + dragon.width &&
                        f.y > dragon.y && f.y < dragon.y + dragon.height) {
                        dragon.health -= 10;
                        game.addScore(10);
                        fireballs.splice(i, 1);

                        if (dragon.health <= 0) {
                            game.addScore(50);
                            alert('Dragon defeated!');
                        }
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        function initFishFeed() {
            const game = initSimpleGame('fishfeed');
            const gameArea = document.getElementById('fishfeedGameArea');
            if (!gameArea) return;

            gameArea.innerHTML = '<div style="padding:20px;text-align:center"><h2> Feed the Fish! </h2><p>Click to drop food pellets</p></div>';
            const canvas = document.createElement('canvas');
            canvas.width = 500; canvas.height = 400;
            canvas.style.cssText = 'background:linear-gradient(to bottom, #87CEEB, #0066cc);';
            gameArea.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const fish = { x: 250, y: 200, width: 40, height: 25 };
            const food = [];

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                food.push({ x: e.clientX - rect.left, y: e.clientY - rect.top, vy: 2 });
            });

            function animate() {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';
                ctx.fillRect(0, 0, 500, 400);

                food.forEach((f, i) => {
                    f.y += f.vy;
                    ctx.fillStyle = '#ff8800';
                    ctx.fillRect(f.x - 3, f.y - 3, 6, 6);

                    if (f.x > fish.x && f.x < fish.x + fish.width && f.y > fish.y && f.y < fish.y + fish.height) {
                        game.addScore(5);
                        food.splice(i, 1);
                    }
                });

                ctx.fillStyle = '#ff6600';
                ctx.fillRect(fish.x, fish.y, fish.width, fish.height);

                requestAnimationFrame(animate);
            }

            animate();
        }

        // All remaining games use simplified placeholder logic
        function initPigsFly() {
            const game = initSimpleGame('pigsfly');
            const gameArea = document.getElementById('pigsflyGameArea');
            if (gameArea) gameArea.innerHTML = '<div style="padding:50px;text-align:center"><h3> Pigs Fly! </h3><p>Launch pigs to targets - Click canvas to aim and shoot!</p><canvas id="pigsflyCanvas" width="500" height="400"></canvas></div>';
        }

        function initBricksBreaker2() {
            const game = initSimpleGame('bricksbreaker2');
            const gameArea = document.getElementById('bricksbreaker2GameArea');
            if (gameArea) gameArea.innerHTML = '<div style="padding:50px;text-align:center"><h3>Brick Breaker 2</h3><canvas id="bricksbreaker2Canvas" width="500" height="500"></canvas></div>';
        }

        function initSlideBlock() {
            const game = initSimpleGame('slideblock');
            const gameArea = document.getElementById('slideblockGameArea');
            if (gameArea) {
                gameArea.innerHTML = '<div style="display:grid;grid-template-columns:repeat(3,60px);gap:5px;padding:20px"><div style="background:#667eea;width:60px;height:60px;cursor:move"></div><div style="background:#667eea;width:60px;height:60px;cursor:move"></div><div style="background:#667eea;width:60px;height:60px;cursor:move"></div></div>';
            }
        }

        function initAsteroidShoot() {
            const game = initSimpleGame('asteroidshoot');
            game.score += 0;
        }

        function initGhostHunt() {
            const game = initSimpleGame('ghosthunt');
            game.score += 0;
        }

        function initTowerStack() {
            const game = initSimpleGame('towerstack');
            game.score += 0;
        }

        function initScrollMatch() {
            const game = initSimpleGame('scrollmatch');
            game.score += 0;
        }

        function initStarfield() {
            const game = initSimpleGame('starfield');
            const canvas = document.getElementById('starfieldCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const stars = Array(100).fill(null).map(() => ({ x: Math.random() * 500, y: Math.random() * 500, radius: Math.random() * 1.5 }));

            function animate() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 500, 500);
                ctx.fillStyle = '#fff';
                stars.forEach(s => {
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                requestAnimationFrame(animate);
            }
            animate();
        }
        function initLocksmith() {
            let score = 0;
            let code = [];
            let correctCode = [1, 2, 3, 4];
            const codeDisplay = document.getElementById('locksmithCode') || document.createElement('div');
            const buttons = document.querySelectorAll('[data-locksmith-btn]');
            const resetBtn = document.querySelector('[data-locksmith-reset]');

            buttons.forEach((btn, index) => {
                btn.addEventListener('click', () => {
                    code.push(index + 1);
                    codeDisplay.textContent = code.join('-');
                    if (code.length === correctCode.length) {
                        if (code.every((val, idx) => val === correctCode[idx])) {
                            score += 100;
                            code = [];
                            correctCode = Array.from({ length: 4 }, () => Math.floor(Math.random() * 4) + 1);
                            codeDisplay.textContent = 'UNLOCKED! +100';
                        } else {
                            codeDisplay.textContent = 'WRONG!';
                            code = [];
                        }
                    }
                });
            });
            if (resetBtn) resetBtn.addEventListener('click', () => { code = []; codeDisplay.textContent = ''; });
        }

        function initSpiderWeb() {
            let score = 0;
            let lives = 3;
            let gameActive = true;
            const gameArea = document.getElementById('spiderwebGameArea');
            const scoreDisplay = document.getElementById('spiderwebScore');
            const livesDisplay = document.getElementById('spiderwebLives');
            if (!gameArea) return;

            function createWeb() {
                gameArea.innerHTML = '';
                for (let i = 0; i < 5; i++) {
                    const web = document.createElement('div');
                    web.style.position = 'absolute';
                    web.style.left = Math.random() * 80 + '%';
                    web.style.top = Math.random() * 80 + '%';
                    web.style.width = '30px';
                    web.style.height = '30px';
                    web.style.background = '#888';
                    web.style.borderRadius = '50%';
                    web.style.cursor = 'pointer';
                    web.style.border = '2px solid #666';
                    web.addEventListener('mouseenter', () => { lives--; updateDisplay(); });
                    gameArea.appendChild(web);
                }
            }

            function updateDisplay() {
                scoreDisplay.textContent = score;
                livesDisplay.textContent = lives;
                if (lives <= 0) gameActive = false;
            }

            gameArea.addEventListener('click', (e) => {
                if (e.target.style.background === 'rgb(136, 136, 136)') {
                    score += 10;
                    updateDisplay();
                    createWeb();
                }
            });

            createWeb();
            updateDisplay();
        }

        function initJetpack() {
            let score = 0;
            let playerY = 200;
            let velocity = 0;
            let gameActive = true;
            const gravity = 0.5;
            const canvas = document.getElementById('jetpackCanvas') || document.createElement('canvas');
            if (!canvas.parentElement) document.getElementById('jetpackView').appendChild(canvas);
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 600;

            function drawPlayer() {
                ctx.fillStyle = '#FF6B6B';
                ctx.fillRect(150, playerY, 100, 50);
                ctx.fillStyle = '#FFA07A';
                ctx.fillRect(160, playerY + 30, 20, 30);
                ctx.fillRect(220, playerY + 30, 20, 30);
            }

            function drawObstacles() {
                ctx.fillStyle = '#333';
                for (let i = 0; i < 5; i++) {
                    const x = (i * 100 + score / 10) % 500;
                    ctx.fillRect(x, i * 150, 40, 20);
                }
            }

            function update() {
                if (!gameActive) return;
                velocity += gravity;
                playerY += velocity;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawObstacles();
                drawPlayer();
                score += 1;
                if (playerY > canvas.height || playerY < 0) gameActive = false;
                requestAnimationFrame(update);
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === ' ') velocity = -8;
            });

            update();
        }

        function initMoneyStack() {
            let score = 0;
            let stackHeight = 0;
            let gameActive = true;
            const gameArea = document.getElementById('moneystackGameArea');
            const scoreDisplay = document.getElementById('moneystackScore');
            if (!gameArea) return;

            const stack = document.createElement('div');
            stack.style.position = 'relative';
            stack.style.width = '200px';
            stack.style.height = '400px';
            stack.style.margin = '20px auto';
            stack.style.border = '2px solid #999';
            gameArea.appendChild(stack);

            function addCoin() {
                const coin = document.createElement('div');
                coin.style.position = 'absolute';
                coin.style.bottom = stackHeight + 'px';
                coin.style.left = '75px';
                coin.style.width = '50px';
                coin.style.height = '20px';
                coin.style.background = 'linear-gradient(45deg, #FFD700, #FFA500)';
                coin.style.borderRadius = '50%';
                coin.style.display = 'flex';
                coin.style.alignItems = 'center';
                coin.style.justifyContent = 'center';
                coin.style.fontWeight = 'bold';
                coin.textContent = '$';
                stack.appendChild(coin);
                stackHeight += 22;
                score += 10;
                scoreDisplay.textContent = score;
                if (stackHeight < 380) setTimeout(addCoin, 500);
                else gameActive = false;
            }

            addCoin();
        }

        function initClockwork() {
            let score = 0;
            let sequence = [];
            let playerSequence = [];
            let round = 1;
            const colors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#95E1D3'];
            const gameArea = document.getElementById('clockworkGameArea');
            if (!gameArea) return;

            function playRound() {
                sequence.push(Math.floor(Math.random() * 4));
                playerSequence = [];
                playSequence();
            }

            function playSequence() {
                let delay = 0;
                sequence.forEach((index) => {
                    setTimeout(() => {
                        const button = gameArea.children[index];
                        button.style.opacity = '0.5';
                        setTimeout(() => button.style.opacity = '1', 300);
                    }, delay);
                    delay += 600;
                });
            }

            colors.forEach((color, index) => {
                const button = document.createElement('div');
                button.style.width = '100px';
                button.style.height = '100px';
                button.style.background = color;
                button.style.margin = '10px';
                button.style.cursor = 'pointer';
                button.style.borderRadius = '10px';
                button.addEventListener('click', () => {
                    playerSequence.push(index);
                    if (playerSequence[playerSequence.length - 1] !== sequence[playerSequence.length - 1]) {
                        score = round * 10;
                        playerSequence = [];
                        sequence = [];
                        round = 1;
                        setTimeout(playRound, 1000);
                    } else if (playerSequence.length === sequence.length) {
                        round++;
                        score = round * 10;
                        setTimeout(playRound, 1000);
                    }
                });
                gameArea.appendChild(button);
            });

            playRound();
        }

        function initCloudWalk() {
            let score = 0;
            let playerX = 150;
            let gameActive = true;
            const gameArea = document.getElementById('cloudwalkGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '500px';
            gameArea.style.overflow = 'hidden';

            const player = document.createElement('div');
            player.style.position = 'absolute';
            player.style.bottom = '20px';
            player.style.left = playerX + 'px';
            player.style.width = '40px';
            player.style.height = '40px';
            player.style.background = '#FFD700';
            player.style.borderRadius = '50%';
            gameArea.appendChild(player);

            function updatePlayer() {
                player.style.left = playerX + 'px';
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && playerX > 0) playerX -= 20;
                if (e.key === 'ArrowRight' && playerX < 300) playerX += 20;
                updatePlayer();
            });

            score += 1;
        }

        function initGravitas() {
            let score = 0;
            const gameArea = document.getElementById('gravitasGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.background = 'linear-gradient(to bottom, #000033, #0a0a2e)';

            const ball = document.createElement('div');
            ball.style.position = 'absolute';
            ball.style.width = '20px';
            ball.style.height = '20px';
            ball.style.background = '#FF6B9D';
            ball.style.borderRadius = '50%';
            ball.style.top = '50px';
            ball.style.left = '150px';
            gameArea.appendChild(ball);

            let ballY = 50;
            let ballX = 150;
            let velocityY = 0;
            let velocityX = 0;

            function animate() {
                velocityY += 0.5;
                ballY += velocityY;
                ballX += velocityX;
                ball.style.top = ballY + 'px';
                ball.style.left = ballX + 'px';
                if (ballY > 400) ballY = 0;
                requestAnimationFrame(animate);
            }

            gameArea.addEventListener('click', (e) => {
                ballX = e.offsetX;
                ballY = e.offsetY;
                velocityY = 0;
                score += 10;
            });

            animate();
        }

        function initMotionFlash() {
            let score = 0;
            let pattern = [];
            const gameArea = document.getElementById('motionflashGameArea');
            if (!gameArea) return;

            function generatePattern() {
                for (let i = 0; i < 5; i++) {
                    pattern.push({ x: Math.random() * 300, y: Math.random() * 300, color: `hsl(${Math.random() * 360}, 100%, 50%)` });
                }
            }

            function drawPattern() {
                gameArea.innerHTML = '';
                pattern.forEach(item => {
                    const box = document.createElement('div');
                    box.style.position = 'absolute';
                    box.style.left = item.x + 'px';
                    box.style.top = item.y + 'px';
                    box.style.width = '30px';
                    box.style.height = '30px';
                    box.style.background = item.color;
                    box.style.borderRadius = '5px';
                    box.style.cursor = 'pointer';
                    box.addEventListener('click', () => { score += 10; });
                    gameArea.appendChild(box);
                });
            }

            generatePattern();
            drawPattern();
        }

        function initWindRunner() {
            let score = 0;
            let playerX = 150;
            let playerY = 300;
            let gameActive = true;
            const gameArea = document.getElementById('windrunnerGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.overflow = 'hidden';

            const player = document.createElement('div');
            player.style.position = 'absolute';
            player.style.width = '30px';
            player.style.height = '30px';
            player.style.background = '#FF6B6B';
            player.style.borderRadius = '50%';
            gameArea.appendChild(player);

            let windForce = 0;
            function animate() {
                windForce = Math.sin(Date.now() / 1000) * 5;
                playerX += windForce;
                playerY -= 1;
                player.style.left = playerX + 'px';
                player.style.top = playerY + 'px';
                if (playerY < 0) playerY = 400;
                score += 1;
                requestAnimationFrame(animate);
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') playerY -= 20;
                if (e.key === 'ArrowDown') playerY += 20;
            });

            animate();
        }

        function initIceSlide() {
            let score = 0;
            let playerX = 150;
            let playerY = 350;
            let velocityX = 0;
            const friction = 0.95;
            const gameArea = document.getElementById('iceslideGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.overflow = 'hidden';
            gameArea.style.background = 'linear-gradient(to bottom, #87CEEB, #E0F6FF)';

            const player = document.createElement('div');
            player.style.position = 'absolute';
            player.style.width = '40px';
            player.style.height = '20px';
            player.style.background = '#4472CA';
            player.style.borderRadius = '10px';
            gameArea.appendChild(player);

            function update() {
                velocityX *= friction;
                playerX += velocityX;
                if (playerX < 0) playerX = 0;
                if (playerX > 360) playerX = 360;
                player.style.left = playerX + 'px';
                player.style.top = playerY + 'px';
                score += 1;
                requestAnimationFrame(update);
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') velocityX = -10;
                if (e.key === 'ArrowRight') velocityX = 10;
            });

            update();
        }

        function initFireBurst() {
            let score = 0;
            let gameActive = true;
            const gameArea = document.getElementById('fireburstGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';

            function createFlame() {
                const flame = document.createElement('div');
                flame.style.position = 'absolute';
                flame.style.left = Math.random() * 300 + 'px';
                flame.style.top = '0px';
                flame.style.width = '20px';
                flame.style.height = '20px';
                flame.style.background = '#FF4500';
                flame.style.borderRadius = '50%';
                flame.style.cursor = 'pointer';
                gameArea.appendChild(flame);

                let top = 0;
                const interval = setInterval(() => {
                    top += 5;
                    flame.style.top = top + 'px';
                    if (top > 400) {
                        clearInterval(interval);
                        flame.remove();
                    }
                }, 30);

                flame.addEventListener('click', () => {
                    score += 10;
                    clearInterval(interval);
                    flame.remove();
                });
            }

            const spawnInterval = setInterval(() => {
                if (gameActive) createFlame();
            }, 800);

            setTimeout(() => { gameActive = false; clearInterval(spawnInterval); }, 30000);
        }

        function initWaterFlow() {
            let score = 0;
            let waterLevel = 0;
            const gameArea = document.getElementById('waterflowGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.background = '#87CEEB';

            const water = document.createElement('div');
            water.style.position = 'absolute';
            water.style.bottom = '0px';
            water.style.width = '100%';
            water.style.height = waterLevel + 'px';
            water.style.background = '#1E90FF';
            gameArea.appendChild(water);

            const interval = setInterval(() => {
                waterLevel += 5;
                water.style.height = waterLevel + 'px';
                score += 1;
                if (waterLevel > 400) {
                    clearInterval(interval);
                }
            }, 100);
        }

        function initShadowJump() {
            let score = 0;
            let playerY = 350;
            let velocityY = 0;
            const jumpPower = -15;
            const gravity = 0.6;
            const gameArea = document.getElementById('shadowjumpGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.background = 'linear-gradient(to bottom, #1a1a2e, #16213e)';

            const player = document.createElement('div');
            player.style.position = 'absolute';
            player.style.width = '30px';
            player.style.height = '30px';
            player.style.background = '#0f3460';
            player.style.borderRadius = '50%';
            player.style.left = '185px';
            gameArea.appendChild(player);

            function update() {
                velocityY += gravity;
                playerY += velocityY;
                if (playerY > 370) playerY = 370;
                player.style.top = playerY + 'px';
                score += 1;
                requestAnimationFrame(update);
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === ' ' && playerY > 360) velocityY = jumpPower;
            });

            update();
        }

        function initLightBurst() {
            let score = 0;
            let clicks = 0;
            const gameArea = document.getElementById('lightburstGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.background = '#1a1a1a';

            function createLight() {
                const light = document.createElement('div');
                light.style.position = 'absolute';
                light.style.left = Math.random() * 300 + 'px';
                light.style.top = Math.random() * 350 + 'px';
                light.style.width = '30px';
                light.style.height = '30px';
                light.style.background = 'radial-gradient(circle, #FFFF00, #FFA500)';
                light.style.borderRadius = '50%';
                light.style.cursor = 'pointer';
                light.style.boxShadow = '0 0 20px #FFFF00';
                gameArea.appendChild(light);

                light.addEventListener('click', () => {
                    score += 10;
                    light.remove();
                });

                setTimeout(() => light.remove(), 3000);
            }

            const interval = setInterval(createLight, 600);
            setTimeout(() => clearInterval(interval), 30000);
        }

        function initEnergyFlow() {
            let score = 0;
            const gameArea = document.getElementById('energyflowGameArea');
            if (!gameArea) return;
            gameArea.style.position = 'relative';
            gameArea.style.height = '400px';
            gameArea.style.background = '#0a0e27';

            const particles = [];
            function createParticle() {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.left = '200px';
                particle.style.top = '200px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.background = '#00FF00';
                particle.style.borderRadius = '50%';
                particle.style.boxShadow = '0 0 10px #00FF00';
                gameArea.appendChild(particle);

                let x = 200;
                let y = 200;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 2;

                const updateParticle = () => {
                    x += Math.cos(angle) * speed;
                    y += Math.sin(angle) * speed;
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    if (x < 0 || x > 400 || y < 0 || y > 400) {
                        particle.remove();
                    } else {
                        requestAnimationFrame(updateParticle);
                    }
                };

                updateParticle();
            }

            setInterval(createParticle, 100);
        }

        function initCrystalGem() { initSimpleGame('crystalgem'); }
        function initVolcanoRun() { initSimpleGame('volcanorun'); }
        function initDesertBlast() { initSimpleGame('desertblast'); }
        function initFrozenQuest() { initSimpleGame('frozenquest'); }
        function initJurassic() { initSimpleGame('jurassic'); }
        function initDeepSeaDive() { initSimpleGame('deepseadive'); }
        function initForestWalk() { initSimpleGame('forestwalk'); }
        function initSkyGlide() { initSimpleGame('skyglide'); }
        function initMoonBase() { initSimpleGame('moonbase'); }
        function initSunBurst() { initSimpleGame('sunburst'); }
        function initRainbowRace() { initSimpleGame('rainbowrace'); }
        function initThunderStrike() { initSimpleGame('thunderstrike'); }
        function initStormChasers() { initSimpleGame('stormchasers'); }
        function initBlizzardRun() { initSimpleGame('blizzardrun'); }
        function initTornado() { initSimpleGame('tornado'); }
        function initMeteorStrike() { initSimpleGame('meteorstrike'); }
        function initGalaxyDef() { initSimpleGame('galaxydef'); }
        function initNebula() { initSimpleGame('nebula'); }
        function initBlackHole() { initSimpleGame('blackhole'); }
        function initWarpDrive() { initSimpleGame('warpdrive'); }
        function initPulseWave() { initSimpleGame('pulsewave'); }
    </script>
    <script>
        // Global epilepsy-mode toggle: persists in localStorage and toggles body class
        (function epilepsyModeActivate() {
            const key = 'gamecenter.epilepsyMode';
            const btn = document.getElementById('epilepsyToggle');
            function setMode(on) {
                if (on) {
                    document.documentElement.classList.add('epilepsy-mode');
                    btn.classList.add('active');
                    btn.textContent = ' Epilepsy ON';
                } else {
                    document.documentElement.classList.remove('epilepsy-mode');
                    btn.classList.remove('active');
                    btn.textContent = ' Epilepsy';
                }
                localStorage.setItem(key, on ? '1' : '0');
            }
            if (btn) {
                const stored = localStorage.getItem(key);
                setMode(stored === '1');
                btn.addEventListener('click', () => setMode(!document.documentElement.classList.contains('epilepsy-mode')));
            }
        })();
    </script>
    <style>
        :root {
            --bg: #0b0f18;
            --panel: #0f1628;
            --ink: #e9f0ff;
            --muted: #a9b7d9;
            --accent: #66aaff;
            --danger: #ff6b6b;
            --ok: #22c55e;
            --btn: #151e36;
            --btn2: #132038;
            --grid-gap: 10px;
            --radius: 14px;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            --calc-bg-mode: linear-gradient;
            /* 'solid' or 'linear-gradient' */
            --calc-bg-color1: #0f1628;
            --calc-bg-color2: #0d1426;
            --calc-bg-angle: 180deg;
            --epilepsy-color1: #ff0022;
            --epilepsy-color2: #0033ff;
            --epilepsy-speed: 0.1ms;
            --epilepsy-colorful-speed: 0.1ms;
        }
    </style>
    <script>
        function goToCalculator() {
            window.location.href = "src/core/calculator.html"
        }
        </script>
    <script src="../games-missing.js"></script>
</body>

</html>
